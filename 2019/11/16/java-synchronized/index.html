<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="synchronized关键字原理在我个人看来应该是java中最难的几个问题之一了。其用法不难，但里面涉及的知识点很多。它作为关键字提供了并发环境中多线程的同步机制，但就是因此，我们无法直观的看到它的源码，从而很难探究它的底层原理。 synchronized用法synchronized可以修饰方法或者代码块：  方法： 静态方法 实例方法   代码块： 实例对象 class对象    我们不会看它">
<meta property="og:type" content="article">
<meta property="og:title" content="Synchronized原理剖析">
<meta property="og:url" content="https://blog.yangx.site/2019/11/16/java-synchronized/index.html">
<meta property="og:site_name" content="YXiao&#39;s Blog">
<meta property="og:description" content="synchronized关键字原理在我个人看来应该是java中最难的几个问题之一了。其用法不难，但里面涉及的知识点很多。它作为关键字提供了并发环境中多线程的同步机制，但就是因此，我们无法直观的看到它的源码，从而很难探究它的底层原理。 synchronized用法synchronized可以修饰方法或者代码块：  方法： 静态方法 实例方法   代码块： 实例对象 class对象    我们不会看它">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.yangx.site/images/monitor.png">
<meta property="og:image" content="https://blog.yangx.site/images/objectMonitor.png">
<meta property="article:published_time" content="2019-11-16T15:17:43.000Z">
<meta property="article:modified_time" content="2020-03-09T15:59:04.963Z">
<meta property="article:author" content="yxiao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.yangx.site/images/monitor.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Synchronized原理剖析</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
    <script data-ad-client="ca-pub-9170262800275390" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">文章</a></li>
         
          <li><a href="/categories/">目录</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/12/01/java-threadLocal/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/10/04/java-classloader/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://blog.yangx.site/2019/11/16/java-synchronized/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://blog.yangx.site/2019/11/16/java-synchronized/&text=Synchronized原理剖析" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://blog.yangx.site/2019/11/16/java-synchronized/&title=Synchronized原理剖析" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Synchronized原理剖析&body=Check out this article: https://blog.yangx.site/2019/11/16/java-synchronized/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized用法"><span class="toc-number">1.</span> <span class="toc-text">synchronized用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized作用于代码块"><span class="toc-number">1.1.</span> <span class="toc-text">synchronized作用于代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized作用于方法"><span class="toc-number">1.2.</span> <span class="toc-text">synchronized作用于方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#monitorenter、monitorexit和ACC-SYNCHRONIZED"><span class="toc-number">2.</span> <span class="toc-text">monitorenter、monitorexit和ACC_SYNCHRONIZED</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#monitorenter"><span class="toc-number">2.1.</span> <span class="toc-text">monitorenter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#monitorexit"><span class="toc-number">2.2.</span> <span class="toc-text">monitorexit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACC-SYNCHRONIZED"><span class="toc-number">2.3.</span> <span class="toc-text">ACC_SYNCHRONIZED</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#monitor监视器"><span class="toc-number">3.</span> <span class="toc-text">monitor监视器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统中的管程"><span class="toc-number">3.1.</span> <span class="toc-text">操作系统中的管程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ObjectMonitor"><span class="toc-number">3.2.</span> <span class="toc-text">ObjectMonitor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构（定义）"><span class="toc-number">3.2.1.</span> <span class="toc-text">数据结构（定义）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作原理"><span class="toc-number">3.2.2.</span> <span class="toc-text">工作原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象如何与monitor关联"><span class="toc-number">4.</span> <span class="toc-text">对象如何与monitor关联</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java对象内存布局"><span class="toc-number">4.1.</span> <span class="toc-text">Java对象内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象头"><span class="toc-number">4.2.</span> <span class="toc-text">对象头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mark-word"><span class="toc-number">4.3.</span> <span class="toc-text">Mark word</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mark-word中的重量锁"><span class="toc-number">4.4.</span> <span class="toc-text">Mark word中的重量锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#锁优化"><span class="toc-number">5.</span> <span class="toc-text">锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#自旋锁"><span class="toc-number">5.1.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁消除"><span class="toc-number">5.2.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁粗化"><span class="toc-number">5.3.</span> <span class="toc-text">锁粗化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁膨胀"><span class="toc-number">5.4.</span> <span class="toc-text">锁膨胀</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Synchronized原理剖析
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">YXiao's Blog</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-11-16T15:17:43.000Z" itemprop="datePublished">2019-11-16</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Java/">Java</a> › <a class="category-link" href="/categories/Java/Concurrency/">Concurrency</a>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>synchronized关键字原理在我个人看来应该是java中最难的几个问题之一了。其用法不难，但里面涉及的知识点很多。它作为关键字提供了并发环境中多线程的同步机制，但就是因此，我们无法直观的看到它的源码，从而很难探究它的底层原理。</p>
<h1 id="synchronized用法"><a href="#synchronized用法" class="headerlink" title="synchronized用法"></a>synchronized用法</h1><p>synchronized可以修饰方法或者代码块：</p>
<ul>
<li>方法：<ul>
<li>静态方法</li>
<li>实例方法</li>
</ul>
</li>
<li>代码块：<ul>
<li>实例对象</li>
<li>class对象</li>
</ul>
</li>
</ul>
<p>我们不会看它如何使用，而是主要探究其原理，同样的，本文适合对于synchronized关键字有一定使用经验的人。接下来通过反编译来看看它的究竟。</p>
<h2 id="synchronized作用于代码块"><a href="#synchronized作用于代码块" class="headerlink" title="synchronized作用于代码块"></a>synchronized作用于代码块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Solution<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"test synchronized"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过反编译可得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]) throws java.lang.InterruptedException;</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; class com&#x2F;leetcode&#x2F;Solution</span><br><span class="line">         2: dup</span><br><span class="line">         3: astore_1</span><br><span class="line">         4: monitorenter</span><br><span class="line">         5: getstatic     #3                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         8: ldc           #4                  &#x2F;&#x2F; String test synchronized</span><br><span class="line">        10: invokevirtual #5                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">        13: aload_1</span><br><span class="line">        14: monitorexit</span><br><span class="line">        15: goto          23</span><br><span class="line">        18: astore_2</span><br><span class="line">        19: aload_1</span><br><span class="line">        20: monitorexit</span><br><span class="line">        21: aload_2</span><br><span class="line">        22: athrow</span><br><span class="line">        23: return</span><br></pre></td></tr></table></figure>

<p>注意第4行的monitorenter和14行的monitorexit，也就是在synchronized作用于代码块时，JVM通过这两个指令进行了同步，那么它们如何保证同步的呢？我们后面会分析。</p>
<h2 id="synchronized作用于方法"><a href="#synchronized作用于方法" class="headerlink" title="synchronized作用于方法"></a>synchronized作用于方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test synchronized method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译可得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; String test synchronized method</span><br><span class="line">         5: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">         8: return</span><br></pre></td></tr></table></figure>

<p>注意到字节码的flags中多了一个ACC_SYNCHRONIZED，也就是synchronized作用于方法时，JVM在方法访问标识符flags中加入ACC_SYNCHRONIZED来实现同步。</p>
<h1 id="monitorenter、monitorexit和ACC-SYNCHRONIZED"><a href="#monitorenter、monitorexit和ACC-SYNCHRONIZED" class="headerlink" title="monitorenter、monitorexit和ACC_SYNCHRONIZED"></a>monitorenter、monitorexit和ACC_SYNCHRONIZED</h1><p>我们会根据oracle提供的jvm规范文档来介绍这三个指令。</p>
<h2 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h2><blockquote>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p>
<p>If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</p>
<p>If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.</p>
<p>If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</p>
</blockquote>
<p>翻译过来就是：</p>
<blockquote>
<p>每个对象都与一个monitor相关联。当且仅当拥有所有者时（被拥有），monitor才会被锁定。执行到monitorenter指令的线程，会尝试去获得对应的monitor，如下：</p>
<p>每个对象维护着一个记录着被锁次数的计数器, 对象未被锁定时，该计数器为0。线程进入monitor（执行monitorenter指令）时，会把计数器设置为1.</p>
<p>当同一个线程再次获得该对象的锁的时候，计数器再次自增.</p>
<p>当其他线程想获得该monitor的时候，就会阻塞，直到计数器为0才能成功。</p>
</blockquote>
<h2 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h2><blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.</p>
<p>The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>翻译过来就是：</p>
<blockquote>
<p>monitor的拥有者线程才能执行monitorexit指令。</p>
<p>线程执行monitorexit指令，就会让monitor的计数器减一。如果计数器为0，表明该线程不再拥有monitor。其他线程就允许尝试去获得该monitor了。</p>
</blockquote>
<h2 id="ACC-SYNCHRONIZED"><a href="#ACC-SYNCHRONIZED" class="headerlink" title="ACC_SYNCHRONIZED"></a>ACC_SYNCHRONIZED</h2><blockquote>
<p>Method-level synchronization is performed implicitly, as part of method invocation and return. A synchronized method is distinguished in the run-time constant pool’s method_info structure by the ACC_SYNCHRONIZED flag, which is checked by the method invocation instructions. When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly. During the time the executing thread owns the monitor, no other thread may enter it. If an exception is thrown during invocation of the synchronized method and the synchronized method does not handle the exception, the monitor for the method is automatically exited before the exception is rethrown out of the synchronized method.</p>
</blockquote>
<p>翻译过来就是：</p>
<blockquote>
<p>方法级别的同步是隐式的，作为方法调用的一部分。同步方法的常量池中会有一个ACC_SYNCHRONIZED标志。</p>
<p>当调用一个设置了ACC_SYNCHRONIZED标志的方法，执行线程需要先获得monitor锁，然后开始执行方法，方法执行之后再释放monitor锁，当方法不管是正常return还是抛出异常都会释放对应的monitor锁。</p>
<p>在这期间，如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。</p>
<p>如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。</p>
</blockquote>
<p>那么我们多次提到的monitor究竟是个什么东西呢？</p>
<h1 id="monitor监视器"><a href="#monitor监视器" class="headerlink" title="monitor监视器"></a>monitor监视器</h1><h2 id="操作系统中的管程"><a href="#操作系统中的管程" class="headerlink" title="操作系统中的管程"></a>操作系统中的管程</h2><p>我们都知道管程在操作系统中提供了一种机制，它提供线程间的互斥访问。</p>
<p>实际上，操作系统中的管程是概念原理，或者说是一种规范，而ObjectMonitor是它在JVM（HotSpot）中的具体实现。</p>
<h2 id="ObjectMonitor"><a href="#ObjectMonitor" class="headerlink" title="ObjectMonitor"></a>ObjectMonitor</h2><h3 id="数据结构（定义）"><a href="#数据结构（定义）" class="headerlink" title="数据结构（定义）"></a>数据结构（定义）</h3><p>在HotSpot中，ObjectMonitor的主要数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       &#x3D; NULL;</span><br><span class="line">    _count        &#x3D; 0;      &#x2F;&#x2F; *记录owner线程获取锁的个数</span><br><span class="line">    _waiters      &#x3D; 0,</span><br><span class="line">    _recursions   &#x3D; 0;      &#x2F;&#x2F; *锁的重入次数</span><br><span class="line">    _object       &#x3D; NULL;</span><br><span class="line">    _owner        &#x3D; NULL;   &#x2F;&#x2F; *指向持有monitor对象的线程</span><br><span class="line">    _WaitSet      &#x3D; NULL;   &#x2F;&#x2F; *存放处于wait状态的线程队列</span><br><span class="line">    _WaitSetLock  &#x3D; 0 ;</span><br><span class="line">    _Responsible  &#x3D; NULL ;</span><br><span class="line">    _succ         &#x3D; NULL ;</span><br><span class="line">    _cxq          &#x3D; NULL ;</span><br><span class="line">    FreeNext      &#x3D; NULL ;</span><br><span class="line">    _EntryList    &#x3D; NULL ;  &#x2F;&#x2F; *存放处于等待锁block状态的线程队列</span><br><span class="line">    _SpinFreq     &#x3D; 0 ;</span><br><span class="line">    _SpinClock    &#x3D; 0 ;</span><br><span class="line">    OwnerIsThread &#x3D; 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点字段已经使用“*”标记出来了。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="/images/monitor.png" alt="monitor"></p>
<ul>
<li>想要获取monitor的线程，首先会进入_EntryList队列；</li>
<li>当某个线程获取到对象的monitor后，进入_Owner区域，设置为当前线程，同时计数器_count加1；</li>
<li>如果线程调用了wait()方法，则会进入_WaitSet队列。它会释放monitor锁，即将_owner赋值为null，_count自减1，进入_WaitSet队列阻塞等待；</li>
<li>如果其他线程调用 notify() / notifyAll()，会唤醒_WaitSet中的某个线程，该线程再次尝试获取monitor锁，成功即进入_Owner区域；</li>
<li>同步方法执行完毕了，线程退出临界区，会将monitor的owner设为null，并释放监视锁。</li>
</ul>
<p>以代码为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;  <span class="comment">//进入_EntryList队列</span></span><br><span class="line">    doSth();</span><br><span class="line">    wait();           <span class="comment">//进入_WaitSet队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对象如何与monitor关联"><a href="#对象如何与monitor关联" class="headerlink" title="对象如何与monitor关联"></a>对象如何与monitor关联</h1><p>对象是如何与monitor关联起来的呢？</p>
<p><img src="/images/objectMonitor.png" alt="objectMonitor"></p>
<p>由此可见，实例对象中有一个对象头，在对象头的Mark word中，如果这个对象被上了重量级锁，Mark word中会有一个指向互斥量（重量级锁）的指针，指向ObjectMonitor对象，从而实现了对象与monitor的关联。</p>
<p>接下来我们就一层一层的看下去，这中间令人一头雾水的各个名词都是什么意思？以及什么原理？</p>
<h2 id="Java对象内存布局"><a href="#Java对象内存布局" class="headerlink" title="Java对象内存布局"></a>Java对象内存布局</h2><p>由上图可见，在JVM中，对象在堆中的布局可以分为三块：对象头、实例数据和对齐填充。</p>
<p>那么我们如何证明这一点呢？口说无凭啊。我们可以通过一个依赖包来打印对象的内存布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>然后简单创建个对象就可以打印出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">L</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">L l = <span class="keyword">new</span> L();</span><br><span class="line">System.out.println(ClassLayout.parseInstance(l).toPrintable());</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">com.leetcode.L object internals:</span><br><span class="line"> OFFSET  SIZE  TYPE DESCRIPTION    VALUE</span><br><span class="line">  0     4       (object header)    01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">  4     4       (object header)    00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">  8     4       (object header)    43 c1 00 f8 (01000011 11000001 00000000 11111000) (-134168253)</span><br><span class="line"> 12     1   boolean L.flag         false</span><br><span class="line"> 13     3       (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 3 bytes external &#x3D; 3 bytes total</span><br></pre></td></tr></table></figure>

<p>其中的object header就是我们说的“<strong>对象头</strong>”，中间的L.flag实际上就是我们上面定义的L类实例的对象l的“<strong>实例数据</strong>”，自此总共有13 bytes。</p>
<p>但64位的JVM要求对象大小必须是8个bytes的倍数，也就是即使只有一个boolean是1 byte，也要加上7 bytes的字节填充。上面的输出中“loss due to the next object alignment”我们可以看到在基于原来的13 bytes基础上，又加上了3 bytes的“<strong>字节填充</strong>”，刚好可以解释我们上面画的图是正确的。</p>
<h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>这里我们只看上面对象头部分的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OFFSET  SIZE  TYPE DESCRIPTION    VALUE</span><br><span class="line"> 0     4       (object header)    01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line"> 4     4       (object header)    00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line"> 8     4       (object header)    43 c1 00 f8 (01000011 11000001 00000000 11111000) (-134168253)</span><br></pre></td></tr></table></figure>

<p>在我的64位机器上拿到的对象头是12 bytes，也就是96 bits（有些同学会测出来128 bits，这是因为有些机器开启了指针压缩造成的，这里不做详述）。</p>
<p>JVM规范：对象头是每个gc管理的堆对象的公共结构，包括堆对象的：</p>
<ul>
<li>布局；</li>
<li>类型（存放指向元空间类模板的指针）；</li>
<li>gc状态（4位bit）；</li>
<li>同步状态（后面会说）；</li>
<li>哈希码（此处注意，hashcode并不存在*）；</li>
</ul>
<p>的基本信息。所有的java对象和jvm内部对象都有一个通用的对象头格式。</p>
<p>根据JVM规范，对象头 = mark word（8byte） + klass pointer（4byte） = 12 bytes。其中klass pointer就是元空间内类的模板信息（指针）。如果是数组，还有4个byte记录长度 + 长度的动态byte数。</p>
<p>那么我们现在知道了，后面的4个bytes是类模板的指针，那前8个bytes的Mark word又是什么？每一位都表示什么呢？</p>
<h2 id="Mark-word"><a href="#Mark-word" class="headerlink" title="Mark word"></a>Mark word</h2><p>Mark word中存放了堆对象的gc状态、同步状态、哈希码等信息，但其实这里面也有坑（hash码真的存了吗）。</p>
<p>我们先来看一下不同状态锁的时候，Mark word的表现：</p>
<table>
<thead>
<tr>
<th>Object Header（96 bits）</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Mark word（64 bits）</td>
<td>Klass word（32 bits）</td>
<td></td>
</tr>
<tr>
<td>unused: 25 | hashcode: 31 |unused: 1 | age: 4| blased_lock: 1| lock: 2</td>
<td>pointer to metadata object</td>
<td>无锁</td>
</tr>
<tr>
<td>thread: 54 | epoch: 2| unused: 1| age: 4|blased_lock: 1| lock: 2</td>
<td>pointer to metadata object</td>
<td>偏向锁</td>
</tr>
<tr>
<td>—————– ptr_to_lock_record: 62 —————–| lock: 2</td>
<td>pointer to metadata object</td>
<td>轻量锁</td>
</tr>
<tr>
<td>—————– ptr_to_heavyweight_monitor: 62 —————–| lock: 2</td>
<td>pointer to metadata object</td>
<td>重量锁</td>
</tr>
<tr>
<td>—————————————————————————————————————————- | lock: 2</td>
<td>pointer to metadata object</td>
<td>gc</td>
</tr>
</tbody></table>
<p>注意这里的<code>ptr_to_heavyweight_monitor</code>，后面我们会对它进行分析。</p>
<p>1、同步状态：</p>
<p>需要blased_lock（偏向锁标识）和lock（锁状态标识）共同表示前两种状态：</p>
<ul>
<li>blased_lock：0，lock：01：表示无锁；</li>
<li>blased_lock：1，lock：01：表示偏向锁；</li>
<li>lock：00：表示轻量锁；</li>
<li>lock：10：表示重量锁；</li>
<li>lock：11：表示gc标志。</li>
</ul>
<p>这是因为lock的2个bits只能表示4种状态，故而引入了1个bit标识偏向锁，而后的三种状态都没有blased_lock啥事儿了，用lock就够了。</p>
<p>2、gc状态：age字段表示gc状态，age只有4个bits，能表示的最大数字是15，这也就解释了为什么对象在young区的from和to交换15次就放到old区。</p>
<p>3、哈希码</p>
<p>这里大家可能跟我有一样的困惑，前8个bytes都是0，只有一个bit是1，哪里存的hash码？如此说来，那hash码真的存在于对象头吗？</p>
<p>我们在上面分析对象头时，用*标记了说明hash码其实是并不存在的，hashcode存的是地址，这个地址是需要计算出来的并不是绝对的内存地址。事实上object.hashcode()方法也是native方法，需要有计算过程，地址这个东西毕竟只有cpp才能知道。</p>
<p>那我怎么在对象头中显示hash码呢？很简单，上面手动调用hashcode()方法，hash码就会被存到对象头里面了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(l.hashCode());</span><br><span class="line">System.out.println(ClassLayout.parseInstance(l).toPrintable());</span><br></pre></td></tr></table></figure>

<p>输出为（对象头只贴value部分）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1625635731    &#x2F;&#x2F; hashcode</span><br><span class="line">VALUE</span><br><span class="line">01 93 3b e5 (00000001 10010011 00111011 11100101) (-449080575)</span><br><span class="line">60 00 00 00 (01100000 00000000 00000000 00000000) (96)</span><br><span class="line">43 c1 00 f8 (01000011 11000001 00000000 11111000) (-134168253)</span><br></pre></td></tr></table></figure>

<p>这样，hash码就出来了，这里细心的同学可能又要问了，那我算出来的<code>01 93 3b e5 60</code>得到的和调用hashcode()方法不一样啊，是不是搞错了？</p>
<p>这里还涉及到一个小知识点，就是计算机bit的大小端存储问题，至少在我的机器上是采用<strong>大端存储</strong>的，还记得刚刚无锁时对象头的bit分布吗？<code>unused: 1|age: 4|blased_lock: 1|lock: 2</code>这里一共8个bit，刚好是前面第一个0x01（最后一001表示无锁状态）。接下来按照倒序来讲就应该是hashcode了，并且这几个16进制数内部也是倒序的，所以应该是<code>60 e5 3b 93</code>的10进制刚好是1625635731，这和上面手动调用hashcode()方法得到的结果是一致的。</p>
<p>再强调一遍，正常来讲对象头预留了hashcode位，但初始是不存储的，需要计算。</p>
<h2 id="Mark-word中的重量锁"><a href="#Mark-word中的重量锁" class="headerlink" title="Mark word中的重量锁"></a>Mark word中的重量锁</h2><p>还记得上面我们留的坑吗？<code>ptr_to_heavyweight_monitor</code>在重量锁的情形下，Mark word中的后62个bits（大端存储机器）指向的就是堆中ObjectMonitor对象，仅此一句话而已。</p>
<p>其实到这里，synchronized原理我们已经剖析完了。难吗？不了解对象的内存布局可能一辈子都不知道咋实现的，因为也没有源码。但是简单吗？清晰地分析下来发现，<strong>synchronized就是通过两个指令和一个flag来操控ObjectMonitor对象，而这个monitor对象通过对象头中存储的地址来访问。</strong></p>
<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><p>后面的jdk版本中（jdk 1.6之后），使用synchronized不会直接调用monitor的enter()和exit()方法了，直接调用被称作<strong>重量级锁</strong>，所以进行了一些锁优化，包括适应性自旋、锁消除、锁粗化、锁膨胀等一系列优化策略。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>当临界区很小的情况下，锁占用的时间很短，那么频繁的阻塞和唤醒对于CPU来说开销太大了，所以采用自旋的方式减少CPU从用户态转为核心态切换的时间。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>有些程序员写代码时，上来就对一个实例进行sync，也不管究竟有没有竞争。JVM会在运行时检测，对于不存在共享数据竞争的锁进行消除。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>锁粗化是指对于一系列要加锁的操作，JVM会将它们连在一起，扩展成一个范围更大的锁，举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> L l = <span class="keyword">new</span> L();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (l) &#123;</span><br><span class="line">            System.out.println(<span class="string">"锁粗化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果每次循环进去都加锁解锁简直是灾难，JVM会优化成下面这个样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> L l = <span class="keyword">new</span> L();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (l) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"锁粗化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><p>锁膨胀指的是jdk 1.6之后针对于synchronized关键字做的优化，根据被锁资源的竞争程度，进行无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁的升级过程，而不是上来就上个重量级锁。</p>
<ol>
<li>偏向锁：只有一个线程进入临界区；</li>
<li>轻量级锁：多个线程未竞争或者竞争不激烈，同步块执行速度非常快；</li>
<li>重量级锁：多线程竞争，高吞吐量，同步块执行时间较长。</li>
</ol>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">文章</a></li>
         
          <li><a href="/categories/">目录</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized用法"><span class="toc-number">1.</span> <span class="toc-text">synchronized用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized作用于代码块"><span class="toc-number">1.1.</span> <span class="toc-text">synchronized作用于代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized作用于方法"><span class="toc-number">1.2.</span> <span class="toc-text">synchronized作用于方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#monitorenter、monitorexit和ACC-SYNCHRONIZED"><span class="toc-number">2.</span> <span class="toc-text">monitorenter、monitorexit和ACC_SYNCHRONIZED</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#monitorenter"><span class="toc-number">2.1.</span> <span class="toc-text">monitorenter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#monitorexit"><span class="toc-number">2.2.</span> <span class="toc-text">monitorexit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACC-SYNCHRONIZED"><span class="toc-number">2.3.</span> <span class="toc-text">ACC_SYNCHRONIZED</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#monitor监视器"><span class="toc-number">3.</span> <span class="toc-text">monitor监视器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统中的管程"><span class="toc-number">3.1.</span> <span class="toc-text">操作系统中的管程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ObjectMonitor"><span class="toc-number">3.2.</span> <span class="toc-text">ObjectMonitor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构（定义）"><span class="toc-number">3.2.1.</span> <span class="toc-text">数据结构（定义）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作原理"><span class="toc-number">3.2.2.</span> <span class="toc-text">工作原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象如何与monitor关联"><span class="toc-number">4.</span> <span class="toc-text">对象如何与monitor关联</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java对象内存布局"><span class="toc-number">4.1.</span> <span class="toc-text">Java对象内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象头"><span class="toc-number">4.2.</span> <span class="toc-text">对象头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mark-word"><span class="toc-number">4.3.</span> <span class="toc-text">Mark word</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mark-word中的重量锁"><span class="toc-number">4.4.</span> <span class="toc-text">Mark word中的重量锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#锁优化"><span class="toc-number">5.</span> <span class="toc-text">锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#自旋锁"><span class="toc-number">5.1.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁消除"><span class="toc-number">5.2.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁粗化"><span class="toc-number">5.3.</span> <span class="toc-text">锁粗化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁膨胀"><span class="toc-number">5.4.</span> <span class="toc-text">锁膨胀</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://blog.yangx.site/2019/11/16/java-synchronized/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://blog.yangx.site/2019/11/16/java-synchronized/&text=Synchronized原理剖析" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://blog.yangx.site/2019/11/16/java-synchronized/&title=Synchronized原理剖析" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Synchronized原理剖析&body=Check out this article: https://blog.yangx.site/2019/11/16/java-synchronized/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 yxiao
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">文章</a></li>
         
          <li><a href="/categories/">目录</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-159372775-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
