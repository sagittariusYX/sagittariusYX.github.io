<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ReentrantLock及AQS源码分析</title>
      <link href="/2020/03/03/java-multi-thread-aqs/"/>
      <url>/2020/03/03/java-multi-thread-aqs/</url>
      
        <content type="html"><![CDATA[<h1 id="自己实现一个自旋锁"><a href="#自己实现一个自旋锁" class="headerlink" title="自己实现一个自旋锁"></a>自己实现一个自旋锁</h1><p>我们来写一个普通的自旋锁，然后再慢慢去改进它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标识是否有线程加锁</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//lock</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    status = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> except, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cas操作,修改status成功则返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：这样的自旋浪费CPU资源，没有拿到锁的线程会一直自旋。如果拿到锁的线程执行10s，那么其他线程白白浪费了10s的CPU资源。</p><p>解决思路：让得不到锁的线程让出CPU。</p><h2 id="yield-自旋"><a href="#yield-自旋" class="headerlink" title="yield() + 自旋"></a>yield() + 自旋</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//lock</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    status = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：yield()方法能够让出CPU资源，但是只有两个线程竞争时，yield是有效的。只是当前线程让出CPU，有可能下次操作系统还是选择运行该线程。如果有10000个线程，会出问题。</p><h2 id="sleep-自旋"><a href="#sleep-自旋" class="headerlink" title="sleep() + 自旋"></a>sleep() + 自旋</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//lock</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    status = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：sleep()的缺点就更明显了，你咋知道要睡10秒？</p><h2 id="park-自旋"><a href="#park-自旋" class="headerlink" title="park() + 自旋"></a>park() + 自旋</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标识是否有线程加锁</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 等待队列、链表</span></span><br><span class="line">Queue parkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 拿锁失败，park</span></span><br><span class="line">        <span class="comment">// 可以用LockSupport.park()，是native方法</span></span><br><span class="line">        park();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lockNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前线程加入等待队列</span></span><br><span class="line">    parkQueue.add(currentThread);</span><br><span class="line">    <span class="comment">// 释放CPU，阻塞</span></span><br><span class="line">    releaseCPU();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockNotify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿到队列头部的线程唤醒</span></span><br><span class="line">    Thread t = parkQueue.header();</span><br><span class="line">    <span class="comment">// 唤醒t</span></span><br><span class="line">    unpark(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就比较完美了，这是伪代码，其实ReentrantLock用的就是类似这样的机制。</p><h1 id="ReentrantLock源码分析"><a href="#ReentrantLock源码分析" class="headerlink" title="ReentrantLock源码分析"></a>ReentrantLock源码分析</h1><p>ReentrantLock基于AbstractQueuedSynchronizer这个抽象类来实现可重入的锁，ReentrantLock在构造方法时可以传入fair参数来决定是否是公平的锁，并且内部定义了2个数据结构（FairSync和NonfairSync）分别来实现公平非公平锁。</p><p>AQS本身除了一些状态以外，核心是一个FIFO的队列，或者说自己维护的双向链表。</p><p>ReentrantLock是jdk 1.5出来的，据传是Doug Lea大神不满意当时synchronized关键字的效率（1.6后synchronized有了锁优化），自行实现了一个高效的锁AQS。后来sun公司直接将其收进了juc包中，并且在以后的版本对synchronized进行了优化。原来我们总喜欢比较两个方式性能的优劣，但实际在今天，已没有多大的区别了。</p><p>至于面试常问的synchronized和锁的区别，我的理解主要目的还是考察是否对它们使用过、实现原理以及存在层面上的比较。现在你单纯问宝马好还是奔驰好，无从谈起。</p><p>ReentrantLock使用方法也很简单，先创建锁，在业务逻辑前调用lock()实例方法上锁，在finally块中解锁即可。</p><h2 id="AQS中的Node内部类"><a href="#AQS中的Node内部类" class="headerlink" title="AQS中的Node内部类"></a>AQS中的Node内部类</h2><p>这个Node使我们理解AQS以及ReentrantLock的基础数据结构，它是在AQS中定义的，主要作为排队线程中的基本单位（节点），它本质上就是封装了Thread，并且提供了向前向后的指针来维护排队队列，你把它理解成双端链表也可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的属性就这仨。</p><h2 id="lock-上锁过程"><a href="#lock-上锁过程" class="headerlink" title="lock()上锁过程"></a>lock()上锁过程</h2><p>lock()上锁过程对于公平锁和非公平锁只有一点差别，我们先贴一下源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FairSync</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接去acquire一个锁，对应底层就是state+1</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; NonfairSync</span><br><span class="line">final void lock() &#123;</span><br><span class="line">    &#x2F;&#x2F; 非公平锁上来先cas一下能不能拿到锁</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        &#x2F;&#x2F; 如果拿到了，设置当前线程为owner</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        &#x2F;&#x2F; 如果没拿到，再去acquire</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为啥说非公平？因为它上来就想插队。</p><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h3><p>acquire()方法对于是否公平是一样的，是父类AQS中的默认方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试拿锁，后面详细分析这个tryAcquire</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">// 加入到AQS队列后立马park()</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// interrupt当前线程</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire()"></a>tryAcquire()</h3><p>这里贴的是FairSync的tryAcquire()，NonfairSync的实现只是少了!hasQueuedPredecessors()需要排队的判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取上锁状态，自由状态为0，被上锁为1，大于1表示重入</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  <span class="comment">// 自由状态，当前线程去上锁</span></span><br><span class="line">        <span class="comment">// hasQueuedPredecessors判断是否需要排队，比较复杂，后面介绍</span></span><br><span class="line">        <span class="comment">// 如果不需要排队就cas加锁</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 加锁成功，把当前线程设为owner，返回true</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果state不为0，判断是不是重入，也就是判断是不是owner自己要上锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 如果是重入，状态+1表示重入次数</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// state溢出，重入最多是Integer.MAX_VALUE</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 设置新的state并上锁成功</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果state不为0，还不是owner要上锁，说明有人在拿着锁，上锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors()"></a>hasQueuedPredecessors()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS队列在初始化时会虚拟一个thread为null的Node，因为队列当中的head永远是持有锁的那个node。自此之后，除了第一次会虚拟一个，其他时候都是持有锁的那个线程封装的Node。这个理念在AQS中我们一定要理解。</p><p>我觉得这个方法是整个AQS中最难的部分没有之一，所以这里不用注释的形式了，在下面对于各种情况详细分析一下：</p><ul><li>队列中没有Node，那么head和tail都为null，这个时候队列没有被初始化，那么不需要排队，直接去上锁；但也有特殊情况，如果2个线程同时来lock()，看到队列没有初始化，就都用CAS去修改计数器，那么必然有一个会失败，那么失败的这个线程就去初始化队列，并且乖乖排队；</li><li>（难点）队列中只有1个Node，也就是head == tail，但是我们上面说了，初始化完成后，head是thread为null的虚拟节点，如果只有一个数据，那队列长度应该是2啊？其实这里是一个中间状态，即持有锁的线程刚好释放锁，而<strong>自己又是队列中唯一一个节点</strong>，这时候不去等待unpark()通知，主动去尝试CAS拿锁，此时h == t，要看下一个判断：h.next != null（因为是当前要加锁的线程），并且后面s.thread != Thread.currentThread()也成立，整个return为false，就表示不用排队，直接去拿锁（日了狗了这一行代码）；</li><li>队列中有若干Node（大于1个），那么h != t肯定成立，需要看后面那段表达式，大于1个的时候h.next肯定不为空，那么就看拿锁线程是不是排队的第一个线程：<ul><li>如果当前线程不是第一个排队线程，后半段为true前半段也是true，整个函数返回true，那没啥废话，乖乖去排队；</li><li>如果当前线程是第一个排队线程（当做现在第一个排队的人是你媳妇），那么这里整个函数返回false，不需要排队，直接外层去CAS拿锁，这里又分2种情况：<ul><li>加锁成功：持有锁的线程刚好执行完了，释放掉锁，那么当然就是当前线程拿到锁；</li><li>加锁失败：持有锁的线程还没执行完，也不会进tryAcquire(1)的else分支，那么本次拿锁失败，在acquire(1)中会addWaiter()正常排队。</li></ul></li></ul></li></ul><h3 id="acquireQueued-addWaiter-Node-EXCLUSIVE-arg"><a href="#acquireQueued-addWaiter-Node-EXCLUSIVE-arg" class="headerlink" title="acquireQueued(addWaiter(Node.EXCLUSIVE), arg)"></a>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</h3><p>上面说如果加锁失败，就把它加到AQS队列中，我再贴一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">// tryAcquire取反，加锁失败</span></span><br><span class="line">        <span class="comment">// 加入到AQS队列后立马park()</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// interrupt当前线程</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能跑到acquireQueued(addWaiter(Node.EXCLUSIVE), arg)这里说明当前线程要排队了。这里分为2种情况：</p><ol><li>其他线程持有锁，那么当前线程需要排队，但此时队列还没有被初始化；</li><li>其他线程持有锁，队列已经被初始化，所以当前线程需要去排队。</li></ol><h3 id="addWaiter-Node-EXCLUSIVE"><a href="#addWaiter-Node-EXCLUSIVE" class="headerlink" title="addWaiter(Node.EXCLUSIVE)"></a>addWaiter(Node.EXCLUSIVE)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把当前线程封装为Node对象，mode为排它（读写锁中的读锁才是共享mode）</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 判断队尾是否为null，其实只要队列被初始化了，队尾一定不为null</span></span><br><span class="line">    <span class="comment">// 换而言之这里判断的就是队列有没有被初始化，也就是上面我们说的那2种情况</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 队尾不为空，队列已经初始化了</span></span><br><span class="line">        <span class="comment">// 这种情况比较简单，把当前Node设置为队尾，维护链表关系即可</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列没有被初始化，下面来分析这个enq</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="comment">// 返回当前node</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enq每次执行的情况都不同，这里分次来分析</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入，t为null，队列没有被初始化</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// 调用无参的Node构造方法，也就是加了一个thread为null的虚拟Node</span></span><br><span class="line">            <span class="comment">// 并把这个虚拟Node设为头部</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                <span class="comment">// 此时AQS中只有一个元素，就是这个虚拟Node</span></span><br><span class="line">                <span class="comment">// 然后将尾部指向它，第一次循环结束</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面我们来看第二次循环</span></span><br><span class="line"><span class="comment">// 这个代码写的比较高效，处理了不同的情况</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 这个时候t指向的是那个虚拟Node了，不为null</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前Node入队，前驱为虚拟Node</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// cas设置尾部</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                <span class="comment">// 维护链表关系</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="comment">// 返回虚拟节点？这个返回其实就是终止死循环</span></span><br><span class="line">                <span class="comment">// 返回出去的t没啥意义，外面的addWaiter没有接收enq的返回</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们看下来，这个addWaiter()方法就是拿锁失败时，让当前线程入队，并且维护队列的链表关系。</p><p>接下来看acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，经过上面的一系列操作后，变成了acquireQueued(node, arg)。</p><h3 id="acquireQueued-node-arg"><a href="#acquireQueued-node-arg" class="headerlink" title="acquireQueued(node, arg)"></a>acquireQueued(node, arg)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 拿到当前Node的前驱p</span></span><br><span class="line">            <span class="comment">// 这里分为2种情况：1. 上一个节点是head；2. 上一个节点不是head</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 1. 如果上一个节点是head，则表示当前节点为队列中的第二个元素，“排队”的第一个元素</span></span><br><span class="line">            <span class="comment">// 第一个排队的先去尝试拿锁，这里为啥要尝试拿锁呢？</span></span><br><span class="line">            <span class="comment">// 这相当于你买票，你前面那人正在窗口，你是排队的第一个</span></span><br><span class="line">            <span class="comment">// 那此时你肯定不死心，要问问你前面那人买完了没？</span></span><br><span class="line">            <span class="comment">// 1.1 买完了的话，去旁边收拾你的身份证，我可以开始买了（可以拿锁了）</span></span><br><span class="line">            <span class="comment">// 1.2 前面那人要是还没处理完（还持有锁），那我再睡一会儿（park）</span></span><br><span class="line">            <span class="comment">// 所以这里拿锁就是看一下是不是之前的线程刚好释放锁，主动碰碰运气</span></span><br><span class="line">            <span class="comment">// 这也是提高效率，如果运气好，就不需要调一次unpark了，直接拿锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 如果运气好cas到了锁，那么前面的Node出队列，当前Node设为队首</span></span><br><span class="line">                <span class="comment">// 这步操作是去除前面Node的占位</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 前面Node出队，断链</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 返回false，不需要interrupt，当前线程拿锁执行</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 上一个节点不是head + 第一个排队的拿锁失败（其他线程没释放锁）</span></span><br><span class="line">            <span class="comment">// 这种情况下要park了</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// 调用LockSupport.park(this);</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 进入下次循环，再尝试cas拿锁，还拿不到安心排队</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unlock-解锁过程"><a href="#unlock-解锁过程" class="headerlink" title="unlock()解锁过程"></a>unlock()解锁过程</h2><p>相比之下，unlock的过程就好理解一些了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     sync.release(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="sync-release-1"><a href="#sync-release-1" class="headerlink" title="sync.release(1)"></a>sync.release(1)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试解锁，下面会分析</span></span><br><span class="line">     <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">         Node h = head;</span><br><span class="line">         <span class="comment">// 当前lock被解锁，那么看AQS中的head，即下一个排队的Thread</span></span><br><span class="line">         <span class="comment">// 当h不是无锁状态下，进行unpark()操作</span></span><br><span class="line">         <span class="comment">// 前面这个不为null判断是避免NPE，别想多</span></span><br><span class="line">         <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">             <span class="comment">// 这里面调LockSupport.unpark(h.next.thread)</span></span><br><span class="line">             <span class="comment">// 对下一个Node unpark</span></span><br><span class="line">             <span class="comment">// 为啥不是unpark自己？这里有2点原因：</span></span><br><span class="line">             <span class="comment">// 1. 自己在执行啊，调用unlock的时候已经获得锁在执行了</span></span><br><span class="line">             <span class="comment">// 2. 下一个Node对应的线程已经在park了，没有cpu资源</span></span><br><span class="line">             <span class="comment">//    所以没办法执行任何代码了，只能别人来改</span></span><br><span class="line">             unparkSuccessor(h);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="tryRelease-arg"><a href="#tryRelease-arg" class="headerlink" title="tryRelease(arg)"></a>tryRelease(arg)</h3><p>这个比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 减少state</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 如果当前要解锁的线程不是lock的owner，会异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 标记锁状态</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有重入了，state对应的值为0，这个lock就完全free了</span></span><br><span class="line">        <span class="comment">// 其他线程可以过来拿锁了</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 把owner设为null，无主状态</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="comment">// 返回free</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们可以说Java现代化的同步中的synchronized关键字是基于管程monitor的，Lock是基于AQS的。</p><p>AQS还有其他的应用，比如CountDownLatch、Semaphore，以及线程池中创建新线程封装的Worker也是AQS的子类（addWorker()方法还记得吗？）。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Concurrency </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程 —— 线程池原理及源码分析</title>
      <link href="/2020/02/23/java-multi-thread-threadPool/"/>
      <url>/2020/02/23/java-multi-thread-threadPool/</url>
      
        <content type="html"><![CDATA[<h1 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h1><p>线程池也是池化技术的一个具体实现，这样说来，合理利用包括线程池等池化技术（如连接池等）能够带来三个好处：</p><ol><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><h1 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h1><p>在了解原理之前，先了解一下如何使用它，玩熟了再往深处挖。</p><h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><p>我们首先来看一下线程池的默认构造函数，以及可传入的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><ul><li>corePoolSize：线程池中常驻核心线程数；</li><li>maximumPoolSize：能够容纳同时执行的最大线程数，必须大于等于1；</li><li>keepAliveTime：多余的空闲线程存活时间（当前线程数超过corePoolSize时，空闲时间超过keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止）；</li><li>unit：keepAliveTime的单位；</li><li>workQueue：任务队列，被提交但尚未被执行的任务；</li><li>threadFactory：生成线程池中工作线程的线程工厂，用于创建线程，一般用默认的即可；</li><li>handler：拒绝策略，当队列满了，并且工作线程大于等于最大线程数，执行拒绝策略。</li></ul><p>这里要对两个重点概念进行说明：</p><h3 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h3><p>workQueue是用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列：</p><table><thead><tr><th>队列</th><th>说明</th></tr></thead><tbody><tr><td>☆ArrayBlockingQueue</td><td>数组结构组成的<strong>有界</strong>阻塞队列</td></tr><tr><td>☆LinkedBlockingQueue</td><td>链表结构组成的有界（大小<strong>默认值为Integer.MAX_VALUE</strong>）阻塞队列（相当于无界）</td></tr><tr><td>PriorityBlockingQueue</td><td>支持<strong>优先级排序</strong>的<strong>无界</strong>阻塞队列</td></tr><tr><td>DelayQueue</td><td>使用<strong>优先级队列</strong>实现的<strong>延迟无界</strong>阻塞队列</td></tr><tr><td>☆SynchronousQueue</td><td>不存储元素的阻塞队列，也即<strong>单个元素</strong>的队列</td></tr><tr><td>LinkedTransferQueue</td><td>链表结构组成的<strong>无界</strong>阻塞队列</td></tr><tr><td>LinkedBlocking<strong>De</strong>que</td><td>链表结构组成的<strong>双向</strong>阻塞队列</td></tr></tbody></table><h3 id="handler（RejectHandler）"><a href="#handler（RejectHandler）" class="headerlink" title="handler（RejectHandler）"></a>handler（RejectHandler）</h3><p>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略<strong>默认情况下是AbortPolicy</strong>，表示无法处理新任务时抛出异常。</p><p>以下是JDK1.8提供的四种策略：</p><table><thead><tr><th>策略</th><th>说明</th></tr></thead><tbody><tr><td>AbortPolicy</td><td>（默认实现，不敢用，动不动就崩）直接抛出异常。</td></tr><tr><td>CallerRunsPolicy</td><td>即不会抛弃任务，又不会抛出异常，而是将任务回退到调用者（比如退给main线程执行），从而降低新任务的流量。</td></tr><tr><td>DiscardOldestPolicy</td><td>丢弃队列里呆的最久的一个任务，然后把当前任务加入到队列中尝试再次提交。</td></tr><tr><td>DiscardPolicy</td><td>不处理，丢弃掉，也不抛出异常。如果允许任务丢失，这是最好的一种方案。</td></tr><tr><td>实现RejectedExecutionHandler接口</td><td>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</td></tr></tbody></table><h2 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h2><p>线程池允许我们使用execute()和submit()两种方法提交任务：</p><ul><li>execute提交任务，但是execute方法没有返回值，所以无法判断提交的任务是否被线程池执行成功；</li><li>submit方法来提交任务，它会将task<strong>封装为一个futureTask</strong>（后面我们还会提到），并返回一个future，那么我们可以通过这个future来判断任务是否执行成功，通过future的get方法来获取返回值。<ul><li>get()方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</li></ul></li></ul><h2 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h2><p>我们可以通过调用线程池的shutdown()或shutdownNow()方法来关闭线程池，但是它们的实现原理不同：</p><ul><li>shutdown()的原理是只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程；</li><li>shutdownNow()的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</li></ul><p>只要调用了这两个关闭方法的其中一个，isShutdown()方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminated()方法会返回true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，<strong>通常调用shutdown()来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow()</strong>。</p><h1 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h1><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>线程池的主要工作流程如下图：</p><p><img src="/images/ThreadPool.png" alt="ThreadPool"></p><p>我们可以看出，当提交一个新任务到线程池时，线程池的处理流程如下：</p><ol><li>首先线程池判断核心线程池是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程。</li><li>其次线程池判断工作队列是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。</li><li>最后线程池判断整个线程池是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。</li></ol><h2 id="线程池提交任务源码分析"><a href="#线程池提交任务源码分析" class="headerlink" title="线程池提交任务源码分析"></a>线程池提交任务源码分析</h2><p>这里我们还是分为submit和execute两种方式来分析。</p><p>当线程池调用submit()方法提交任务时，线程池会首先将这个Runnable的task封装为一个futureTask，然后跟execute的方式一样直接调用execute()方法来执行，此后将这个futureTask返回，便于以后get()来获取运行结果或拿到异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其后，这两种提交方式走的是同样的代码路径了。线程池调用executor()执行任务的方法如下（execute方式入口）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// clt记录着runState和workerCount</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// workerCountOf方法取出低29位的值，表示当前活动的线程数</span></span><br><span class="line">    <span class="comment">// 然后拿线程数和核心线程数做比较</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 1. 判断核心线程池是否已满</span></span><br><span class="line">        <span class="comment">// 如果活动线程数 &lt; 核心线程数，添加到workers中</span></span><br><span class="line">        <span class="comment">// addWorker中的第二个参数表示限制添加线程的数量</span></span><br><span class="line">        <span class="comment">// 是根据corePoolSize来判断还是maximumPoolSize来判断</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 如果当前线程池是运行状态并且任务添加到队列成功</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 正在执行</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 第一个参数为null，表示在线程池中创建一个线程，但不去启动</span></span><br><span class="line">            <span class="comment">// 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">// 3. 执行饱和策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看一下execute()中多次调用的addWorker()方法，它的主要工作是在线程池中创建一个新的线程并执行：</p><p>参数：</p><ul><li>firstTask：指定新创建的线程执行的第一个任务，为null则不执行任务；</li><li>core：如果是true则使用corePoolSize来绑定，否则使用maximumPoolSize绑定。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="comment">// 获取运行状态</span></span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="comment">// 如果状态值 &gt;= SHUTDOWN (不接新任务，且不处理队列任务)</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="comment">// 如果wc大于容量，或者core如果为true表示根据corePoolSize来比较,否则为maximumPoolSize</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 原子增加workerCount</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="comment">// 如果当前的运行状态不等于rs，说明状态已被改变，返回重新执行</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据firstTask来创建Worker对象</span></span><br><span class="line">            <span class="comment">// 注意！！！</span></span><br><span class="line">            <span class="comment">// 此处如果是execute方法调用，firstTask是一个Runnable</span></span><br><span class="line">            <span class="comment">// 而如果是submit方法调用，firstTask是一个FutureTask</span></span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="comment">// 根据worker创建一个线程</span></span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// firstTask == null表明只新建线程而不执行任务</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 如果t活着就抛异常</span></span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        <span class="comment">// 否则加入worker(HashSet)</span></span><br><span class="line">                        <span class="comment">// workers包含池中的所有工作线程。仅在持有mainLock时访问</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        <span class="comment">// worker的添加工作状态改为true</span></span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果worker的添加工作完成</span></span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    <span class="comment">// 启动线程</span></span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的异常处理"><a href="#线程池的异常处理" class="headerlink" title="线程池的异常处理"></a>线程池的异常处理</h2><p>关于线程池的异常处理，这其实源于一次踩坑，现象是我发现通过submit()方法提交task（除0异常）之后，异常不打印出来了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">    executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"test thread"</span>);</span><br><span class="line">            System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_181.jdk&#x2F;Contents&#x2F;Home&#x2F;bin&#x2F;java ...</span><br><span class="line">test thread</span><br><span class="line"></span><br><span class="line">Process finished with exit code 130 (interrupted by signal 2: SIGINT)</span><br></pre></td></tr></table></figure><p>而通过execute()方法直接执行task，会抛出对应的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">    executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"test thread"</span>);</span><br><span class="line">            System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test thread</span><br><span class="line">Exception in thread &quot;pool-1-thread-1&quot; java.lang.ArithmeticException: &#x2F; by zero</span><br><span class="line">    at com.leetcode.Result$1.run(Result.java:50)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><p>其实线程池对于异常的处理，跟提交线程的方式有关，分为submit的方式和execute的方式。</p><h3 id="submit获取异常"><a href="#submit获取异常" class="headerlink" title="submit获取异常"></a>submit获取异常</h3><p>上面我们分析过，submit()方法，是在AbstractExecutorService中实现的，它会将task封装成一个futureTask，然后execute()去执行。</p><p>接下来execute()方法是在ThreadPoolExecutor中实现的，整个execute()方法就是判断线程池状态，然后选择到底是new线程来执行还是加入等待队列，做事情的就是addWorker()，然后就会调用内部类Worker的run()方法。</p><p>在runWorker()中会调用futureTask的run()方法，如果出现了异常，会将这个Exception通过setException()的方式吞掉，它认为<strong>异常也是这个task执行的一部分</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    result = c.call();</span><br><span class="line">    ran = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    result = <span class="keyword">null</span>;</span><br><span class="line">    ran = <span class="keyword">false</span>;</span><br><span class="line">    setException(ex);    <span class="comment">// 重点！！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想拿到这个异常，需要调用futureTask的get()方法。</p><h3 id="execute直接抛出异常"><a href="#execute直接抛出异常" class="headerlink" title="execute直接抛出异常"></a>execute直接抛出异常</h3><p>如果是execute()方法的话，task.run()直接调的就是Callable或者Runnable的run()方法了，所有的异常就直接抛了，因为没有futureTask的那层封装。</p><p>这里走的是Thread的run()方法。</p><p>UncaughtExceptionHandler是JVM调用的处理线程异常的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dispatch an uncaught exception to the handler. This method is</span></span><br><span class="line"><span class="comment"> * intended to be called only by the JVM.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchUncaughtException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    getUncaughtExceptionHandler().uncaughtException(<span class="keyword">this</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Executors类提供的几种线程池"><a href="#Executors类提供的几种线程池" class="headerlink" title="Executors类提供的几种线程池"></a>Executors类提供的几种线程池</h1><p>理论聊了这么多，我们来看看juc中给我们提供了哪几种线程池的实现，以及它们各自都有什么特点。</p><p>线程池主要有5种（包含jdk 1.8）：</p><p>1，Executors.newScheduledThreadPool()：无限大小的线程池，每个线程存活时间是无限的，使用优先级队列实现的延迟无界阻塞队列，适用于周期性执行任务的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.NANOSECONDS,</span><br><span class="line">                                <span class="keyword">new</span> DelayedWorkQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2，Executors.newFixedThreadPool(int)：固定数量线程的池子，每个线程存活时间是无限的，使用无界阻塞队列，适用于执行长期的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3，Executors.newSingleThreadPool()：只有一个线程的池子，存活时间是无限的，使用无界阻塞队列，适用于一个任务一个任务执行的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4，Executors.newCachedThreadPool()：新任务到来就插入到同步队列中，并且同时寻找可用线程来执行，使用单个元素的队列，适用于短期异步的任务或者负载较轻的服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5，Java8新出Executors.newWorkStealingPool(int)：使用目前机器可用的处理器作为它的并行级别，采用ForkJoinPool来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">            (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h1><p>我们不禁眼花缭乱，juc给我们提供了如此多的的线程池的实现，那日常开发中如何选择哪种线程池来使用呢？</p><p>真相只有一个：哪个都不用！！！</p><blockquote><p>【强制】《阿里巴巴Java开发手册》规定线程池不允许使用Executors去创建，而是通过<code>new ThreadPoolExecutor</code>的方式。</p></blockquote><p>也就是通过ThreadPoolExecutor直接构造方法的方式。这主要是因为Executors返回线程池对象有其弊端：</p><ul><li>FixedThreadPool和SingleThreadPool：允许<strong>请求队列长度</strong>为Integer.MAX_VALUE，可能会堆积大量请求，导致OOM；</li><li>CachedThreadPool和ScheduledThreadPool：允许<strong>创建线程数量</strong>为Integer.MAX_VALUE，可能会创建大量线程，导致OOM。</li></ul><p>那么我们在手动创建线程池时，如何合理配置呢？</p><h2 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h2><p><strong>从线程数量上来看：</strong></p><p>以Runtime.getRuntime.availableProcessors()获得的CPU核数为基准：</p><ul><li>CPU密集型：配置Ncpu + 1个线程的线程池（线程数应当等于核心数，但是再怎么计算密集，总有一些IO吧，所以再加一个线程来把等待IO的CPU时间利用起来）；</li><li>IO密集型：线程并不是一直在执行任务，则配置尽可能多的线程，如2 * Ncpu；<ul><li>或者Ncpu / (1 - 阻塞系数)，阻塞系数在0.8 - 0.9之间，比如8核CPU, 8 / (1 - 0.9) = 80个线程；</li><li>看具体测出来的情况吧。</li></ul></li></ul><p><strong>从任务的执行时间来看：</strong></p><p>可以使用优先级队列，让执行时间短的任务先执行。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本来之前写过一篇关于线程池的文章的，但过于浅显。自近日以来觉得做技术不光要会使用、熟练使用，更要深入到源码层面理解其工作原理。Talk is cheap，show me the code！自认为本篇文章由表入里，已经将线程池的大部分内容分析透彻了。</p><p>如发现表述不当，或有明显错误，请在首页联系作者邮箱，感激不尽。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Concurrency </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码分析 —— bean依赖注入</title>
      <link href="/2020/02/02/spring-dependency-injection/"/>
      <url>/2020/02/02/spring-dependency-injection/</url>
      
        <content type="html"><![CDATA[<p>Spring bean的生命周期涉及的知识点太多而且比较复杂，很难在一篇文章中把Spring bean生命周期所有的方面都讲清楚。所以按照几条线来分别整理，最后再写一篇汇总的文章串联起来。</p><p>本文依然基于annotation注解配置的方式进行分析。</p><p>回顾一下我们说过Spring bean的生命周期主要大概有以下几个步骤：</p><ul><li>创建bean的实例</li><li>给实例化出来的bean填充属性</li><li>初始化bean</li><li>通过IOC容器使用bean</li><li>容器关闭时销毁bean</li></ul><p>本文就对第二阶段bean的依赖注入（Dependency Injection）分以下几个问题来整理：</p><ul><li>什么是Spring容器和依赖注入？</li><li>何时发生依赖注入？</li><li>Spring依赖注入的源码</li></ul><h1 id="什么是Spring容器和依赖注入？"><a href="#什么是Spring容器和依赖注入？" class="headerlink" title="什么是Spring容器和依赖注入？"></a>什么是Spring容器和依赖注入？</h1><p>上次我们说过，IOC是一种重要的设计理念，而Spring IOC又是基于这个理念在Spring framework实现的高级特性。Spring IOC具备以下两个特性：</p><ol><li><strong>准备Bean的整个生命周期需要的数据：</strong>在这一步中，Spring容器会定位配置文件，加载各种Class文件，并且将其解析成BeanDefinition（重要数据类型），这个BeanDefinition会贯穿Spring容器及Spring运行环境初始化的整个流程，是我们尤其要关注的数据基础；</li><li><strong>管理整个Bean的生命周期：</strong>完成bean实例化、完成各个bean之间依赖关系注入（本文所分析）、完成bean的初始化及销毁。</li></ol><h2 id="依赖注入和属性注入的区别"><a href="#依赖注入和属性注入的区别" class="headerlink" title="依赖注入和属性注入的区别"></a>依赖注入和属性注入的区别</h2><p>依赖注入其实是属性注入的一种特殊情形，特殊之处就在于它要注入的是bean，而不是String、List、Array这种。</p><p>我们通过@Autowire标签来完成依赖注入。</p><h1 id="何时发生依赖注入？"><a href="#何时发生依赖注入？" class="headerlink" title="何时发生依赖注入？"></a>何时发生依赖注入？</h1><p>回看之前我们分析的bean实例化源码，可以看到一丝线索。</p><p>在AnnotationConfigApplicationContext初始化时，调用关键方法refresh()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    register(componentClasses);</span><br><span class="line">    <span class="comment">// Spring容器初始化入口</span></span><br><span class="line">    refresh();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Spring初始化入口refresh（省略了部分代码，提升阅读体验）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">      <span class="comment">// 在这里初始化所有非懒加载的bean！！！！</span></span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点进去finishBeanFactoryInitialization(beanFactory)里头有个初始化non-lazy-init bean的函数preInstantiateSingletons()，具体逻辑如下：</p><ol><li>对beanNames集合遍历获取每个BeanDefinition；</li><li>判断是否是懒加载的，如果不是则继续处理(non-lazy-init bean不做处理)；</li><li>判断是否是factorybean如果不是则进行实例化并依赖注入。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 所有beanDefinition集合</span></span><br><span class="line">  List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">  <span class="comment">// 触发所有非懒加载单例bean的初始化</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="comment">// 获取beanDefinition</span></span><br><span class="line">    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="comment">// 判断是否是懒加载单例bean，如果是单例的并且不是懒加载的则在Spring 容器</span></span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      <span class="comment">// 判断是否是FactoryBean</span></span><br><span class="line">      <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">        Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">          <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">          <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                    ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                getAccessControlContext());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是普通bean则进行初始化依赖注入，此getBean(beanName)接下来触发的逻辑跟</span></span><br><span class="line">        <span class="comment">// context.getBean("beanName") 所触发的逻辑是一样的</span></span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于懒加载的bean，本质上就是手动去调用这个getBean(beanName)方法。所以在此我们找到了依赖注入的入口。</p><h1 id="Spring依赖注入的源码"><a href="#Spring依赖注入的源码" class="headerlink" title="Spring依赖注入的源码"></a>Spring依赖注入的源码</h1><h2 id="依赖注入实现的入口"><a href="#依赖注入实现的入口" class="headerlink" title="依赖注入实现的入口"></a>依赖注入实现的入口</h2><p>getBean()是个空壳方法，里面直接调用doGetBean()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">              @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Create bean instance.</span></span><br><span class="line">  <span class="comment">// 如果scope是单例，创建bean</span></span><br><span class="line">  <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建bean实例</span></span><br><span class="line">        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">        <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">        destroySingleton(beanName);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个getSingleton()的第二个参数使用lambda表达式传入createBean()方法，真正创建bean实例的方法在这个createBean()方法里面。</p><p>createBean()中经过一系列预处理，最后调doCreateBean()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">  <span class="comment">// Instantiate the bean.</span></span><br><span class="line">  <span class="comment">//第一步 创建bean实例，还未进行属性填充和各种特性的初始化</span></span><br><span class="line">  BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">  Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">  Object exposedObject = bean;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 第二步 进行属性填充(依赖注入)</span></span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    <span class="comment">// 第三步 执行bean的初始化方法</span></span><br><span class="line">    exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// 抛相应异常</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register bean as disposable.</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里关注第二步进行依赖注入的代码populateBean(beanName, mbd, instanceWrapper)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到所有的属性</span></span><br><span class="line">  PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line">  <span class="comment">// 这里处理自动装配类型的，也就是autowire为byName还是byType</span></span><br><span class="line">  <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">    MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line">    <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">    <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">      autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">    <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line">    pvs = newPvs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查看后置处理器是否准备好，这里的后置处理器会通过其中一个子类InstantiationAwareBeanPostProcessors</span></span><br><span class="line">  <span class="comment">// 来处理以@Autowire标签来注入的bean</span></span><br><span class="line">  <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">  <span class="comment">// 是否需要依赖检查，分为4个等级：1. 不检查 - None；2. 检查object引用 - object；</span></span><br><span class="line">  <span class="comment">// 3. 检查简单依赖 - simple；4. 全部检查 - all。</span></span><br><span class="line">  <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">  PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      pvs = mbd.getPropertyValues();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="comment">// 通过InstantiationAwareBeanPostProcessor接口的实现类来处理依赖注入</span></span><br><span class="line">      <span class="comment">// 如果是注解方式，使用AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">      <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">        InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">        <span class="comment">// 此处会进行对注解方式的注入！！！</span></span><br><span class="line">        PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">          &#125;</span><br><span class="line">          pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">          <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pvs = pvsToUse;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// XML形式注入</span></span><br><span class="line">    applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解形式注入的源码"><a href="#注解形式注入的源码" class="headerlink" title="注解形式注入的源码"></a>注解形式注入的源码</h2><p>基于注解的方式我们关注<code>PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName)</code>这个方法调用。看一下AutowiredAnnotationBeanPostProcessor中的postProcessProperties()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里定义了把谁注入进哪里</span></span><br><span class="line">  InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 进行依赖注入</span></span><br><span class="line">    metadata.inject(bean, beanName, pvs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Injection of autowired dependencies failed"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InjectionMetadata这个类封装了依赖的bean信息<code>private final Collection&lt;InjectedElement&gt; injectedElements;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, @Nullable String beanName, @Nullable PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  Collection&lt;InjectedElement&gt; checkedElements = <span class="keyword">this</span>.checkedElements;</span><br><span class="line">  <span class="comment">// 这里取的是Collection&lt;InjectedElement&gt; injectedElements这个集合</span></span><br><span class="line">  Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">      (checkedElements != <span class="keyword">null</span> ? checkedElements : <span class="keyword">this</span>.injectedElements);</span><br><span class="line">  <span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 对集合中的元素进行注入</span></span><br><span class="line">    <span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Processing injected element of bean '"</span> + beanName + <span class="string">"': "</span> + element);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 此处通过反射完成注入method.invoke(target, getResourceToInject(target, beanName));</span></span><br><span class="line">      element.inject(target, beanName, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XML形式注入的源码"><a href="#XML形式注入的源码" class="headerlink" title="XML形式注入的源码"></a>XML形式注入的源码</h2><p>在populateBean()中最后面有通过XML形式注入的入口<code>applyPropertyValues(beanName, mbd, bw, pvs);</code>，这个方法主要做的事情是把属性转换为相应的类的属性类型，最终注入到bean中，主要分为三个步骤：</p><ul><li>判断是否完成转换；</li><li>进行转换；</li><li>注入到bean中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">  MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">  List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">    mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">    <span class="comment">// 判断是否完成转换</span></span><br><span class="line">    <span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">      <span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        bw.setPropertyValues(mpvs);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取属性值的list</span></span><br><span class="line">    original = mpvs.getPropertyValueList();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">  <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    converter = bw;</span><br><span class="line">  &#125;</span><br><span class="line">  BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">  List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;&gt;(original.size());</span><br><span class="line">  <span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">      deepCopy.add(pv);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 属性名</span></span><br><span class="line">      String propertyName = pv.getName();</span><br><span class="line">      Object originalValue = pv.getValue();</span><br><span class="line">      <span class="keyword">if</span> (originalValue == AutowiredPropertyMarker.INSTANCE) &#123;</span><br><span class="line">        Method writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod();</span><br><span class="line">        <span class="keyword">if</span> (writeMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Autowire marker for property without write method: "</span> + pv);</span><br><span class="line">        &#125;</span><br><span class="line">        originalValue = <span class="keyword">new</span> DependencyDescriptor(<span class="keyword">new</span> MethodParameter(writeMethod, <span class="number">0</span>), <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 转换后的属性值，也就是对于1.Bean 2.Array 3.List 4.Set 5.Map 6.String等数据结构进行转换，重要！！！</span></span><br><span class="line">      Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">      Object convertedValue = resolvedValue;</span><br><span class="line">      <span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">          !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">      <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">        convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Possibly store converted value in merged bean definition,</span></span><br><span class="line">      <span class="comment">// in order to avoid re-conversion for every created bean instance.</span></span><br><span class="line">      <span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">          pv.setConvertedValue(convertedValue);</span><br><span class="line">        &#125;</span><br><span class="line">        deepCopy.add(pv);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">          !((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">          !(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">        pv.setConvertedValue(convertedValue);</span><br><span class="line">        deepCopy.add(pv);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">        deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 转换完成</span></span><br><span class="line">  <span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">    mpvs.setConverted();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set our (possibly massaged) deep copy.</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 进行属性注入，和注解方式的inject方法类似</span></span><br><span class="line">    bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>依赖注入部分主要是以下几点：</p><ol><li>依赖注入是bean生命周期的重要一环；</li><li>依赖注入是属性注入的一种，只不过注入的是bean类型；</li><li>何时发生依赖注入；</li><li>两种注入方式（注解方式和XML方式）的源码。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码分析 —— bean实例化原理</title>
      <link href="/2020/01/12/spring-bean-instantiation/"/>
      <url>/2020/01/12/spring-bean-instantiation/</url>
      
        <content type="html"><![CDATA[<p>整理一下Spring bean的实例化相关内容。创建Spring bean实例是Spring bean生命周期的第一阶段。</p><p>本文基于annotation注解配置的方式进行分析。</p><h1 id="bean实例化入口"><a href="#bean实例化入口" class="headerlink" title="bean实例化入口"></a>bean实例化入口</h1><p>Spring bean的生命周期主要有如下几个步骤：</p><ul><li>创建bean的实例</li><li>给实例化出来的bean填充属性</li><li>初始化bean</li><li>通过IOC容器使用bean</li><li>容器关闭时销毁bean</li></ul><p>在AnnotationConfigApplicationContext初始化时，调用关键方法refresh()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>();</span><br><span class="line">  register(componentClasses);</span><br><span class="line">  <span class="comment">// Spring容器初始化入口</span></span><br><span class="line">  refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring初始化入口refresh（省略了部分代码，提升阅读体验）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">      <span class="comment">// 在这里初始化所有非懒加载的bean！！！！</span></span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点进去finishBeanFactoryInitialization(beanFactory)里头有个初始化non-lazy-init bean的函数preInstantiateSingletons()，具体逻辑如下：</p><ol><li>对beanNames集合遍历获取每个BeanDefinition；</li><li>判断是否是懒加载的，如果不是则继续处理(non-lazy-init bean不做处理)；</li><li>判断是否是factorybean如果不是则进行实例化并依赖注入。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 所有beanDefinition集合</span></span><br><span class="line">  List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">  <span class="comment">// 触发所有非懒加载单例bean的初始化</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="comment">// 获取beanDefinition</span></span><br><span class="line">    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="comment">// 判断是否是懒加载单例bean，如果是单例的并且不是懒加载的则在Spring容器中加载</span></span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      <span class="comment">// 判断是否是FactoryBean</span></span><br><span class="line">      <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">        Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">          <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">          <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                    ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                getAccessControlContext());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是普通bean则进行初始化依赖注入，此getBean(beanName)接下来触发的逻辑跟</span></span><br><span class="line">        <span class="comment">// context.getBean("beanName") 所触发的逻辑是一样的</span></span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getBean()方法是实现bean初始化以及依赖注入的函数，本篇我们只关注bean的初始化。</p><p>对于lazy-init和non-lazy-init此时开始分叉。</p><h1 id="初始化懒加载bean"><a href="#初始化懒加载bean" class="headerlink" title="初始化懒加载bean"></a>初始化懒加载bean</h1><p>上面preInstantiateSingletons()方法中看到如果不是懒加载的bean则执行初始化，实际上是Spring帮用户调用了getBean()方法来完成的。</p><p>所以在懒加载bean的情景中，preInstantiateSingletons()方法直接返回，我们在使用bean的时候手动去getBean()，也就是完成了后续的初始化过程，此谓“懒加载”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  AnnotationConfigApplicationContext ac =</span><br><span class="line">      <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  ac.getBean(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于非懒加载的bean，getBean()的时候会从缓存里头取，因为容器初始化阶段已经初始化了。</p><h1 id="初始化普通的单例bean"><a href="#初始化普通的单例bean" class="headerlink" title="初始化普通的单例bean"></a>初始化普通的单例bean</h1><h2 id="寻找bean实例化入口"><a href="#寻找bean实例化入口" class="headerlink" title="寻找bean实例化入口"></a>寻找bean实例化入口</h2><p>getBean()是个空壳方法，里面直接调用doGetBean()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">              @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Create bean instance.</span></span><br><span class="line">  <span class="comment">// 如果scope是单例，创建bean</span></span><br><span class="line">  <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建bean实例</span></span><br><span class="line">        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">        <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">        destroySingleton(beanName);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个getSingleton()的第二个参数使用lambda表达式传入createBean()方法，真正创建bean实例的方法在这个createBean()方法里面。</p><p>createBean()中经过一系列预处理，最后调doCreateBean()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">  <span class="comment">// Instantiate the bean.</span></span><br><span class="line">  <span class="comment">//第一步 创建bean实例，还未进行属性填充和各种特性的初始化</span></span><br><span class="line">  BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">  Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">  Object exposedObject = bean;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 第二步 进行属性填充(依赖注入)</span></span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    <span class="comment">// 第三步 执行bean的初始化方法</span></span><br><span class="line">    exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// 抛相应异常</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register bean as disposable.</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里要注意区分bean实例化（第一步）和初始化（第三步）的区别：</p><ul><li>实例化是指完成对象创建，此时它只是一个java对象，还没有完成和Spring有关的集成，也就是没有完成各种PostProcessors的洗礼；</li><li>初始化是指在完成实例化的同时，继而完成了各种与Spring容器集成等PostProcessors的处理，并且将其放入Spring的IOC容器中（本质上就是那个singletonMap）。</li></ul></blockquote><p>这里我们只关心第一步创建bean实例的流程：instanceWrapper = createBeanInstance(beanName, mbd, args);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">  Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用工厂方法进行实例化</span></span><br><span class="line">  <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line">  Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">  <span class="comment">// 使用带参构造函数初始化</span></span><br><span class="line">  <span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">      mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">    <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">  <span class="comment">// 默认实例化方式 无参构造实例化</span></span><br><span class="line">  <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步主要根据BeanDefinition里的元数据定义决定使用哪种实例化方法，主要有下面三种：</p><ul><li>instantiateUsingFactoryMethod 工厂方法实例化的具体实现；</li><li>autowireConstructor 有参构造函数实例化的具体实现；</li><li>instantiateBean 默认实例化具体实现（无参构造函数）。</li></ul><h2 id="bean实例化策略"><a href="#bean实例化策略" class="headerlink" title="bean实例化策略"></a>bean实例化策略</h2><p>找到bean实例化入口后，我们来研究一下bean的实例化策略：</p><ul><li>cglib；</li><li>简单反射。</li></ul><p>上面说到的两种实例化策略是根据BeanDefinition里的定义决定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Object beanInstance;</span><br><span class="line">    <span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">          getInstantiationStrategy().instantiate(mbd, beanName, parent),</span><br><span class="line">          getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在这里选择一种策略进行实例化</span></span><br><span class="line">      beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">    initBeanWrapper(bw);</span><br><span class="line">    <span class="keyword">return</span> bw;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里getInstantiationStrategy()会返回一种实例化策略，它们都是实现InstantiationStrategy接口的，该接口的实现类可以看到只有2种：</p><ul><li>CglibSubclassingInstantiationStrategy：cglib策略；</li><li>SimpleInstantiationStrategy：简单反射策略。</li></ul><p>然后真正调用实例化方法instantiate()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Don't override the class with CGLIB if no overrides.</span></span><br><span class="line">    <span class="comment">// methodOverride为空，也就是用户没有使用replace或者lookup的配置方法，采用简单反射的方式</span></span><br><span class="line">    <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">      Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">      <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">        <span class="comment">// 决策使用哪种构造器</span></span><br><span class="line">        constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">        <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">          <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">              constructorToUse = AccessController.doPrivileged(</span><br><span class="line">                  (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              constructorToUse = clazz.getDeclaredConstructor();</span><br><span class="line">            &#125;</span><br><span class="line">            bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 完成bean的实例化</span></span><br><span class="line">      <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line">      <span class="comment">// methodOverride不为空，采用cglib来创建</span></span><br><span class="line">      <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Bean实例化只是bean生命周期的一小部分，实际上只是bean初始化的一部分。</p><p>代码越读越薄。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java ThreadLocal使用及源码分析</title>
      <link href="/2019/12/01/java-threadLocal/"/>
      <url>/2019/12/01/java-threadLocal/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal作用和使用"><a href="#ThreadLocal作用和使用" class="headerlink" title="ThreadLocal作用和使用"></a>ThreadLocal作用和使用</h1><h2 id="ThreadLocal是啥？"><a href="#ThreadLocal是啥？" class="headerlink" title="ThreadLocal是啥？"></a>ThreadLocal是啥？</h2><p>ThreadLocal出现在各种语言中，我们主要关心它在Java中的使用和源码分析。</p><p>ThreadLocal的作用是提供线程内的局部变量，简单来说就是在各个线程内部创建一个变量的副本，我们可以观察到每一个Thread实例都有这样一个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line"> * by the ThreadLocal class. *&#x2F;</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;</span><br></pre></td></tr></table></figure><p>其实我们可以在并发环境下，使用各种锁的实现来访问变量，但实际上ThreadLocal的思想就是用空间换时间，每个线程都有一份变量的副本，保证各个线程内部的变量不互相干扰。</p><h2 id="ThreadLocal咋用？"><a href="#ThreadLocal咋用？" class="headerlink" title="ThreadLocal咋用？"></a>ThreadLocal咋用？</h2><p>ThreadLocal使用倒是比较简单的，贴一段测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="number">0</span>);</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-0</span><br><span class="line">null</span><br><span class="line">0</span><br><span class="line">Thread-1</span><br><span class="line">null</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>这里我们要注意第二个null，在Thread-0设置完ThreadLocal变量后，Thread-1拿到自己的ThreadLocal变量的值还是初始值null，正是体现了各个线程间的变量隔离。</p><p>另外一个要注意的点就是<strong>ThreadLocal变量要声明为static的</strong>。</p><h1 id="ThreadLocal源码"><a href="#ThreadLocal源码" class="headerlink" title="ThreadLocal源码"></a>ThreadLocal源码</h1><p>上面我们看到了每个线程实例都有一个ThreadLocalMap的属性，实际上：</p><ol><li>每个线程都维护着一个ThreadLocalMap，用来存放该线程所有的ThreadLocal；</li><li>ThreadLocalMap底层是一个<code>Entry[] table</code>数组，每一个Entry都是一个K-V，key为ThreadLocal，value为存储的值：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Entry这个数据结构，它是继承了WeakReference实现的，当ThreadLocal的引用销毁时（一般是线程结束），指向堆中的ThreadLocal实例的强引用就消失了，只有一条Entry的key指向ThreadLocal实例的弱引用，我们知道弱引用的特性，那么堆中ThreadLocal实例是可以被GC回收的。</p><p>此时Entry的key为null，但直到线程结束前，Entry中的value都是无法被回收的，这里就有可能造成<strong>内存泄漏</strong>，后面我们会分析如何解决。</p><p>回过头来看下代码吧，ThreadLocal都是怎么实现的。</p><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 传入this，也就是ThreadLocal本身作为了map的key</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="comment">// 返回get的值</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若没有拿到map，进行初始化</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑清晰，不用过多解释了，下面再看看里面具体的几个方法。</p><h3 id="getMap"><a href="#getMap" class="headerlink" title="getMap"></a>getMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法很简单，拿到当前线程的threadLocals，也就是最开始我们说的Thread类中定义的那个属性，初始值为null。</p><h3 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue"></a>setInitialValue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initial value直接就是null</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 拿到map，就把null value设进去</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 拿不到map就创建一个</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createMap()很简单，new一个ThreadLocalMap实例。</p><p>ThreadLocalMap是我们分析的重点了，下面的一些源码都是针对这个静态内部类来分析的。首先看一下它的成员变量和定义（去掉源码的一些注释）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义了Entry的数据结构</span></span><br><span class="line">    <span class="comment">// ThreadLocalMap本质上就是Entry[]</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始容量16</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最重要的Entry数组</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组中的size</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义threshold值，默认loadfactor为2/3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash时设置threshold</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全移动索引</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找下一个index</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找上一个index</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap的构造函数，没啥可解释的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map-getEntry"><a href="#map-getEntry" class="headerlink" title="map.getEntry"></a>map.getEntry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看一下这个getEntryAfterMiss()方法。</p><h3 id="getEntryAfterMiss"><a href="#getEntryAfterMiss" class="headerlink" title="getEntryAfterMiss"></a>getEntryAfterMiss</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// key为null则清理entry</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 开放寻址法处理hash冲突</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// e为null时直接返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看一下key为null则清理entry，因为此时这个entry就是一个过期对象。其实这个expungeStaleEntry()方法就是在key为null时，为了避免value还是强引用无法GC，从而造成内存泄漏。其实在每一个get()、set()操作时都会清理这些key为null的entry的。</p><h3 id="expungeStaleEntry"><a href="#expungeStaleEntry" class="headerlink" title="expungeStaleEntry"></a>expungeStaleEntry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. expunge entry at staleSlot</span></span><br><span class="line">    <span class="comment">// key为null，则把value设为null</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Entry的引用也设为null</span></span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要有两个部分：</p><ol><li>expunge entry at staleSlot：将value设置为null，并且Entry的引用也设置为null，GC时就会回收掉；</li><li>Rehash until we encounter null：将staleSlot之后、null值之前的这一段做调整。清除key为null的Entry，对于key不为null，做rehash。</li></ol><p>做rehash主要是方便下次处理hash冲突，或者尽量避免hash冲突。</p><h2 id="set-方法"><a href="#set-方法" class="headerlink" title="set()方法"></a>set()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map-set"><a href="#map-set" class="headerlink" title="map.set"></a>map.set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 计算索引值</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环检测，开放寻址法处理hash冲突</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="comment">// 找到key，设置value并返回</span></span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 更换这个key为null的Entry，相当于插入key-value</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有hash冲突时，直到遇到为null的地方，就在这个地方创建新Entry</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// cleanSomeSlots中调用expungeStaleEntry方法，清理Entry</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        <span class="comment">// 如果做了清理，并且超过了threshold，做rehash</span></span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry"></a>replaceStaleEntry</h3><p>set()方法中调用了这个方法，它主要是处理key为null时的场景，因为有可能此时的value还不为null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前找到key为null的位置，记为slotToExpunge</span></span><br><span class="line">    <span class="comment">// 这是为了后面清理的过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从staleSlot向后找，到下一个null为止</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 若找到key和传入的key相等</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="comment">// 把这个Entry更新value</span></span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把它和staleSlot位置的Entry交换</span></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 调用cleanSomeSlots清理key为null的Entry</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">    <span class="comment">// 如果直到后面的null都没有找到和传入的key相等的key</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 就在staleSlot处新建一个Entry</span></span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        <span class="comment">// 再清理一遍key为null的Entry</span></span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法我们再捋一遍：</p><ol><li>第1个for循环：我们向前找到key为null的位置，记录为slotToExpunge，这里是为了后面的清理过程，可以不关注了；</li><li>第2个for循环：我们从staleSlot起到下一个null为止，若是找到key和传入key相等的Entry，就给这个Entry赋新的value值，并且把它和staleSlot位置的Entry交换，然后调用CleanSomeSlots()清理key为null的Entry；</li><li>若是一直没有key和传入key相等的Entry，那么就在staleSlot处新建一个Entry。函数最后再清理一遍空key的Entry。</li></ol><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>rehash()执行的时机是<code>size &gt;= threshold</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清理完key为null的Entry后，如果size &gt;= threshold的3/4，调用resize()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="comment">// 扩容为原来的2倍</span></span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 对于每一个Entry做rehash</span></span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">         <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">// 删除Entry</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">// 做清理</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用ThreadLocal注意事项"><a href="#使用ThreadLocal注意事项" class="headerlink" title="使用ThreadLocal注意事项"></a>使用ThreadLocal注意事项</h1><p>我们在使用ThreadLocal时，最关心的是内存泄漏问题，但经过我们以上详尽的分析，发现无论是get()、set()还是remove()方法，key为null的Entry都会被清除，那么其实Entry内部的value也就没有强引用了，则会被GC回收。</p><p>但如果没有调用过get()或者set()，就<strong>有可能</strong>有内存泄漏的问题，所以最好的习惯是：</p><ol><li>手动调用remove()方法，清除不再使用的ThreadLocal；</li><li>尽量将ThreadLocal设置为private static的，这样ThreadLocal会跟着线程本身一起消亡。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Concurrency </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized原理剖析</title>
      <link href="/2019/11/16/java-synchronized/"/>
      <url>/2019/11/16/java-synchronized/</url>
      
        <content type="html"><![CDATA[<p>synchronized关键字原理在我个人看来应该是java中最难的几个问题之一了。其用法不难，但里面涉及的知识点很多。它作为关键字提供了并发环境中多线程的同步机制，但就是因此，我们无法直观的看到它的源码，从而很难探究它的底层原理。</p><h1 id="synchronized用法"><a href="#synchronized用法" class="headerlink" title="synchronized用法"></a>synchronized用法</h1><p>synchronized可以修饰方法或者代码块：</p><ul><li>方法：<ul><li>静态方法</li><li>实例方法</li></ul></li><li>代码块：<ul><li>实例对象</li><li>class对象</li></ul></li></ul><p>我们不会看它如何使用，而是主要探究其原理，同样的，本文适合对于synchronized关键字有一定使用经验的人。接下来通过反编译来看看它的究竟。</p><h2 id="synchronized作用于代码块"><a href="#synchronized作用于代码块" class="headerlink" title="synchronized作用于代码块"></a>synchronized作用于代码块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Solution<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"test synchronized"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反编译可得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]) throws java.lang.InterruptedException;</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; class com&#x2F;leetcode&#x2F;Solution</span><br><span class="line">         2: dup</span><br><span class="line">         3: astore_1</span><br><span class="line">         4: monitorenter</span><br><span class="line">         5: getstatic     #3                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         8: ldc           #4                  &#x2F;&#x2F; String test synchronized</span><br><span class="line">        10: invokevirtual #5                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">        13: aload_1</span><br><span class="line">        14: monitorexit</span><br><span class="line">        15: goto          23</span><br><span class="line">        18: astore_2</span><br><span class="line">        19: aload_1</span><br><span class="line">        20: monitorexit</span><br><span class="line">        21: aload_2</span><br><span class="line">        22: athrow</span><br><span class="line">        23: return</span><br></pre></td></tr></table></figure><p>注意第4行的monitorenter和14行的monitorexit，也就是在synchronized作用于代码块时，JVM通过这两个指令进行了同步，那么它们如何保证同步的呢？我们后面会分析。</p><h2 id="synchronized作用于方法"><a href="#synchronized作用于方法" class="headerlink" title="synchronized作用于方法"></a>synchronized作用于方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test synchronized method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译可得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; String test synchronized method</span><br><span class="line">         5: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">         8: return</span><br></pre></td></tr></table></figure><p>注意到字节码的flags中多了一个ACC_SYNCHRONIZED，也就是synchronized作用于方法时，JVM在方法访问标识符flags中加入ACC_SYNCHRONIZED来实现同步。</p><h1 id="monitorenter、monitorexit和ACC-SYNCHRONIZED"><a href="#monitorenter、monitorexit和ACC-SYNCHRONIZED" class="headerlink" title="monitorenter、monitorexit和ACC_SYNCHRONIZED"></a>monitorenter、monitorexit和ACC_SYNCHRONIZED</h1><p>我们会根据oracle提供的jvm规范文档来介绍这三个指令。</p><h2 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h2><blockquote><p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p><p>If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</p><p>If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.</p><p>If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</p></blockquote><p>翻译过来就是：</p><blockquote><p>每个对象都与一个monitor相关联。当且仅当拥有所有者时（被拥有），monitor才会被锁定。执行到monitorenter指令的线程，会尝试去获得对应的monitor，如下：</p><p>每个对象维护着一个记录着被锁次数的计数器, 对象未被锁定时，该计数器为0。线程进入monitor（执行monitorenter指令）时，会把计数器设置为1.</p><p>当同一个线程再次获得该对象的锁的时候，计数器再次自增.</p><p>当其他线程想获得该monitor的时候，就会阻塞，直到计数器为0才能成功。</p></blockquote><h2 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h2><blockquote><p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.</p><p>The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p></blockquote><p>翻译过来就是：</p><blockquote><p>monitor的拥有者线程才能执行monitorexit指令。</p><p>线程执行monitorexit指令，就会让monitor的计数器减一。如果计数器为0，表明该线程不再拥有monitor。其他线程就允许尝试去获得该monitor了。</p></blockquote><h2 id="ACC-SYNCHRONIZED"><a href="#ACC-SYNCHRONIZED" class="headerlink" title="ACC_SYNCHRONIZED"></a>ACC_SYNCHRONIZED</h2><blockquote><p>Method-level synchronization is performed implicitly, as part of method invocation and return. A synchronized method is distinguished in the run-time constant pool’s method_info structure by the ACC_SYNCHRONIZED flag, which is checked by the method invocation instructions. When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly. During the time the executing thread owns the monitor, no other thread may enter it. If an exception is thrown during invocation of the synchronized method and the synchronized method does not handle the exception, the monitor for the method is automatically exited before the exception is rethrown out of the synchronized method.</p></blockquote><p>翻译过来就是：</p><blockquote><p>方法级别的同步是隐式的，作为方法调用的一部分。同步方法的常量池中会有一个ACC_SYNCHRONIZED标志。</p><p>当调用一个设置了ACC_SYNCHRONIZED标志的方法，执行线程需要先获得monitor锁，然后开始执行方法，方法执行之后再释放monitor锁，当方法不管是正常return还是抛出异常都会释放对应的monitor锁。</p><p>在这期间，如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。</p><p>如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。</p></blockquote><p>那么我们多次提到的monitor究竟是个什么东西呢？</p><h1 id="monitor监视器"><a href="#monitor监视器" class="headerlink" title="monitor监视器"></a>monitor监视器</h1><h2 id="操作系统中的管程"><a href="#操作系统中的管程" class="headerlink" title="操作系统中的管程"></a>操作系统中的管程</h2><p>我们都知道管程在操作系统中提供了一种机制，它提供线程间的互斥访问。</p><p>实际上，操作系统中的管程是概念原理，或者说是一种规范，而ObjectMonitor是它在JVM（HotSpot）中的具体实现。</p><h2 id="ObjectMonitor"><a href="#ObjectMonitor" class="headerlink" title="ObjectMonitor"></a>ObjectMonitor</h2><h3 id="数据结构（定义）"><a href="#数据结构（定义）" class="headerlink" title="数据结构（定义）"></a>数据结构（定义）</h3><p>在HotSpot中，ObjectMonitor的主要数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       &#x3D; NULL;</span><br><span class="line">    _count        &#x3D; 0;      &#x2F;&#x2F; *记录owner线程获取锁的个数</span><br><span class="line">    _waiters      &#x3D; 0,</span><br><span class="line">    _recursions   &#x3D; 0;      &#x2F;&#x2F; *锁的重入次数</span><br><span class="line">    _object       &#x3D; NULL;</span><br><span class="line">    _owner        &#x3D; NULL;   &#x2F;&#x2F; *指向持有monitor对象的线程</span><br><span class="line">    _WaitSet      &#x3D; NULL;   &#x2F;&#x2F; *存放处于wait状态的线程队列</span><br><span class="line">    _WaitSetLock  &#x3D; 0 ;</span><br><span class="line">    _Responsible  &#x3D; NULL ;</span><br><span class="line">    _succ         &#x3D; NULL ;</span><br><span class="line">    _cxq          &#x3D; NULL ;</span><br><span class="line">    FreeNext      &#x3D; NULL ;</span><br><span class="line">    _EntryList    &#x3D; NULL ;  &#x2F;&#x2F; *存放处于等待锁block状态的线程队列</span><br><span class="line">    _SpinFreq     &#x3D; 0 ;</span><br><span class="line">    _SpinClock    &#x3D; 0 ;</span><br><span class="line">    OwnerIsThread &#x3D; 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点字段已经使用“*”标记出来了。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="/images/monitor.png" alt="monitor"></p><ul><li>想要获取monitor的线程，首先会进入_EntryList队列；</li><li>当某个线程获取到对象的monitor后，进入_Owner区域，设置为当前线程，同时计数器_count加1；</li><li>如果线程调用了wait()方法，则会进入_WaitSet队列。它会释放monitor锁，即将_owner赋值为null，_count自减1，进入_WaitSet队列阻塞等待；</li><li>如果其他线程调用 notify() / notifyAll()，会唤醒_WaitSet中的某个线程，该线程再次尝试获取monitor锁，成功即进入_Owner区域；</li><li>同步方法执行完毕了，线程退出临界区，会将monitor的owner设为null，并释放监视锁。</li></ul><p>以代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;  <span class="comment">//进入_EntryList队列</span></span><br><span class="line">    doSth();</span><br><span class="line">    wait();           <span class="comment">//进入_WaitSet队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象如何与monitor关联"><a href="#对象如何与monitor关联" class="headerlink" title="对象如何与monitor关联"></a>对象如何与monitor关联</h1><p>对象是如何与monitor关联起来的呢？</p><p><img src="/images/objectMonitor.png" alt="objectMonitor"></p><p>由此可见，实例对象中有一个对象头，在对象头的Mark word中，如果这个对象被上了重量级锁，Mark word中会有一个指向互斥量（重量级锁）的指针，指向ObjectMonitor对象，从而实现了对象与monitor的关联。</p><p>接下来我们就一层一层的看下去，这中间令人一头雾水的各个名词都是什么意思？以及什么原理？</p><h2 id="Java对象内存布局"><a href="#Java对象内存布局" class="headerlink" title="Java对象内存布局"></a>Java对象内存布局</h2><p>由上图可见，在JVM中，对象在堆中的布局可以分为三块：对象头、实例数据和对齐填充。</p><p>那么我们如何证明这一点呢？口说无凭啊。我们可以通过一个依赖包来打印对象的内存布局：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>然后简单创建个对象就可以打印出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">L</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">L l = <span class="keyword">new</span> L();</span><br><span class="line">System.out.println(ClassLayout.parseInstance(l).toPrintable());</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">com.leetcode.L object internals:</span><br><span class="line"> OFFSET  SIZE  TYPE DESCRIPTION    VALUE</span><br><span class="line">  0     4       (object header)    01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">  4     4       (object header)    00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">  8     4       (object header)    43 c1 00 f8 (01000011 11000001 00000000 11111000) (-134168253)</span><br><span class="line"> 12     1   boolean L.flag         false</span><br><span class="line"> 13     3       (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 3 bytes external &#x3D; 3 bytes total</span><br></pre></td></tr></table></figure><p>其中的object header就是我们说的“<strong>对象头</strong>”，中间的L.flag实际上就是我们上面定义的L类实例的对象l的“<strong>实例数据</strong>”，自此总共有13 bytes。</p><p>但64位的JVM要求对象大小必须是8个bytes的倍数，也就是即使只有一个boolean是1 byte，也要加上7 bytes的字节填充。上面的输出中“loss due to the next object alignment”我们可以看到在基于原来的13 bytes基础上，又加上了3 bytes的“<strong>字节填充</strong>”，刚好可以解释我们上面画的图是正确的。</p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>这里我们只看上面对象头部分的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OFFSET  SIZE  TYPE DESCRIPTION    VALUE</span><br><span class="line"> 0     4       (object header)    01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line"> 4     4       (object header)    00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line"> 8     4       (object header)    43 c1 00 f8 (01000011 11000001 00000000 11111000) (-134168253)</span><br></pre></td></tr></table></figure><p>在我的64位机器上拿到的对象头是12 bytes，也就是96 bits（有些同学会测出来128 bits，这是因为有些机器开启了指针压缩造成的，这里不做详述）。</p><p>JVM规范：对象头是每个gc管理的堆对象的公共结构，包括堆对象的：</p><ul><li>布局；</li><li>类型（存放指向元空间类模板的指针）；</li><li>gc状态（4位bit）；</li><li>同步状态（后面会说）；</li><li>哈希码（此处注意，hashcode并不存在*）；</li></ul><p>的基本信息。所有的java对象和jvm内部对象都有一个通用的对象头格式。</p><p>根据JVM规范，对象头 = mark word（8byte） + klass pointer（4byte） = 12 bytes。其中klass pointer就是元空间内类的模板信息（指针）。如果是数组，还有4个byte记录长度 + 长度的动态byte数。</p><p>那么我们现在知道了，后面的4个bytes是类模板的指针，那前8个bytes的Mark word又是什么？每一位都表示什么呢？</p><h2 id="Mark-word"><a href="#Mark-word" class="headerlink" title="Mark word"></a>Mark word</h2><p>Mark word中存放了堆对象的gc状态、同步状态、哈希码等信息，但其实这里面也有坑（hash码真的存了吗）。</p><p>我们先来看一下不同状态锁的时候，Mark word的表现：</p><table><thead><tr><th>Object Header（96 bits）</th><th></th><th></th></tr></thead><tbody><tr><td>Mark word（64 bits）</td><td>Klass word（32 bits）</td><td></td></tr><tr><td>unused: 25 | hashcode: 31 |unused: 1 | age: 4| blased_lock: 1| lock: 2</td><td>pointer to metadata object</td><td>无锁</td></tr><tr><td>thread: 54 | epoch: 2| unused: 1| age: 4|blased_lock: 1| lock: 2</td><td>pointer to metadata object</td><td>偏向锁</td></tr><tr><td>—————– ptr_to_lock_record: 62 —————–| lock: 2</td><td>pointer to metadata object</td><td>轻量锁</td></tr><tr><td>—————– ptr_to_heavyweight_monitor: 62 —————–| lock: 2</td><td>pointer to metadata object</td><td>重量锁</td></tr><tr><td>—————————————————————————————————————————- | lock: 2</td><td>pointer to metadata object</td><td>gc</td></tr></tbody></table><p>注意这里的<code>ptr_to_heavyweight_monitor</code>，后面我们会对它进行分析。</p><p>1、同步状态：</p><p>需要blased_lock（偏向锁标识）和lock（锁状态标识）共同表示前两种状态：</p><ul><li>blased_lock：0，lock：01：表示无锁；</li><li>blased_lock：1，lock：01：表示偏向锁；</li><li>lock：00：表示轻量锁；</li><li>lock：10：表示重量锁；</li><li>lock：11：表示gc标志。</li></ul><p>这是因为lock的2个bits只能表示4种状态，故而引入了1个bit标识偏向锁，而后的三种状态都没有blased_lock啥事儿了，用lock就够了。</p><p>2、gc状态：age字段表示gc状态，age只有4个bits，能表示的最大数字是15，这也就解释了为什么对象在young区的from和to交换15次就放到old区。</p><p>3、哈希码</p><p>这里大家可能跟我有一样的困惑，前8个bytes都是0，只有一个bit是1，哪里存的hash码？如此说来，那hash码真的存在于对象头吗？</p><p>我们在上面分析对象头时，用*标记了说明hash码其实是并不存在的，hashcode存的是地址，这个地址是需要计算出来的并不是绝对的内存地址。事实上object.hashcode()方法也是native方法，需要有计算过程，地址这个东西毕竟只有cpp才能知道。</p><p>那我怎么在对象头中显示hash码呢？很简单，上面手动调用hashcode()方法，hash码就会被存到对象头里面了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(l.hashCode());</span><br><span class="line">System.out.println(ClassLayout.parseInstance(l).toPrintable());</span><br></pre></td></tr></table></figure><p>输出为（对象头只贴value部分）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1625635731    &#x2F;&#x2F; hashcode</span><br><span class="line">VALUE</span><br><span class="line">01 93 3b e5 (00000001 10010011 00111011 11100101) (-449080575)</span><br><span class="line">60 00 00 00 (01100000 00000000 00000000 00000000) (96)</span><br><span class="line">43 c1 00 f8 (01000011 11000001 00000000 11111000) (-134168253)</span><br></pre></td></tr></table></figure><p>这样，hash码就出来了，这里细心的同学可能又要问了，那我算出来的<code>01 93 3b e5 60</code>得到的和调用hashcode()方法不一样啊，是不是搞错了？</p><p>这里还涉及到一个小知识点，就是计算机bit的大小端存储问题，至少在我的机器上是采用<strong>大端存储</strong>的，还记得刚刚无锁时对象头的bit分布吗？<code>unused: 1|age: 4|blased_lock: 1|lock: 2</code>这里一共8个bit，刚好是前面第一个0x01（最后一001表示无锁状态）。接下来按照倒序来讲就应该是hashcode了，并且这几个16进制数内部也是倒序的，所以应该是<code>60 e5 3b 93</code>的10进制刚好是1625635731，这和上面手动调用hashcode()方法得到的结果是一致的。</p><p>再强调一遍，正常来讲对象头预留了hashcode位，但初始是不存储的，需要计算。</p><h2 id="Mark-word中的重量锁"><a href="#Mark-word中的重量锁" class="headerlink" title="Mark word中的重量锁"></a>Mark word中的重量锁</h2><p>还记得上面我们留的坑吗？<code>ptr_to_heavyweight_monitor</code>在重量锁的情形下，Mark word中的后62个bits（大端存储机器）指向的就是堆中ObjectMonitor对象，仅此一句话而已。</p><p>其实到这里，synchronized原理我们已经剖析完了。难吗？不了解对象的内存布局可能一辈子都不知道咋实现的，因为也没有源码。但是简单吗？清晰地分析下来发现，<strong>synchronized就是通过两个指令和一个flag来操控ObjectMonitor对象，而这个monitor对象通过对象头中存储的地址来访问。</strong></p><h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><p>后面的jdk版本中（jdk 1.6之后），使用synchronized不会直接调用monitor的enter()和exit()方法了，直接调用被称作<strong>重量级锁</strong>，所以进行了一些锁优化，包括适应性自旋、锁消除、锁粗化、锁膨胀等一系列优化策略。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>当临界区很小的情况下，锁占用的时间很短，那么频繁的阻塞和唤醒对于CPU来说开销太大了，所以采用自旋的方式减少CPU从用户态转为核心态切换的时间。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>有些程序员写代码时，上来就对一个实例进行sync，也不管究竟有没有竞争。JVM会在运行时检测，对于不存在共享数据竞争的锁进行消除。</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>锁粗化是指对于一系列要加锁的操作，JVM会将它们连在一起，扩展成一个范围更大的锁，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> L l = <span class="keyword">new</span> L();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (l) &#123;</span><br><span class="line">            System.out.println(<span class="string">"锁粗化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果每次循环进去都加锁解锁简直是灾难，JVM会优化成下面这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> L l = <span class="keyword">new</span> L();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (l) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"锁粗化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><p>锁膨胀指的是根据被锁资源的竞争程度，进行无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁的升级过程，而不是上来就上个重量级锁。</p><ol><li>偏向锁：只有一个线程进入临界区；</li><li>轻量级锁：多个线程未竞争或者竞争不激烈，同步块执行速度非常快；</li><li>重量级锁：多线程竞争，高吞吐量，同步块执行时间较长。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Concurrency </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java ClassLoader原理及源码分析</title>
      <link href="/2019/10/04/java-classloader/"/>
      <url>/2019/10/04/java-classloader/</url>
      
        <content type="html"><![CDATA[<p>讲道理我们日常开发中基本涉及不到类加载器，大多数人更不必要去自定义类加载器，但我本着知其然必知其所以然的想法，还是对java中的类加载器是什么？如何工作？它的源码？）做尽量详细的分析。研究的过程毕竟是好玩的。</p><p>本文适合对于ClassLoader有初步了解的人阅读。</p><h1 id="Java类加载器理论"><a href="#Java类加载器理论" class="headerlink" title="Java类加载器理论"></a>Java类加载器理论</h1><h2 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器"></a>什么是类加载器</h2><p>Java中的类加载器（ClassLoader）用来加载class文件的。它就是JVM将编译好的.class文件加载到虚拟机中运行的工具，这个工具有JVM为我们提供的，我们也可以自己去实现。</p><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p>JVM自带的有3个类加载器：</p><ul><li>Bootstrap ClassLoader：启动类加载器，加载$JRE_HOME/lib下的rt.jar、resources.jar、charsets.jar和class文件等；</li><li>Extention ClassLoader：扩展的类加载器，加载$JRE_HOME/lib/ext下的jar包和class文件；</li><li>App ClassLoader：加载当前应用的classpath的所有类。</li></ul><p>除此之外，我们也可以根据自己的需求，自定义类加载器，自定义的类加载器是java.lang.ClassLoader的子类，可以定制类的加载方式。</p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>好多人对于这个双亲委派机制云里雾里，其实我也不喜欢“正经”地学习技术，那么在看这个概念之前，我希望我们一起默念下面这个口诀：<strong>我爸是李刚，有事找我爹 —– 往上捅</strong>。</p><p><img src="/images/classLoader.png" alt="classLoader"></p><p>加载一个类时，若父加载器可以加载，优先使用父加载器。<br>这样做避免自己写的类（如自己写了一个String.java）污染Java的源代码，提高程序安全性。</p><p>核心：</p><p><strong>当一个类收到了类加载请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到BootstrapClassLoader中，只有当父类加载器反馈自己无法完成这个请求时（在它自己的加载路径下没有找到所需的class），子类加载器才会尝试自己去加载。</strong></p><p>采用双亲委派的一个<strong>好处</strong>是，比如加载位于rt.jar的类java.lang.Object，不管哪个加载器加载这个类，最后都是委托给顶层的bootstrap类加载器进行加载，这样保证了使用不同的类加载器最终都获得同一个object对象。</p><h3 id="loadClass-源码"><a href="#loadClass-源码" class="headerlink" title="loadClass()源码"></a>loadClass()源码</h3><p>在双亲委派机制中，有一个非常重要的<code>loadClass(String name, boolean resolve)</code>方法，我们先抽象的来看一下这个方法的执行步骤：</p><ol><li>调用findLoadedClass(String)来检查传进来的name对应的class是不是已经加载过了；</li><li>如果没有，调用父加载器的loadClass()方法。如果父加载器是null，则使用jvm内置的加载器，也就是BootstrapClassLoader。这也就是为什么ExtClassLoader的parent为null，但仍然说BootstrapClassLoader是它的父加载器，后面我们会具体说；</li><li>如果向上委托父加载器没有加载成功，则通过自己的findClass(String)来加载。</li></ol><p>Show me the code，下面这段代码详细解释了双亲委派模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 首先，检测是否已经加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 若没有被加载</span></span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 父加载器不为空则调用父加载器的loadClass</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 父加载器为空则调用BootstrapClassLoader</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">// 如果向上委托没有加载成功，自己加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的是如果要编写一个classLoader的子类，也就是自定义一个classLoader，<strong>建议覆盖findClass()方法，而不要直接改写loadClass()方法</strong>。</p><h2 id="父加载器是父类吗？"><a href="#父加载器是父类吗？" class="headerlink" title="父加载器是父类吗？"></a>父加载器是父类吗？</h2><p>父加载器不是父类，ExtClassLoader、AppClassLoader以及自定义的加载器的继承关系都是<code>-&gt; URLClassLoader -&gt; SecureClassLoader -&gt; ClassLoader</code>。但实际上我们调用getParent()方法时，得到的并不是它的父类，而是父加载器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="comment">// Note: VM hardcoded the offset of this field, thus all new fields</span></span><br><span class="line">    <span class="comment">// must be added *after* it.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">    <span class="comment">// The class loader for the system</span></span><br><span class="line">    <span class="comment">// @GuardedBy("ClassLoader.class")</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClassLoader scl;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initSystemClassLoader();</span><br><span class="line">        <span class="keyword">if</span> (scl == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> scl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!sclSet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scl != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recursive invocation"</span>);</span><br><span class="line">            sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">            <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Throwable oops = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 通过Launcher获取ClassLoader</span></span><br><span class="line">                scl = l.getClassLoader();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    scl = AccessController.doPrivileged(</span><br><span class="line">                        <span class="keyword">new</span> SystemClassLoaderAction(scl));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                    oops = pae.getCause();</span><br><span class="line">                    <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> InvocationTargetException) &#123;</span><br><span class="line">                        oops = oops.getCause();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (oops != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> (Error) oops;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// wrap the exception</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> Error(oops);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sclSet = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以实际上，getParent()返回的就是一个ClassLoader对象parent，而parent又有2种情况：</p><ol><li>自定义类（也就是我们平时自己写的class）创建ClassLoader时直接指定一个ClassLoader为parent；</li><li>由l.getClassLoader()获取，也就是Launcher发现如果没有指定parent，会默认指定ClassLoader为AppClassLoader。</li></ol><p>那么接下来的一个问题：在测试过程中遇到了这样一个现象，下面代码会输出什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Test<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">System.out.println(Test<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getParent</span>())</span>;</span><br><span class="line">System.out.println(Test<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getParent</span>().<span class="title">getParent</span>())</span>;</span><br></pre></td></tr></table></figure><p>我们可以先想一想，<code>Test.class</code>是我们自己实现的一个类，那么它的ClassLoader应该是AppClassLoader。那么它的parent()应该是ExtClassLoader，再parent()就应该是BootstrapClassLoader了吧，但事实是这样吗？</p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@610455d6</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>前两个猜对了，但第三个为啥是null？</p><p>这是因为BootstrapClassLoader是C++编写的，它本身也是JVM的一部分，所以严格意义来讲，它并不是一个java类，也就无法在java代码中获取它的引用。</p><h1 id="类加载器源码"><a href="#类加载器源码" class="headerlink" title="类加载器源码"></a>类加载器源码</h1><p>上面的“双亲委派机制”分析了ClassLoader加载类时的理论模型，下面我们来根据源码更好的理解一下（为了阅读体验，精简了部分源码）。</p><h2 id="Launcher和BootstrapClassLoader"><a href="#Launcher和BootstrapClassLoader" class="headerlink" title="Launcher和BootstrapClassLoader"></a>Launcher和BootstrapClassLoader</h2><p>看<code>sun.misc.Launcher</code>,它是一个java虚拟机的入口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath =</span><br><span class="line">        System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create the extension class loader</span></span><br><span class="line">        <span class="comment">// 创建ExtClassLoader</span></span><br><span class="line">        ClassLoader extcl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">                <span class="string">"Could not create extension class loader"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now create the class loader to use to launch the application</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过ExtClassLoader创建AppClassLoader</span></span><br><span class="line">            loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">                <span class="string">"Could not create application class loader"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置AppClassLoader为线程上下文类加载器</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Returns the class loader used to launch the main application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The class loader used for loading installed extensions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The class loader used for loading from java.class.path.</span></span><br><span class="line"><span class="comment">     * runs in a restricted security context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们不禁会有一个问题，上面你说有3个ClassLoader，为啥这就变成了2个了？BootstrapClassLoader呢？</p><p>在前几行我们看到了一个bootClassPath的String，这个其实就是BootstrapClassLoader加载包的路径，我们单独看一下这个bootClassPath是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"sun.boot.class.path"</span>));</span><br></pre></td></tr></table></figure><p>得到的运行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$JRE_HOME&#x2F;lib&#x2F;resources.jar:</span><br><span class="line">$JRE_HOME&#x2F;lib&#x2F;rt.jar:</span><br><span class="line">$JRE_HOME&#x2F;lib&#x2F;sunrsasign.jar:</span><br><span class="line">$JRE_HOME&#x2F;lib&#x2F;jsse.jar:</span><br><span class="line">$JRE_HOME&#x2F;lib&#x2F;jce.jar:</span><br><span class="line">$JRE_HOME&#x2F;lib&#x2F;charsets.jar:</span><br><span class="line">$JRE_HOME&#x2F;lib&#x2F;jfr.jar:</span><br><span class="line">$JRE_HOME&#x2F;classes</span><br></pre></td></tr></table></figure><p>由此可见，这些都是jre目录下面的jar包和class文件，这其实也是jvm的提供的加载器BootstrapClassLoader加载的文件。</p><h2 id="ExtClassLoader"><a href="#ExtClassLoader" class="headerlink" title="ExtClassLoader"></a>ExtClassLoader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The class loader used for loading installed extensions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ClassLoader.registerAsParallelCapable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create an ExtClassLoader. The ExtClassLoader is created</span></span><br><span class="line"><span class="comment">     * within a context that limits which files it can read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获取ext目录下的所有文件</span></span><br><span class="line">        <span class="keyword">final</span> File[] dirs = getExtDirs();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Prior implementations of this doPrivileged() block supplied</span></span><br><span class="line">            <span class="comment">// aa synthesized ACC via a call to the private method</span></span><br><span class="line">            <span class="comment">// ExtClassLoader.getContext().</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> ExtClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                        <span class="keyword">int</span> len = dirs.length;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                            MetaIndex.registerDirectory(dirs[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> ExtClassLoader(dirs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) e.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line">        String s = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">        File[] dirs;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">            StringTokenizer st =</span><br><span class="line">                <span class="keyword">new</span> StringTokenizer(s, File.pathSeparator);</span><br><span class="line">            <span class="keyword">int</span> count = st.countTokens();</span><br><span class="line">            dirs = <span class="keyword">new</span> File[count];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                dirs[i] = <span class="keyword">new</span> File(st.nextToken());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dirs = <span class="keyword">new</span> File[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dirs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是看一下这个getExtDirs()返回什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_181.jdk&#x2F;Contents&#x2F;Home&#x2F;jre&#x2F;lib&#x2F;ext:</span><br><span class="line">&#x2F;Network&#x2F;Library&#x2F;Java&#x2F;Extensions:&#x2F;System&#x2F;Library&#x2F;Java&#x2F;Extensions:&#x2F;usr&#x2F;lib&#x2F;java</span><br></pre></td></tr></table></figure><h2 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class loader used for loading from java.class.path.</span></span><br><span class="line"><span class="comment"> * runs in a restricted security context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader extcl)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String s = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">        <span class="keyword">final</span> File[] path = (s == <span class="keyword">null</span>) ? <span class="keyword">new</span> File[<span class="number">0</span>] : getClassPath(s);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;AppClassLoader&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                URL[] urls =</span><br><span class="line">                    (s == <span class="keyword">null</span>) ? <span class="keyword">new</span> URL[<span class="number">0</span>] : pathToURLs(path);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> AppClassLoader(urls, extcl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>System.getProperty(&quot;java.class.path&quot;);</code>输出的是当前java工程目录bin，就不贴了，里面存放的是编译生成的class文件。</p><h2 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h2><p>根据上面我们对于源码的分析，其他的ClassLoader主要加载的是本地指定目录下的jar或者class。但如果想动态加载一些诸如：本地其他目录下的class文件，或者网络上下载的class，就需要自定义ClassLoader了。</p><p>步骤：</p><ol><li>编写一个类继承ClassLoader；</li><li>复写它的findClass()方法；</li><li>在findClass()方法中调用defineClass()方法转换为Class对象（这个defineClass是rt.jar提供的）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiskClassLoader</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data;</span><br><span class="line">        <span class="comment">// 读取class文件到byte[] data中</span></span><br><span class="line">        defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>没啥总结的，读读源码一切都很清晰了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾收集与内存分配策略</title>
      <link href="/2019/06/07/jvm-gc/"/>
      <url>/2019/06/07/jvm-gc/</url>
      
        <content type="html"><![CDATA[<p>虽然比较详尽的分析了JVM各个垃圾收集算法的执行过程，以及对于各个垃圾收集器的介绍，但似乎条理并不那么清晰。“只看这一篇”的梗实在炒烂了，但事实上这篇文章还是希望在之前对于Java GC的了解上，更加系统的整理一下，旨在梳理出清晰系统的知识网络。</p><p>之前有整理过JVM GC相关的知识点，包括以下四篇文章：</p><ul><li><a href="https://sagittariusyx.github.io/2017/08/17/jvm-optimization-base-intro/" target="_blank" rel="noopener">JVM调优（一） - 基本概念</a></li><li><a href="https://sagittariusyx.github.io/2017/08/25/jvm-GC-algorithms/" target="_blank" rel="noopener">JVM调优（二） - 基本垃圾回收算法和垃圾收集器</a></li><li><a href="https://sagittariusyx.github.io/2017/08/27/jvm-GC-problems/" target="_blank" rel="noopener">JVM调优（三） - GC面临的问题</a></li><li><a href="https://sagittariusyx.github.io/2017/09/10/jvm-generation-GC/" target="_blank" rel="noopener">JVM调优（四） - 分代GC详解</a></li></ul><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们知道<strong>程序计数器、虚拟机栈、本地方法栈</strong>3个区域随线程而生，随线程而灭；在这几个区域内不需要过多的考虑垃圾回收的问题，因为方法或者线程结束时，内存自然就跟随着回收了。</p><p>而Java<strong>堆和方法区</strong>则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存分配和回收都是动态的，垃圾回收主要关注的是这部分内存。</p><h1 id="对象已死吗？"><a href="#对象已死吗？" class="headerlink" title="对象已死吗？"></a>对象已死吗？</h1><p>在JVM堆中存放着几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象中哪些还“活着”，哪些已经“死去”（即不可能再被任何途径使用的对象）。</p><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>引用计数算法是这样工作的：给对象添加一个<strong>引用计数器</strong>，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>客观的说，引用计数算法（Reference Counting）的实现简单，判定效率也高，在大部分情况下是不错的算法。但是，至少主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是<strong>它很难解决对象之间相互循环引用的问题</strong>。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>在主流的商用程序语言（Java、C#等）的主流实现中，都是通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的基本思路就是通过<strong>一系列</strong>的<strong>称为“GC Roots”的对象作为起始点</strong>，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（也就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p><p>下面图中，对象object 5、object 6、object 7虽然互相有关联，但是它们到GC Roots是不可达的，所以会被判定为是可回收的对象。</p><p><img src="/images/reachability_analysis.png" alt="reachability_analysis"></p><p>在Java中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ul><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h2><p>“标记 - 清除”（Mark-Sweep）算法是最基础的收集算法，算法分为“标记”和“清除”两个阶段：<strong>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</strong>之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。</p><p>它的主要不足有两个：一个是<strong>效率问题</strong>，标记和清除两个过程的效率都不高；另一个是<strong>空间问题</strong>，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记 - 清除算法的执行过程如下图所示。</p><p><img src="/images/gc_mark_sweep.png" alt="gc_mark_sweep"></p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它<strong>将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</strong></p><p>这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是<strong>这种算法的代价是将内存缩小为了原来的一半</strong>，未免太高了一点。复制算法的执行过程如下图所示。</p><p><img src="/images/gc_copying.png" alt="gc_copying"></p><p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性的复制到另外一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性的复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。<strong>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1</strong>，也就是每次新生代中可用内存为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h2><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，<strong>标记过程仍然与“标记-清除”算法一样</strong>，但后续步骤不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</strong>，“标记-整理”算法的示意图如下图所示。</p><p><img src="/images/gc_mark_compact.png" alt="gc_mark_compact"></p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为<strong>新生代</strong>和<strong>老年代</strong>，这样就可以根据各个年代的特点采用最适当的收集算法。</p><p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；</p><p>而老年代因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记 - 清除”或者“标记 - 整理”算法来进行回收。</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户提供自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于JDK1.7 Update 14之后的HotSpot虚拟机（在这个版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），这个虚拟机包含的所有收集器如下图所示。</p><p><img src="/images/garbage_collector.png" alt="garbage_collector"></p><p>上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。下面介绍这些收集器的特性、基本原理和使用场景，并重点分析CMS和G1这两款相对复杂的收集器，了解它们的部分运行细节。</p><p>在介绍这些收集器各自的特性之前，我们先来明确一个观点：虽然我们是在对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最适合的收集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，那HotSpot虚拟机就没必要实现那么多不同的收集器了。</p><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。大家看名字就会知道，这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在<strong>它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束</strong>。“Stop The World”这个名字也许听起来很酷，但这项必须实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常的线程全部停掉，这对很多应用来说都是难以接受的。不妨试想一下，要是你的计算机每运行一个小时就会暂停响应5分钟，你会有什么样的心情？下图示意了Serial/Serial Old收集器的运行过程。</p><p><img src="/images/serial_collector.png" alt="serial_collector"></p><p>从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）乃至GC收集器的最前沿成果Garbage First（G1）收集器，我们看到了一个个越来越优秀（也越来越复杂）的收集器的出现，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除。</p><p>写到这里，似乎已经把Serial收集器描述成一个“老而无用、食之无味弃之可惜”的鸡肋了，但实际上到现在为止，它依然是<strong>虚拟机运行在Client模式下的默认新生代收集器</strong>。它也有着优于其他收集器的地方：<strong>简单而高效</strong>（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。</p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew收集器其实就是<strong>Serial收集器的多线程版本</strong>，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX : SurvivorRatio、 -XX : PretenureSizeThreshold、 -XX : HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。ParNew收集器的工作过程如下图所示。</p><p><img src="/images/parNew_collector.png" alt="parNew_collector"></p><p>ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创建之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS收集器（Concurrent Mark Sweep），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p><p>不幸的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中<strong>使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个</strong>。ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX : UserParNewGC选项来强制指定它。</p><p>注意，从ParNew收集器开始，后面还会接触到几款并发和并行的收集器。在大家可能产生疑惑之前，有必要先解释两个名词：并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下语境中，它们可以解释如下。</p><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</li></ul><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能的缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率的利用CPU时间，尽快完成程序的运行任务，主要适合在后台运算而不需要太多交互的任务。</p><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p><strong>Serial Old收集器是Serial收集器的老年代版本</strong>，它同样是一个单线程收集器，使用“标记 - 整理”算法。这个收集器的<strong>主要意义也是在于给Client模式下的虚拟机使用</strong>。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用。另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。Serial Old收集器的工作工程如下图所示。</p><p><img src="/images/serial_old_collector.png" alt="serial_old_collector"></p><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择（还记得上面说过Parallel Scavenge收集器无法与CMS收集器配合工作吗？）。由于老年代Serial Old收集器在服务器端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。</p><p>直到Parallel Old收集器收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。Parallel Old收集器的工作过程如下图所示。</p><p><img src="/images/parallel_old_collector.png" alt="parallel_old_collector"></p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种<strong>以获取最短回收停顿时间为目标的收集器</strong>。目前很大一部分的Java应用集中在互联网或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p><ol><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ol><blockquote><p>停顿时间：2 &gt; 3 &gt; 1</p></blockquote><p>其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>由于<strong>整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作</strong>。所以，从<strong>总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的</strong>。通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间。</p><p><img src="/images/cms_collector.png" alt="cms_collector"></p><p>CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：<strong>并发收集、低停顿</strong>，Sun公司的一些官方文档中也称之为并发低停顿收集器（Concurrent Low Pause Collector）。但是CMS还远达不到完美的程度，它有以下3个明显的缺点：</p><ul><li>CMS收集器<strong>对CPU资源非常敏感</strong>。<ul><li>其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（譬如2个）时，CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还分出一半的运算发能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。</li></ul></li><li>CMS收集器<strong>无法处理浮动垃圾</strong>（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次FUll GC的产生。<ul><li>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运行使用。在JDK 1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高-XX : CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在JDK 1.6中，CMS收集器的启动阈值已经提升至92%。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX : CM SInitiatingOccupancyFraction设置得太高很容易导致大量“Concurrent Mode Failure”失败，性能反而降低。</li></ul></li><li>CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有<strong>大量空间碎片产生</strong>。<ul><li>空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余。但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX : +UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX : CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC 时都进行碎片整理）。</li></ul></li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使用是（在比较长期的）未来可以替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p><ul><li><strong>并行与并发</strong>：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li><li><strong>分代收集</strong>：与其他收集器一样，分代概念在G1中依然得以保留。虽然<strong>G1可以不需要其他收集器配合就能独立管理整个GC堆</strong>，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获得更好的收集效果。</li><li><strong>空间整合</strong>：与CMS的“标记-清理”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作其间<strong>不会产生内存空间碎片</strong>，收集后能提供规整的可用内存。这种特性<strong>有利于程序长时间运行</strong>，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li><li><strong>可预测的停顿</strong>：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还<strong>能建立可预测的停顿时间模型</strong>，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li></ul><p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但<strong>新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合</strong>。</p><p>在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中<strong>每个Region都有一个与之对应的Remembered Set</strong>，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p><p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p><ol><li>初始标记（Initial Marking）</li><li>并发标记（Concurrent Marking）</li><li>最终标记（Final Marking）</li><li>筛选回收（Live Data Counting and Evacuation）</li></ol><p>对CMS收集器运作过程熟悉的话，一定已经发现G1的前几个步骤的运作过程和CMS有很多相似之处。初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，从Sun公司透露出来的信息来看，这个阶段其实也可以做到<strong>与用户程序一起并发执行</strong>，但是因为<strong>只回收一部分Region</strong>，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。通过下图可以比较清楚的看到G1收集器的运作步骤中并发和需要停顿的阶段。</p><p><img src="/images/G1_collector.png" alt="G1_collector"></p><p>总之，如果你现在采用的收集器没有出现问题，那就没有任何理由现在去选择G1，如果你的应用追求低停顿，那G1现在已经可以作为一个可尝试的选择，如果你的应用追求吞吐量，那G1并不会为你带来什么特别的好处。</p><h1 id="内存分配回收策略"><a href="#内存分配回收策略" class="headerlink" title="内存分配回收策略"></a>内存分配回收策略</h1><p>对象的内存分配，往大方向讲，就是在堆上分配，对象主要分配在新生代的Eden区上，少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p><h2 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h2><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><blockquote><p>多次提到的Minor GC和Full GC有什么不一样吗？</p></blockquote><blockquote><ul><li>新生代GC（Minor GC）：指<strong>发生在新生代的垃圾收集动作</strong>，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li><li>老年代GC（Major GC/Full GC）：指<strong>发生在老年代的GC</strong>，出现了Major GC，<strong>经常会伴随至少一次的Minor GC</strong>（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li></ul></blockquote><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（byte[]数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p><h2 id="长期存活对象进入老年代"><a href="#长期存活对象进入老年代" class="headerlink" title="长期存活对象进入老年代"></a>长期存活对象进入老年代</h2><p>虚拟机给每个对象定义了一个<strong>对象年龄（Age）计数器</strong>。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中<strong>每“熬过”一次Minor GC，年龄就增加1岁</strong>，当它的年龄<strong>增加到一定程度（默认为15岁），就将会被晋升到老年代中</strong>。对象晋升老年代的年龄阈值，可以通过参数-XX : MaxTenuringThreshold设置。</p><h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>为了能更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄达到了MaxTenuringThreshold才能晋升老年代，<strong>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</strong>，无须等到MaxTenuringThreshold中要求的年龄。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，关于JVM的垃圾回收部分系统性的总结完。Java GC是很微妙并且有趣的原理，在理解各个算法及收集器工作原理的基础上，还要根据系统的实际情况来做trade-off，并不是某个GC算法是最好的算法，也并不存在一个垃圾回收器适用于所有系统。</p><p>学以致用，落实实践才是根本。</p><p>参考《深入理解Java虚拟机》，建议每位同学都好好阅读几遍。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
          <category> GC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统读写模型中的Quorum机制</title>
      <link href="/2018/08/13/DS-quorum-rw/"/>
      <url>/2018/08/13/DS-quorum-rw/</url>
      
        <content type="html"><![CDATA[<p>分布式系统的设计中会涉及到许多的协议、机制用来解决可靠性问题、数据一致性问题等，Quorum 机制就是其中的一种。我们通过分布式系统中的读写模型来简单介绍它。</p><h1 id="分布式系统中的读写模型"><a href="#分布式系统中的读写模型" class="headerlink" title="分布式系统中的读写模型"></a>分布式系统中的读写模型</h1><p>分布式系统是由多个节点（指代一台服务器、存储设备等）构成，由于网络异常、宕机等节点并不能保证正常工作，特别是在节点数量很大的时候，出现异常状况的节点几乎是肯定的。为了保证系统的正常运行，能够提供可靠的服务，分布式系统中对于数据的存储采用多份数据副本（注：这里的副本并非只用来备份，它可参与提供系统服务）来保证可靠性，也就是其中一个节点上读取数据失败了那么可以转向另外一个存有相同数据副本的节点读取返回给用户。这个过程对于用户来说是透明的。那么随之而来的就会带来数据的副本数据的不一致性，例如：用户提交一次修改后，那么原先保存的副本显然就与当前数据不一致了。解决这个问题最简单的方法Read Only Write All，就是在用户提交修改操作后，系统确保存储的数据所有的副本全部完成更新后，再告诉用户操作成功；而读取数据的时候只需要查询其中的一个副本数据返回给用户就行了。在很少对存储的数据进行修改的情形下（例如存档历史数据供以后分析），这种解决方案很好。如遇到经常需要修改的情形，写操作时延时现象就很明显，加上并发或者连续的执行的话效率就可想而知了。实质上，这是由于Write和Read负载不均衡所致，Read很轻松，Write深表压力！</p><p>那么有没有一种方案能够不需要更新完全部的数据，但又保证返回给用户的是有效数据的解决方案呢？<strong>Quorum机制</strong>便是一种选择。</p><h1 id="从小学的抽屉原理说起"><a href="#从小学的抽屉原理说起" class="headerlink" title="从小学的抽屉原理说起"></a>从小学的抽屉原理说起</h1><p>为什么从抽屉原理说起？一来大家对这个比较熟悉，二来它与Quorum机制有异曲同工的地方。回顾抽屉原理，2个抽屉每个抽屉最多容纳2个苹果，现在有3个苹果无论怎么放，其中的一个抽屉里面会有2个苹果。那么我们把抽屉原理变变型，2个抽屉一个放了2个红苹果，另一个放了2个青苹果，我们取出3个苹果，无论怎么取至少有1个是红苹果，这个理解起来也很简单。我们把红苹果看成更新了的有效数据，青苹果看成未更新的无效数据。便可以看出来，不需要更新全部数据（并非全部是红苹果）我们就可以得到有效数据，当然我们需要读取多个副本完成（取出多个苹果）。这就是Quorum机制的原型，其实质是将Write All的负载均衡到Read Only上。</p><h1 id="Quorum机制"><a href="#Quorum机制" class="headerlink" title="Quorum机制"></a>Quorum机制</h1><p>苹果抽屉理论只是对它的理解，Quorum的定义：</p><p><img src="/images/quorum.png" alt="quorum"></p><p>简单概括说来就是， Quorum 是一种集合 , l中任意取集合S,R ，S,R 都存在交集。当然，本文并不打算多讲它的数学定义方面的理解，这里只是提供个信息，看不懂也没事联系到前面的分布式读写模型就能很容易理解这个了。</p><p>回到文章的开头，我们来看看是怎么运用Quorum机制来解决读写模型中读写的负载均衡。其实，关键的是更新多少个数据副本后，使得读取时总能读到有效数据？回想我们的的红苹果，假设总共有N个数据副本，其中k个已经更新，N-k个未更新的，那么我们任意读取N-k+1个数据的时候就必定至少有1个是属于更新了的k个里面的，也就是Quorum的交集，我们只需比较读取的N-k+1中版本最高的那个数据返回给用户就可以得到最新更新的数据了。</p><p>那么对于写模型呢？我也只需要完成k个副本的更新后，就可以告诉用户操作完成而不需要Write All了，当然告诉完用户完成操作后，系统内部还是会慢慢的把剩余的副本更新，这对于用户是透明的。可以看到，我们把Write身上的部分负载转移到了Read上，Read读取多个副本，使得Write不会过于劳累，不好的是弱化了分布式系统中的数据一致性。至于转移多少负载比较合适，这个需要根据分布式系统的具体需求中对数据一致性的要求。不过，CAP理论告诉我们没有完美的方案。</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式及写法</title>
      <link href="/2018/08/13/singleton-pattern/"/>
      <url>/2018/08/13/singleton-pattern/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍<strong>单例设计模式</strong>。包括单例的概念、用途、实现方式、如何防止被序列化破坏等。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式。保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>单例模式一般体现在类声明中，单例的类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>单例模式有以下两个优点：</p><ul><li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如网站首页页面缓存）；</li><li>避免对资源的多重占用（比如写文件操作）。</li></ul><p>有时候，我们在选择使用单例模式的时候，不仅仅考虑到其带来的优点，还有可能是有些场景就必须要单例。</p><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>我们知道，一个类的对象的产生是由类构造函数来完成的。如果一个类对外提供了public的构造方法，那么外界就可以任意创建该类的对象。所以，如果想限制对象的产生，一个办法就是<strong>将构造函数变为私有的(至少是受保护的)</strong>，使外面的类不能通过引用来产生对象。同时为了保证类的可用性，就必须提供一个自己的对象以及访问这个对象的静态方法。</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>下面是一个简单的单例的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在类内部实例化一个实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//私有的构造函数,外部无法访问</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供获取实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是一个简单的单例的实现，这种实现方式我们称之为<strong>饿汉式</strong>。所谓饿汉。这是个比较形象的比喻。对于一个饿汉来说，他希望他想要用到这个实例的时候就能够立即拿到，而不需要任何等待时间。所以，通过static的静态初始化方式，在该类第一次被加载的时候，就有一个Singleton的实例被创建出来了。这样就保证在第一次想要使用该对象时，它已经被初始化好了。</p><p>同时，由于该实例在类被加载的时候就创建出来了，所以也避免了线程安全问题。</p><p>还有一种饿汉式的变种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在类内部定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//实例化该实例</span></span><br><span class="line">        instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有的构造函数,外部无法访问</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供获取实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实是一样的，都是在类被加载的时候实例化一个对象。</p><p>饿汉式单例，在类被加载的时候对象就会实例化。这也许会<strong>造成不必要的消耗</strong>，因为有可能这个实例根本就不会被用到。而且，如果这个类被多次加载的话也会造成多次实例化。其实解决这个问题的方式有很多，下面提供两种解决方式，第一种是使用静态内部类的形式。第二种是使用懒汉式。</p><h2 id="静态内部类式"><a href="#静态内部类式" class="headerlink" title="静态内部类式"></a>静态内部类式</h2><p>先来看通过静态内部类的方式解决上面的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在静态内部类中初始化实例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClassSingleton INSTANCE = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供获取实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟饿汉式不同的是（很细微的差别）：饿汉式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而<strong>这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance</strong>。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比饿汉式更加合理。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>下面看另外一种在该对象真正被使用的时候才会实例化的单例模式——懒汉式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//对外提供获取实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在对象被使用的时候才实例化</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种单例叫做懒汉式单例。懒汉，就是不会提前把实例创建出来，将类对自己的实例化延迟到第一次被引用的时候。getInstance方法的作用是希望该对象在第一次被使用的时候被new出来。</p><p>有没有发现，其实这种懒汉式单例其实还存在一个问题，那就是<strong>线程安全问题</strong>。在多线程情况下，有可能两个线程同时进入if语句中，这样，在两个线程都从if中退出的时候就创建了两个不一样的对象。</p><h2 id="线程安全的懒汉式"><a href="#线程安全的懒汉式" class="headerlink" title="线程安全的懒汉式"></a>线程安全的懒汉式</h2><p>针对线程不安全的懒汉式的单例，其实解决方式很简单，就是给创建对象的步骤加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedSingleton instance;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SynchronizedSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//对外提供获取实例的静态方法,对该方法加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SynchronizedSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在对象被使用的时候才实例化</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SynchronizedSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法能够在多线程中很好的工作，而且看起来它也具备很好的延迟加载，但是，遗憾的是，它<strong>效率很低</strong>，因为99%情况下不需要同步。（因为上面的synchronized的加锁范围是整个方法，该方法的所有操作都是同步进行的，但是对于<strong>非第一次创建对象的情况，也就是没有进入if语句中的情况，根本不需要同步操作</strong>，可以直接返回instance。）</p><h2 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h2><p>针对上面code存在的问题，相信对并发编程了解的同学都知道如何解决。其实上面的代码存在的问题主要是锁的范围太大了。只要<strong>缩小锁的范围</strong>就可以了。那么如何缩小锁的范围呢？相比于同步方法，同步代码块的加锁范围更小。可以改造成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面code是一种改进写法，通过使用同步代码块的方式减小了锁的范围。这样可以大大提高效率。（对于已经存在singleton的情况，无须同步，直接return）。</p><p>但是，事情真的有这么容易吗？上面的代码看上去好像是没有任何问题。实现了惰性初始化，解决了同步问题，还减小了锁的范围，提高了效率。但是，该代码还存在隐患。隐患的原因主要和Java内存模型（JMM）有关。考虑下面的事件序列：</p><ul><li>线程A发现变量没有被初始化, 然后它获取锁并开始变量的初始化。</li><li>由于某些编程语言的语义，编译器生成的代码允许在线程A执行完变量的初始化之前，更新变量并将其指向部分初始化的对象。</li><li>线程B发现共享变量已经被初始化，并返回变量。由于线程B确信变量已被初始化，它没有获取锁。如果在A完成初始化之前共享变量对B可见（这是由于A没有完成初始化或者因为一些初始化的值还没有穿过B使用的内存(缓存一致性)），程序很可能会崩溃。</li></ul><p>在J2SE 1.4或更早的版本中使用双重检查锁有潜在的危险，有时会正常工作（区分正确实现和有小问题的实现是很困难的。取决于编译器，线程的调度和其他并发系统活动，不正确的实现双重检查锁导致的异常结果可能会间歇性出现。重现异常是十分困难的。） 在J2SE 5.0中，这一问题被修正了。volatile关键字保证多个线程可以正确处理单个实例。</p><h2 id="使用volatile"><a href="#使用volatile" class="headerlink" title="使用volatile"></a>使用volatile</h2><p>所以，使用volatile的方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> VolatileSingleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">VolatileSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> VolatileSingleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (VolatileSingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> VolatileSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种双重校验锁的方式用的比较广泛，它解决了前面提到的所有问题。但是，即使是这种看上去完美无缺的方式也可能存在问题，那就是遇到序列化的时候。详细内容后文介绍。</p><h2 id="使用final"><a href="#使用final" class="headerlink" title="使用final"></a>使用final</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalWrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalWrapper</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FinalWrapper&lt;FinalSingleton&gt; helperWrapper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FinalSingleton <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FinalWrapper&lt;FinalSingleton&gt; wrapper = helperWrapper;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (helperWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    helperWrapper = <span class="keyword">new</span> FinalWrapper&lt;FinalSingleton&gt;(<span class="keyword">new</span> FinalSingleton());</span><br><span class="line">                &#125;</span><br><span class="line">                wrapper = helperWrapper;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wrapper.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举式"><a href="#枚举式" class="headerlink" title="枚举式"></a>枚举式</h2><p>在1.5之前，实现单例一般只有以上几种办法，在1.5之后，还有另外一种实现单例的方式，那就是使用枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象（下面会介绍），可谓是很坚强的壁垒啊。不过，在实际工作中，我也很少看见有人这么写过，但是不代表它不好。</p><h1 id="单例和序列化"><a href="#单例和序列化" class="headerlink" title="单例和序列化"></a>单例和序列化</h1><p>在《<a href="http://www.hollischuang.com/archives/1144" target="_blank" rel="noopener">单例与序列化的那些事儿</a>》一文中就分析过单例和序列化之前的关系——序列化可以破坏单例。</p><p>为什么序列化可以破坏单例了？答：序列化会<strong>通过反射调用无参数的构造方法</strong>创建一个新的对象。</p><p>要想防止序列化对单例的破坏，只要在Singleton类中定义readResolve就可以解决该问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文中介绍了几种实现单例的方法，主要包括饿汉、懒汉、使用静态内部类、双重校验锁、枚举等。还介绍了如何防止序列化破坏类的单例性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java IO和NIO</title>
      <link href="/2018/08/08/java-io-nio/"/>
      <url>/2018/08/08/java-io-nio/</url>
      
        <content type="html"><![CDATA[<p>帮助理解Java IO分类，及Java NIO主要模块和工作机制。</p><h1 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h1><p>Java IO是传统的Java处理IO的包的方式，但其中前前后后牵扯到几十个类。如果对它们不做分类总结，是很难掌握这一块内容的，很容易脑子一团浆糊，看过就忘。总体来说，这是一块很硬的骨头。</p><p>我们在此找出Java IO的共性，给它们分分类。本文会有些许表达和概念并非那么严谨，旨在帮助理解和记忆。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们先来看一张网上流传的关于Java IO包的类结构图：</p><p><img src="/images/java_io_no.png" alt="java_io_no"></p><p>不知道多少人看到这幅图心里暗自一句woc，继而内心崩溃。有些人不怕枯燥和艰难，硬着头皮看源码，但是坚持看下去全部看完的有几个呢？就算源码看完看懂，过一周后依然有清晰记忆的又有几个呢？</p><p>上面的图虽然有分类，但是还不够细，而且没有总结出方便记忆的规律，所以我们要重新整理和归类。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="按操作方式（类结构）"><a href="#按操作方式（类结构）" class="headerlink" title="按操作方式（类结构）"></a>按操作方式（类结构）</h3><p>字节流和字符流：</p><ul><li>字节流：以字节为单位，每次读入或读出是<strong>8位数据</strong>。<strong>可以读任何类型数据</strong>。</li><li>字符流：以字符为单位，每次读入或读出是<strong>16位数据</strong>。其<strong>只能读取字符类型数据</strong>。</li></ul><p>输出流和输入流：</p><ul><li>输出流：从内存读出到文件。只能进行写操作。</li><li>输入流：从文件读入到内存。只能进行读操作。</li></ul><p><strong>注意</strong>：这里的出和入，都是相对于系统内存而言的。</p><p>节点流和处理流：</p><ul><li>节点流：直接与数据源相连，读入或读出。</li><li>处理流：与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。</li></ul><p>为什么要有处理流？直接使用节点流，读写不方便，为了更快的读写文件，才有了处理流。</p><p><strong>按操作方式分类结构图：</strong></p><p>根据以上分类，以及jdk的说明，我们可以画出更详细的类结构图：</p><p><img src="/images/io_op_way.png" alt="io_op_way"></p><p>分类说明：</p><p><strong>1）输入字节流InputStream</strong>：</p><ul><li><strong>ByteArrayInputStream</strong>、<strong>StringBufferInputStream</strong>、<strong>FileInputStream</strong> 是三种基本的介质流，它们分别从Byte数组、StringBuffer、和本地文件中读取数据。</li><li><strong>PipedInputStream</strong> 是从与其它线程共用的管道中读取数据。PipedInputStream的一个实例要和PipedOutputStream的一个实例共同使用，共同完成管道的读取写入操作。主要用于线程操作。</li><li><strong>DataInputStream</strong> 将基础数据类型读取出来。</li><li><strong>ObjectInputStream</strong> 和所有 <strong>FilterInputStream</strong> 的子类都是装饰流（装饰器模式的主角）。</li></ul><p><strong>2）输出字节流OutputStream</strong>：</p><ul><li><strong>ByteArrayOutputStream</strong>、<strong>FileOutputStream</strong> 是两种基本的介质流，它们分别向Byte数组和本地文件中写入数据。</li><li><strong>PipedOutputStream</strong> 是向与其它线程共用的管道中写入数据。</li><li><strong>DataOutputStream</strong> 将基础数据类型写入到文件中。</li><li><strong>ObjectOutputStream</strong> 和所有 <strong>FilterOutputStream</strong> 的子类都是装饰流。</li></ul><p><strong>字节流的输入和输出类结构图：</strong></p><p><img src="/images/stream_io.png" alt="stream_io"></p><p><strong>3）字符输入流Reader</strong>：</p><ul><li><strong>FileReader</strong>、<strong>CharReader</strong>、<strong>StringReader</strong> 是三种基本的介质流，它们分在本地文件、Char数组、String中读取数据。</li><li><strong>PipedReader</strong> 是从与其它线程共用的管道中读取数据。</li><li><strong>BufferedReader</strong> 加缓冲功能，避免频繁读写硬盘。</li><li><strong>InputStreamReader</strong> 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。</li></ul><p><strong>4）字符输出流Writer</strong>：</p><ul><li><strong>StringWriter</strong> 向String中写入数据。</li><li><strong>CharArrayWriter</strong> 实现一个可用作字符输入流的字符缓冲区。</li><li><strong>PipedWriter</strong> 是向与其它线程共用的管道中写入数据。</li><li><strong>BufferedWriter</strong> 增加缓冲功能，避免频繁读写硬盘。</li><li><strong>PrintWriter</strong>、<strong>PrintStream</strong> 将对象的格式表示打印到文本输出流。极其类似，功能和使用也非常相似。</li><li><strong>OutputStreamWriter</strong> 是OutputStream到Writer转换的桥梁，它的子类FileWriter其实就是一个实现此功能的具体类。功能和使用和OutputStream极其类似，后面会有它们的对应图。</li></ul><p><strong>字符流的输入和输出类结构图：</strong></p><p><img src="/images/char_stream_io.png" alt="char_stream_io"></p><h3 id="按操作对象"><a href="#按操作对象" class="headerlink" title="按操作对象"></a>按操作对象</h3><p><strong>按操作对象分类结构图：</strong></p><p><img src="/images/io_op_object.png" alt="io_op_object"></p><p>分类说明：</p><p><strong>1）对文件进行操作（节点流）</strong>：</p><ul><li>FileInputStream（字节输入流）</li><li>FileOutputStream（字节输出流）</li><li>FileReader（字符输入流）</li><li>FileWriter（字符输出流）</li></ul><p><strong>2）对管道进行操作（节点流）</strong>：</p><ul><li>PipedInputStream（字节输入流）</li><li>PipedOutputStream（字节输出流）</li><li>PipedReader（字符输入流）</li><li>PipedWriter（字符输出流）</li></ul><p>PipedInputStream的一个实例要和PipedOutputStream的一个实例共同使用，共同完成管道的读取写入操作。<strong>主要用于线程操作</strong>。</p><p><strong>3）字节/字符数组流（节点流）</strong>：</p><ul><li>ByteArrayInputStream</li><li>ByteArrayOutputStream</li><li>CharArrayReader</li><li>CharArrayWriter</li></ul><p>除了上述三种是节点流，其他都是处理流，需要跟节点流配合使用。</p><p><strong>1）Buffered缓冲流（处理流）</strong>：</p><p>带缓冲区的处理流，缓冲区的作用的主要目的是：避免每次和硬盘打交道，提高数据访问的效率。</p><ul><li>BufferedInputStream</li><li>BufferedOutputStream</li><li>BufferedReader</li><li>BufferedWriter</li></ul><p><strong>2）转化流（处理流）</strong>：</p><ul><li>InputStreamReader：把字节转化成字符；</li><li>OutputStreamWriter：把字节转化成字符。</li></ul><p><strong>3）基本类型数据流（处理流）</strong>：</p><p>用于操作基本数据类型值。因为平时若是我们输出一个8个字节的long类型或4个字节的float类型，那怎么办呢？可以一个字节一个字节输出，也可以把转换成字符串输出，但是这样转换费时间，若是直接输出该多好啊，因此这个数据流就解决了我们输出数据类型的困难。数据流可以直接输出float类型或long类型，提高了数据读写的效率。</p><ul><li>DataInputStream</li><li>DataOutputStream</li></ul><p><strong>4）打印流（处理流）</strong>：</p><p>一般是打印到控制台，可以进行控制打印的地方。</p><ul><li>PrintStream</li><li>PrintWriter</li></ul><p><strong>5）对象流（处理流）</strong>：</p><p>把封装的对象直接输出，而不是一个个在转换成字符串再输出。</p><ul><li>ObjectInputStream 对象反序列化</li><li>ObjectOutputStream 对象序列化</li></ul><p><strong>6）合并流（处理流）</strong>：</p><ul><li>SequenceInputStream 可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。</li></ul><h2 id="其他类：RandomAccessFile"><a href="#其他类：RandomAccessFile" class="headerlink" title="其他类：RandomAccessFile"></a>其他类：RandomAccessFile</h2><p>该对象并不是流体系中的一员，其封装了字节流，同时还封装了一个缓冲区（字符数组），通过内部的指针来操作字符数组中的数据。 该对象特点：</p><ol><li>该对象只能操作文件，所以构造函数接收两种类型的参数：a.字符串文件路径；b.File对象。</li><li>该对象既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(r,rw)。</li></ol><h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><h2 id="NIO简介"><a href="#NIO简介" class="headerlink" title="NIO简介"></a>NIO简介</h2><p>Java NIO是java 1.4之后新出的一套IO接口，这里的的新是相对于原有标准的Java IO和Java Networking接口。NIO提供了一种完全不同的操作方式。</p><p><strong>NIO中的N可以理解为Non-blocking，不单纯是New。</strong></p><p><strong>它支持面向缓冲的，基于通道的I/O操作方法。</strong> 随着JDK 7的推出，NIO系统得到了扩展，为文件系统功能和文件处理提供了增强的支持。 由于NIO文件类支持的这些新的功能，NIO被广泛应用于文件处理。</p><h2 id="NIO和IO的区别"><a href="#NIO和IO的区别" class="headerlink" title="NIO和IO的区别"></a>NIO和IO的区别</h2><p><strong>1. Channels and Buffers（通道和缓冲区）</strong></p><p><strong>IO是面向流的，NIO是面向缓冲区的</strong></p><ul><li>标准的IO编程接口是面向字节流和字符流的。而NIO是面向通道和缓冲区的，数据总是从通道中读到buffer缓冲区内，或者从buffer缓冲区写入到通道中；（NIO中的所有I/O操作都是通过一个通道开始的。）</li><li>Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方；</li><li>Java NIO是面向缓存的I/O方法。将数据读入缓冲器，使用通道进一步处理数据。在NIO中，使用通道和缓冲区来处理I/O操作。</li></ul><p><strong>2. Non-blocking IO（非阻塞IO）</strong></p><p><strong>IO流是阻塞的，NIO流是不阻塞的。</strong></p><ul><li>Java NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</li><li>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</li></ul><p><strong>3. Selectors（选择器）</strong></p><p><strong>NIO有选择器，而IO没有。</strong></p><ul><li>选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。</li><li>线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。</li></ul><h2 id="读写数据方式"><a href="#读写数据方式" class="headerlink" title="读写数据方式"></a>读写数据方式</h2><p>通常来说NIO中的所有IO都是从 Channel（通道） 开始的。</p><ul><li><strong>从通道进行数据读取：</strong>创建一个缓冲区，然后请求通道读取数据。</li><li><strong>从通道进行数据写入：</strong>创建一个缓冲区，填充数据，并要求通道写入数据。</li></ul><p>数据读取和写入操作图示：</p><p><img src="/images/nio_read_write_data.png" alt="nio_read_write_data"></p><h2 id="NIO核心组件"><a href="#NIO核心组件" class="headerlink" title="NIO核心组件"></a>NIO核心组件</h2><p>NIO包含下面几个核心的组件：</p><ul><li><strong>Channels</strong></li><li><strong>Buffers</strong></li><li><strong>Selectors</strong></li></ul><p>整个NIO体系包含的类远远不止这三个，只能说这三个是NIO体系的核心。</p><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p><strong>Java NIO Buffers用于和NIO Channel交互。我们从Channel中读取数据到buffers里，从Buffer把数据写入到Channels。</strong></p><p><strong>Buffer本质上就是一块内存区</strong>，可以用来写入数据，并在稍后读取出来。这块内存被NIO Buffer包裹起来，对外提供一系列的读写方便开发的接口。</p><p>在Java NIO中使用的核心缓冲区如下（覆盖了通过I/O发送的基本数据类型：byte, char、short, int, long, float, double ，long）：</p><ul><li><strong>ByteBuffer</strong></li><li><strong>CharBuffer</strong></li><li><strong>ShortBuffer</strong></li><li><strong>IntBuffer</strong></li><li><strong>FloatBuffer</strong></li><li><strong>DoubleBuffer</strong></li><li><strong>LongBuffer</strong></li></ul><p><img src="/images/buffer_structure.png" alt="buffer_structure"></p><p><strong>利用Buffer读写数据，通常遵循四个步骤：</strong></p><ol><li>把数据写入buffer；</li><li>调用flip；</li><li>从Buffer中读取数据；</li><li>调用buffer.clear()或者buffer.compact()。</li></ol><p>当写入数据到buffer中时，buffer会记录已经写入的数据大小。当需要读数据时，通过<strong>flip()方法把buffer从写模式调整为读模式</strong>；在读模式下，可以读取所有已经写入的数据。</p><p>当读取完数据后，需要清空buffer，以满足后续写入操作。清空buffer有两种方式：调用<strong>clear()</strong>或<strong>compact()</strong>方法。<strong>clear会清空整个buffer，compact则只清空已读取的数据</strong>，未被读取的数据会被移动到buffer的开始位置，写入位置则近跟着未读数据之后。</p><h3 id="Buffer的容量，位置，上限"><a href="#Buffer的容量，位置，上限" class="headerlink" title="Buffer的容量，位置，上限"></a>Buffer的容量，位置，上限</h3><p><strong>Buffer缓冲区实质上就是一块内存</strong>，用于写入数据，也供后续再次读取数据。这块内存被NIO Buffer管理，并提供一系列的方法用于更简单的操作这块内存。</p><p>一个Buffer有三个属性是必须掌握的，分别是：</p><ul><li>capacity容量</li><li>position位置</li><li>limit限制</li></ul><p>position和limit的具体含义取决于当前buffer的模式。capacity在两种模式下都表示容量。</p><p>读写模式下position和limit的含义：</p><p><img src="/images/buffer_read_write_mode.png" alt="buffer_read_write_mode"></p><h4 id="容量（Capacity）"><a href="#容量（Capacity）" class="headerlink" title="容量（Capacity）"></a>容量（Capacity）</h4><p>作为一块内存，buffer有一个固定的大小，叫做capacit（容量）。也就是最多只能写入容量值得字节，整形等数据。一旦buffer写满了就需要清空已读数据以便下次继续写入新的数据。</p><h4 id="位置（Position）"><a href="#位置（Position）" class="headerlink" title="位置（Position）"></a>位置（Position）</h4><p><strong>当写入数据到Buffer的时候需要从一个确定的位置开始</strong>，默认初始化时这个位置position为0，一旦写入了数据比如一个字节，整形数据，那么position的值就会指向数据之后的一个单元，position最大可以到capacity-1.</p><p><strong>当从Buffer读取数据时，也需要从一个确定的位置开始。buffer从写入模式变为读取模式时，position会归零，每次读取后，position向后移动。</strong></p><h4 id="上限（Limit）"><a href="#上限（Limit）" class="headerlink" title="上限（Limit）"></a>上限（Limit）</h4><p>在写模式，limit的含义是我们所能写入的最大数据量，它等同于buffer的容量。</p><p>一旦切换到读模式，limit则代表我们所能读取的最大数据量，他的值等同于写模式下position的位置。换句话说，您可以读取与写入数量相同的字节数（限制设置为写入的字节数，由位置标记）。</p><h3 id="Buffer常见方法"><a href="#Buffer常见方法" class="headerlink" title="Buffer常见方法"></a>Buffer常见方法</h3><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>abstract Object array()</td><td>返回支持此缓冲区的数组 （可选操作）</td></tr><tr><td>abstract int arrayOffset()</td><td>返回该缓冲区的缓冲区的第一个元素的在数组中的偏移量 （可选操作）</td></tr><tr><td>int capacity()</td><td>返回此缓冲区的容量</td></tr><tr><td>Buffer clear()</td><td>清除此缓存区。将position = 0;limit = capacity;mark = -1;</td></tr><tr><td>Buffer flip()</td><td>flip()方法可以把Buffer从写模式切换到读模式。调用flip方法会把position归零，并设置limit为之前的position的值。 也就是说，现在position代表的是读取位置，limit标示的是已写入的数据位置。</td></tr><tr><td>abstract boolean hasArray()</td><td>告诉这个缓冲区是否由可访问的数组支持</td></tr><tr><td>boolean hasRemaining()</td><td>return position &lt; limit，返回是否还有未读内容</td></tr><tr><td>abstract boolean isDirect()</td><td>判断个缓冲区是否为 direct</td></tr><tr><td>abstract boolean isReadOnly()</td><td>判断告知这个缓冲区是否是只读的</td></tr><tr><td>int limit()</td><td>返回此缓冲区的限制</td></tr><tr><td>Buffer position(int newPosition)</td><td>设置这个缓冲区的位置</td></tr><tr><td>int remaining()</td><td>return limit - position; 返回limit和position之间相对位置差</td></tr><tr><td>Buffer rewind()</td><td>把position设为0，mark设为-1，不改变limit的值</td></tr><tr><td>Buffer mark()</td><td>将此缓冲区的标记设置在其位置</td></tr></tbody></table><h3 id="Buffer的使用方式"><a href="#Buffer的使用方式" class="headerlink" title="Buffer的使用方式"></a>Buffer的使用方式</h3><h4 id="分配缓冲区（Allocating-a-Buffer）"><a href="#分配缓冲区（Allocating-a-Buffer）" class="headerlink" title="分配缓冲区（Allocating a Buffer）"></a>分配缓冲区（Allocating a Buffer）</h4><p>为了获得缓冲区对象，我们必须首先分配一个缓冲区。在每个Buffer类中，allocate()方法用于分配缓冲区。</p><p>下面来看看ByteBuffer分配容量为28字节的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">28</span>);</span><br></pre></td></tr></table></figure><p>下面来看看另一个示例：CharBuffer分配空间大小为2048个字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer buf = CharBuffer.allocate(<span class="number">2048</span>);</span><br></pre></td></tr></table></figure><h4 id="写入数据到缓冲区（Writing-Data-to-a-Buffer）"><a href="#写入数据到缓冲区（Writing-Data-to-a-Buffer）" class="headerlink" title="写入数据到缓冲区（Writing Data to a Buffer）"></a>写入数据到缓冲区（Writing Data to a Buffer）</h4><p>写数据到Buffer有两种方法：</p><ul><li>从Channel中写数据到Buffer</li><li>手动写数据到Buffer，调用put方法</li></ul><p>下面是一个实例，演示从Channel写数据到Buffer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">// read into buffer.</span></span><br></pre></td></tr></table></figure><p>通过put写数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(<span class="number">127</span>);</span><br></pre></td></tr></table></figure><p>put方法有很多不同版本，对应不同的写数据方法。例如把数据写到特定的位置，或者把一个字节数据写入buffer。</p><h4 id="翻转（flip-）"><a href="#翻转（flip-）" class="headerlink" title="翻转（flip()）"></a>翻转（flip()）</h4><p>flip()方法可以把Buffer从写模式切换到读模式。调用flip方法会把position归零，并设置limit为之前的position的值。 也就是说，现在position代表的是读取位置，limit标示的是已写入的数据位置。</p><h4 id="从Buffer读取数据（Reading-Data-from-a-Buffer）"><a href="#从Buffer读取数据（Reading-Data-from-a-Buffer）" class="headerlink" title="从Buffer读取数据（Reading Data from a Buffer）"></a>从Buffer读取数据（Reading Data from a Buffer）</h4><p>从Buffer读数据也有两种方式。</p><ul><li>从buffer读数据到channel</li><li>从buffer直接读取数据，调用get方法</li></ul><p>读取数据到channel的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> byteWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure><p>调用get读取数据的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> aByte = buf.get();</span><br></pre></td></tr></table></figure><p>get也有诸多版本，对应了不同的读取方式。</p><h4 id="rewind"><a href="#rewind" class="headerlink" title="rewind()"></a>rewind()</h4><p>Buffer.rewind()方法将position置为0，这样我们可以重复读取buffer中的数据。limit保持不变。</p><h4 id="clear-and-compact"><a href="#clear-and-compact" class="headerlink" title="clear() and compact()"></a>clear() and compact()</h4><p>一旦我们从buffer中读取完数据，需要复用buffer为下次写数据做准备。只需要调用clear()或compact()方法。</p><p>如果调用的是clear()方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</p><p>如果Buffer还有一些数据没有读取完，调用clear就会导致这部分数据被“遗忘”，因为我们没有标记这部分数据未读。</p><p>针对这种情况，如果需要保留未读数据，那么可以使用compact。 因此<strong>compact()和clear()的区别就在于: 对未读数据的处理，是保留这部分数据还是一起清空。</strong></p><h4 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h4><p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();</span><br><span class="line"><span class="comment">//call buffer.get() a couple of times, e.g. during parsing.</span></span><br><span class="line">buffer.reset(); <span class="comment">//set position back to mark.</span></span><br></pre></td></tr></table></figure><h4 id="equals-and-compareTo"><a href="#equals-and-compareTo" class="headerlink" title="equals() and compareTo()"></a>equals() and compareTo()</h4><p>可以用eqauls和compareTo比较两个buffer</p><p><strong>equals():</strong></p><p>判断两个buffer相对，需满足：</p><ul><li>类型相同</li><li>buffer中剩余字节数相同</li><li>所有剩余字节相等</li></ul><p>从上面的三个条件可以看出，equals只比较buffer中的部分内容，并不会去比较每一个元素。</p><p><strong>compareTo():</strong></p><p>compareTo也是比较buffer中的剩余元素，只不过这个方法适用于比较排序的。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>通常来说NIO中的所有IO都是从Channel（通道）开始的。</p><ul><li><strong>从通道进行数据读取</strong>：创建一个缓冲区，然后请求通道读取数据。</li><li><strong>从通道进行数据写入</strong>：创建一个缓冲区，填充数据，并要求通道写入数据。</li></ul><p>数据读取和写入操作图示：</p><p><img src="/images/nio_channel_rw.png" alt="nio_channel_rw"></p><h3 id="与流的区别"><a href="#与流的区别" class="headerlink" title="与流的区别"></a>与流的区别</h3><ul><li>通道可以读也可以写，<strong>流一般来说是单向的</strong>（只能读或者写，所以之前我们用流进行IO操作的时候需要分别创建一个输入流和一个输出流）。</li><li>通道可以<strong>异步读写</strong>。</li><li>通道总是<strong>基于缓冲区Buffer</strong>来读写。</li></ul><h3 id="重要的几个Channel的实现"><a href="#重要的几个Channel的实现" class="headerlink" title="重要的几个Channel的实现"></a>重要的几个Channel的实现</h3><ul><li>FileChannel：用于文件的数据读写</li><li>DatagramChannel：用于UDP的数据读写</li><li>SocketChannel：用于TCP的数据读写，一般是客户端实现</li><li>ServerSocketChannel：允许我们监听TCP链接请求，每个请求会创建会一个SocketChannel，一般是服务器实现</li></ul><p>类层次结构：</p><p><img src="/images/channel_structure.png" alt="channel_structure"></p><h3 id="FileChannel的使用"><a href="#FileChannel的使用" class="headerlink" title="FileChannel的使用"></a>FileChannel的使用</h3><p>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。</p><p>FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p><h4 id="打开FileChannel"><a href="#打开FileChannel" class="headerlink" title="打开FileChannel"></a>打开FileChannel</h4><p>在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。下面是通过RandomAccessFile打开FileChannel的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br></pre></td></tr></table></figure><h4 id="从FileChannel读取数据"><a href="#从FileChannel读取数据" class="headerlink" title="从FileChannel读取数据"></a>从FileChannel读取数据</h4><p>调用多个read()方法之一从FileChannel中读取数据。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure><p>首先，分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。</p><p>然后，调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示了有多少字节被读到了Buffer中。如果返回-1，表示到了文件末尾。</p><h4 id="向FileChannel写数据"><a href="#向FileChannel写数据" class="headerlink" title="向FileChannel写数据"></a>向FileChannel写数据</h4><p>使用FileChannel.write()方法向FileChannel写数据，该方法的参数是一个Buffer。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。</p><h4 id="关闭FileChannel"><a href="#关闭FileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h4><p>用完FileChannel后必须将其关闭。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure><h4 id="FileChannel的position方法"><a href="#FileChannel的position方法" class="headerlink" title="FileChannel的position方法"></a>FileChannel的position方法</h4><p>有时可能需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用position()方法获取FileChannel的当前位置。</p><p>也可以通过调用position(long pos)方法设置FileChannel的当前位置。</p><p>这里有两个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> pos = channel.position();</span><br><span class="line">channel.position(pos + <span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回-1 —— 文件结束标志。</p><p>如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“文件空洞”，磁盘上物理文件中写入的数据间有空隙。</p><h4 id="FileChannel的size方法"><a href="#FileChannel的size方法" class="headerlink" title="FileChannel的size方法"></a>FileChannel的size方法</h4><p>FileChannel实例的size()方法将返回该实例所关联文件的大小。如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> fileSize = channel.size();</span><br></pre></td></tr></table></figure><h4 id="FileChannel的truncate方法"><a href="#FileChannel的truncate方法" class="headerlink" title="FileChannel的truncate方法"></a>FileChannel的truncate方法</h4><p>可以使用FileChannel.truncate()方法截取一个文件。截取文件时，文件将中指定长度后面的部分将被删除。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.truncate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>这个例子截取文件的前1024个字节。</p><h4 id="FileChannel的force方法"><a href="#FileChannel的force方法" class="headerlink" title="FileChannel的force方法"></a>FileChannel的force方法</h4><p>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。</p><p>force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。</p><p>下面的例子同时将文件数据和元数据强制写到磁盘上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.force(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a>Scatter/Gather</h2><p>Java NIO开始支持scatter/gather，scatter/gather用于描述从 Channel中读取或者写入到Channel的操作。</p><p>分散（scatter）从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。</p><p>聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。</p><p>scatter/gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。</p><h3 id="Scattering-Reads"><a href="#Scattering-Reads" class="headerlink" title="Scattering Reads"></a>Scattering Reads</h3><p>Scattering Reads是指数据从一个channel读取到多个buffer中。如下图描述：</p><p><img src="/images/scattering_reads.png" alt="scattering_reads"></p><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">channel.read(bufferArray);</span><br></pre></td></tr></table></figure><p>注意buffer首先被插入到数组，然后再将数组作为channel.read() 的输入参数。read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。</p><p>Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息(译者注：消息大小不固定)。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如 128byte），Scattering Reads才能正常工作。</p><h3 id="Gathering-Writes"><a href="#Gathering-Writes" class="headerlink" title="Gathering Writes"></a>Gathering Writes</h3><p>Gathering Writes是指数据从多个buffer写入到同一个channel。如下图描述：</p><p><img src="/images/gathering_writes.png" alt="gathering_writes"></p><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//write data into buffers</span></span><br><span class="line"></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure><p>buffers数组是write()方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与Scattering Reads相反，Gathering Writes能较好的处理动态消息。</p><h2 id="通道之间的数据传输"><a href="#通道之间的数据传输" class="headerlink" title="通道之间的数据传输"></a>通道之间的数据传输</h2><p>在Java NIO中，如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel（译者注：channel中文常译作通道）传输到另外一个channel。</p><h3 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h3><p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中（译者注：这个方法在JDK文档中的解释为将字节从给定的可读取字节通道传输到此通道的文件中）。</p><p>下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">toChannel.transferFrom(position, count, fromChannel);</span><br></pre></td></tr></table></figure><p>方法的输入参数position表示从position处开始向目标文件写入数据，count表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。</p><p>此外要注意，在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。</p><h3 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h3><p>transferTo()方法将数据从FileChannel传输到其他的channel中。</p><p>下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure><p>是不是发现这个例子和前面那个例子特别相似？除了调用方法的FileChannel对象不一样外，其他的都一样。</p><p>上面所说的关于SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。</p><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。</p><h3 id="为什么使用Selector"><a href="#为什么使用Selector" class="headerlink" title="为什么使用Selector?"></a>为什么使用Selector?</h3><p>仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）。因此，使用的线程越少越好。</p><p>但是，需要记住，现代的操作系统和CPU在多任务方面表现的越来越好，所以多线程的开销随着时间的推移，变得越来越小了。实际上，如果一个CPU有多个内核，不使用多任务可能是在浪费CPU能力。不管怎么说，关于那种设计的讨论应该放在另一篇不同的文章中。在这里，只要知道使用Selector能够处理多个通道就足够了。</p><p>下面是单线程使用一个Selector处理3个channel的示例图：</p><p><img src="/images/selector.png" alt="selector"></p><h3 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h3><p>通过调用Selector.open()方法创建一个Selector，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><h3 id="向Selector注册通道"><a href="#向Selector注册通道" class="headerlink" title="向Selector注册通道"></a>向Selector注册通道</h3><p>为了将Channel和Selector配合使用，必须将channel注册到selector上。通过SelectableChannel.register()方法来实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector,</span><br><span class="line">    Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p><p>注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p><ul><li>Connect</li><li>Accept</li><li>Read</li><li>Write</li></ul><p>通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。</p><p>这四种事件用SelectionKey的四个常量来表示：</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>在上一小节中，当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性：</p><ul><li>interest集合</li><li>ready集合</li><li>Channel</li><li>Selector</li><li>附加的对象（可选） </li></ul><h4 id="interest集合"><a href="#interest集合" class="headerlink" title="interest集合"></a>interest集合</h4><p>就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><p>可以看到，用“位与”操作interest 集合和给定的SelectionKey常量，可以确定某个确定的事件是否在interest 集合中。</p><h4 id="ready集合"><a href="#ready集合" class="headerlink" title="ready集合"></a>ready集合</h4><p>ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure><p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure><h4 id="Channel-Selector"><a href="#Channel-Selector" class="headerlink" title="Channel + Selector"></a>Channel + Selector</h4><p>从SelectionKey访问Channel和Selector很简单。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure><h4 id="附加的对象"><a href="#附加的对象" class="headerlink" title="附加的对象"></a>附加的对象</h4><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure><h3 id="通过Selector选择通道"><a href="#通过Selector选择通道" class="headerlink" title="通过Selector选择通道"></a>通过Selector选择通道</h3><p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p><p>下面是select()方法：</p><ul><li>int select()</li><li>int select(long timeout)</li><li>int selectNow()</li></ul><p>select()阻塞到至少有一个通道在你注册的事件上就绪了。</p><p>select(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)。</p><p>selectNow()不会阻塞，不管什么通道就绪都立刻返回（译者注：此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。）。</p><p>select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p><h4 id="selectedKeys"><a href="#selectedKeys" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h4><p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p><p>当像Selector注册Channel时，Channel.register()方法会返回一个SelectionKey 对象。这个对象代表了注册到该Selector的通道。可以通过SelectionKey的selectedKeySet()方法访问这些对象。</p><p>可以遍历这个已选择的键集合来访问就绪的通道。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。</p><p>注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p><p>SelectionKey.channel()方法返回的通道需要转型成你要处理的类型，如ServerSocketChannel或SocketChannel等。</p><h4 id="wakeUp"><a href="#wakeUp" class="headerlink" title="wakeUp()"></a>wakeUp()</h4><p>某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p><p>如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p><h4 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h4><p>用完Selector后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统一致性及Paxos详解</title>
      <link href="/2018/08/05/paxos/"/>
      <url>/2018/08/05/paxos/</url>
      
        <content type="html"><![CDATA[<p>说起Paxos，这简直是我一直以来的梦魇，经历了几次半知半解、看过就忘的学习历程，形成了一种看了就怕的心理暗示。今天下午翻看技术博客偶然的机会，发现了@知行学社的《<a href="https://v.youku.com/v_show/id_XMTI4NTUxNzMwNA==.html?spm=a2h0k.11417342.soresults.dposter" target="_blank" rel="noopener">分布式系统与Paxos算法视频课程</a>》，大致看了一遍，如获至宝。并重复看了2、3遍后，方才恍然大悟。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在分布式系统中，为了保证数据的高可用，通常，我们会将数据保留多个副本(replica)，这些副本会放置在不同的物理机器上。为了对用户提供正确的CRUD等语义，我们需要保证这些放置在不同物理机器上的副本是一致的。</p><p>为了解决这种<strong>分布式一致性问题</strong>，前人在性能和数据一致性的反反复复权衡过程中总结了许多典型的协议和算法。其中比较著名的有二阶提交协议（Two Phase Commitment Protocol）、三阶提交协议（Three Phase Commitment Protocol）和Paxos算法。</p><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。由于存在事务机制，可以保证每个独立节点上的数据操作可以满足ACID。但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况。所以从理论上讲，两台机器理论上无法达到一致的状态。如果想让分布式部署的多台机器中的数据保持一致性，那么就要保证在所有节点的数据写操作，要不全部都执行，要么全部的都不执行。但是，一台机器在执行本地事务的时候无法知道其他机器中的本地事务的执行结果。所以他也就不知道本次事务到底应该commit还是 rollback。所以，常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行。</p><h1 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h1><p>两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做。所谓的两个阶段是指：第一阶段：<strong>准备阶段(投票阶段)</strong>和第二阶段：<strong>提交阶段（执行阶段）</strong>。</p><p>二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p><p>可以进一步将准备阶段分为以下三个步骤：</p><ol><li>协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</li><li>参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</li><li>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个“同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个“中止”消息。</li></ol><h2 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h2><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p><p>接下来分两种情况分别讨论提交阶段的过程。</p><p>当协调者节点从所有参与者节点获得的相应消息都为“同意”时:</p><p><img src="/images/2PC_success.png" alt="2PC_success"></p><ol><li>协调者节点向所有参与者节点发出“正式提交(commit)”的请求。</li><li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送“完成”消息。</li><li>协调者节点受到所有参与者节点反馈的“完成”消息后，完成事务。</li></ol><p>如果任一参与者节点在第一阶段返回的响应消息为“中止”，或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p><p><img src="/images/2PC_fail.png" alt="2PC_fail"></p><ol><li>协调者节点向所有参与者节点发出“回滚操作(rollback)”的请求。</li><li>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送“回滚完成”消息。</li><li>协调者节点受到所有参与者节点反馈的“回滚完成”消息后，取消事务。</li></ol><p>不管最后结果如何，第二阶段都会结束当前事务。</p><h2 id="2PC缺点"><a href="#2PC缺点" class="headerlink" title="2PC缺点"></a>2PC缺点</h2><p>二阶段提交看起来确实能够提供原子性的操作，但是不幸的是，二阶段提交还是有几个缺点的：</p><ol><li><strong>同步阻塞问题</strong>。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li><li><strong>单点故障</strong>。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）。</li><li><strong>数据不一致</strong>。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</li><li>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li></ol><p>由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p><h1 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h1><p>三阶段提交（Three-phase commit），也叫三阶段提交协议（Three-phase commit protocol），是二阶段提交（2PC）的改进版本。</p><p><img src="/images/3PC.png" alt="3PC"></p><p>与两阶段提交不同的是，三阶段提交有两个改动点:</p><ol><li>引入<strong>超时机制</strong>。同时在协调者和参与者中都引入超时机制。</li><li>在第一阶段和第二阶段中插入一个<strong>准备阶段</strong>。保证了在最后提交阶段之前各参与节点的状态是一致的。</li></ol><p>也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有<code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code>三个阶段。</p><h2 id="CanCommit阶段"><a href="#CanCommit阶段" class="headerlink" title="CanCommit阶段"></a>CanCommit阶段</h2><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p><h2 id="PreCommit阶段"><a href="#PreCommit阶段" class="headerlink" title="PreCommit阶段"></a>PreCommit阶段</h2><p>协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。</p><p><strong>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。</strong></p><ol><li><strong>发送预提交请求</strong>。协调者向参与者发送PreCommit请求，并进入Prepared阶段。</li><li><strong>事务预提交</strong>。参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</li><li><strong>响应反馈</strong>。如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</li></ol><p><strong>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</strong></p><ol><li><strong>发送中断请求</strong>。协调者向所有参与者发送abort请求。</li><li><strong>中断事务</strong>。参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li></ol><h2 id="DoCommit阶段"><a href="#DoCommit阶段" class="headerlink" title="DoCommit阶段"></a>DoCommit阶段</h2><p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p><p><strong>执行提交</strong></p><ol><li><strong>发送提交请求</strong>。协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</li><li><strong>事务提交</strong>。参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</li><li><strong>响应反馈</strong>。事务提交完之后，向协调者发送ack响应。</li><li><strong>完成事务</strong>。协调者接收到所有参与者的ack响应之后，完成事务。</li></ol><p><strong>中断事务</strong></p><p>协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p><ol><li><strong>发送中断请求</strong>。协调者向所有参与者发送abort请求。</li><li><strong>事务回滚</strong>。参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</li><li><strong>反馈结果</strong>。参与者完成事务回滚之后，向协调者发送ACK消息。</li><li><strong>中断事务</strong>。协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</li></ol><blockquote><p>在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。）</p></blockquote><h1 id="Paxos的提出"><a href="#Paxos的提出" class="headerlink" title="Paxos的提出"></a>Paxos的提出</h1><p>为分布式系统设计一个正确的一致性协议是很困难的，了解了2PC和3PC之后，我们可以发现，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。Google Chubby的作者Mike Burrows说过， *”There is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos.* 意即世上只有一种一致性算法，那就是Paxos，所有其他一致性算法都是Paxos算法的不完整版。</p><h2 id="Paxos的理解困境"><a href="#Paxos的理解困境" class="headerlink" title="Paxos的理解困境"></a>Paxos的理解困境</h2><p><strong>Paxos究竟在解决什么问题？</strong></p><p>这个问题等同于：Paxos如何确定一个不可变变量的取值。取值可以是任意二进制数据，并且一旦确定将不再更改，并且可以被获取到（不可变性、可读取性）。</p><p><strong>Paxos如何在分布式存储系统中应用？</strong></p><p>我们知道在分布式系统中数据是可变的，用户可以任意的进行增删改查，分布式存储系统为了保证数据的可靠存储，一般会采用多副本的方式进行存储。如果对多个副本执行的操作序列[<code>$op_1$</code>, <code>$op_2$</code>, …, <code>$op_n$</code>]不进行任何控制，那网络延迟、超时等各种故障都会导致各个副本之间的更新操作是不同的，这样很难保证副本间的一致性。所以为了保证分布式存储系统数据的一致性，我们希望在各个副本之间的更新操作序列是相同的、不变的，即每个副本执行[<code>$op_1$</code>, <code>$op_2$</code>, …, <code>$op_n$</code>]顺序是相同的。我们通过Paxos算法依次来确定不可变变量<code>$op_i$</code>的取值，即第i个操作是什么。每次确定完<code>$op_i$</code>之后，可以让各个副本来执行<code>$op_i$</code>，依次类推。</p><h2 id="抽象问题"><a href="#抽象问题" class="headerlink" title="抽象问题"></a>抽象问题</h2><p>本文介绍Paxos过程中，希望抽象为这样一个实际问题：即设计一个系统，来存储名称为var的变量。系统内部由多个acceptor组成，负责存储和管理var变量；外部有多个proposal机器，可以任意并发的调用系统api，向系统提交不同的var取值；系统对外的api接口为：<code>propose(var, V) =&gt; &lt;ok, f&gt; or &lt;error&gt;</code>，其中f为系统内部已经确定下来的var的取值。</p><p>系统需要保证var的取值<strong>满足一致性</strong>，即var的取值初始为null，而一旦var的取值被确定，则不可以被更改，并且可以一直获取到这个值。</p><p>除了一致性以外，系统还需要满足<strong>容错性</strong>，即可以容忍任意proposal机器出现故障，也可以容忍少数（半数以下）acceptor出现故障。</p><p>暂不考虑网络分化、acceptor故障会丢失var信息等其他问题。</p><h2 id="系统难点"><a href="#系统难点" class="headerlink" title="系统难点"></a>系统难点</h2><p>设计这样一个系统有什么难点呢？</p><ul><li>如何管理控制多个proposal的并发执行；</li><li>如何保证var变量的不可变性；</li><li>如何容忍任意proposal机器故障；</li><li>如何容忍半数以下acceptor故障。</li></ul><h2 id="确定不可变变量取值-——-方案一"><a href="#确定不可变变量取值-——-方案一" class="headerlink" title="确定不可变变量取值 —— 方案一"></a>确定不可变变量取值 —— 方案一</h2><p>在方案一中我们先考虑整个系统由单个acceptor组成，通过类似互斥锁的机制，来<em>管理并发的proposal运行</em>。Proposal首先向acceptor申请互斥访问权，然后才能请求acceptor接受自己的取值。而acceptor给proposal发放互斥访问权，谁申请到互斥访问权，就接受谁提交的取值。</p><p>这样通过互斥访问权机制，我们可以让proposal按照获取互斥访问权的顺序来依次访问acceptor，一旦acceptor接受了某个proposal的取值，则认为var值被确定，其他的proposal不能再更改。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>以下是基于互斥访问权的acceptor实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Acceptor保存：</span><br><span class="line">  变量<span class="keyword">var</span></span><br><span class="line">  一个互斥锁lock</span><br><span class="line"></span><br><span class="line">Acceptor.prepare():</span><br><span class="line">  加互斥锁，给予<span class="keyword">var</span>的互斥访问权，并返回<span class="keyword">var</span>的当前取值f。</span><br><span class="line">Acceptor.release():</span><br><span class="line">  释放互斥锁，收回<span class="keyword">var</span>的互斥访问权。</span><br><span class="line">Acceptor.accept(<span class="keyword">var</span>, V):</span><br><span class="line">  如果已经加锁，并且<span class="keyword">var</span>没有取值，则设置<span class="keyword">var</span>为V，并且释放锁。</span><br></pre></td></tr></table></figure><p><strong>propose(var, V)的两阶段实现：</strong></p><ul><li>第一阶段：通过<code>Acceptor.prepare()</code>获取互斥访问权和当前var取值，如果无法获取，返回<code>&lt;error&gt;</code>（锁被别人占用）。</li><li>第二阶段：根据当前var的取值f，选择执行：<ul><li>如果f为null（以前没有proposal设置过var的值），则通过<code>Acceptor.accept(var, V)</code>提交数据；</li><li>如果f不为null（接受某个proposal设置过var的值f），则通过<code>Acceptor.release()</code>释放访问权，返回<code>&lt;ok, f&gt;</code>。</li></ul></li></ul><h3 id="方案一总结"><a href="#方案一总结" class="headerlink" title="方案一总结"></a>方案一总结</h3><p>所以总结来说方案一是通过Acceptor互斥访问权，能够让Proposal按照获取互斥访问权的顺序序列运行，而不再是并行运行，这样可以简单实现var取值的一致性。</p><p>但不足的是，Proposal在获取到互斥访问权后，并且还没有释放互斥访问权之前发生了故障，则会导致其他所有Proposal无法获取互斥访问权进入第二阶段运行，此时会导致系统陷入“死锁”的状态。即，<strong>方案一无法容忍任意Proposal机器出现故障</strong>。</p><h2 id="引入抢占式访问权-——-方案二"><a href="#引入抢占式访问权-——-方案二" class="headerlink" title="引入抢占式访问权 —— 方案二"></a>引入抢占式访问权 —— 方案二</h2><p>我们提出方案二，引入抢占式访问权的方式来解决死锁问题，即Acceptor可以让某个Proposal获取到的访问权失效，不再接受它的访问。之后，可以将访问权发放给其他的Proposal，让其他Proposal访问Acceptor。从而避免“死锁”带来的影响。</p><p>对Proposal来说，Proposal向Acceptor申请访问权时会指定编号<strong>epoch</strong>（越大的epoch越新）。获取到访问权以后，才能向Acceptor提交取值。</p><p>对Acceptor来说，采用“<strong>喜新厌旧</strong>”的原则。即一旦收到更大的新epoch的申请，马上让旧epoch的访问权失效，不再接受他们提交的取值，然后给新的epoch发放访问权限，只接受新的epoch提交的取值。</p><p>在这种原则下，新的epoch可以抢占旧epoch，让旧epoch访问权失效。为了保证一致性，不同epoch的Proposal之间采用“<strong>后者认同前者</strong>”的原则，即在肯定旧epoch无法生成确定性取值时，新的epoch会提交自己的value，不会冲突；一旦旧epoch形成确定性取值，新的epoch肯定可以获取到此取值，并且认同此取值，不会破坏。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p><strong>基于抢占式访问权的acceptor实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Acceptor保存：</span><br><span class="line">  当前<span class="keyword">var</span>的取值&lt;accepted_epoch, accepted_value&gt;</span><br><span class="line">  最新发放访问权的epoch latest_prepared_epoch</span><br><span class="line">  </span><br><span class="line">Acceptor.prepare(epoch)：</span><br><span class="line">  只接受比latest_prepared_epoch更大的epoch，并给予访问权；</span><br><span class="line">  记录latest_prepared_epoch = epoch，返回当前<span class="keyword">var</span>值。</span><br><span class="line">Acceptor.accept(<span class="keyword">var</span>, prepared_epoch, V)：</span><br><span class="line">  验证latest_prepared_epoch == prepared_epoch，若不等，说明有一个更大的epoch抢占了访问权，prepared_epoch已失效；</span><br><span class="line">  并设置<span class="keyword">var</span>的取值&lt;accepted_epoch, accepted_value&gt; = &lt;prepared_epoch, V&gt;</span><br></pre></td></tr></table></figure><p><strong>propose(var, V)的两阶段实现：</strong></p><ul><li>第一阶段：获取epoch轮次的访问权和当前var的取值，我们可以简单获取当前时间戳为epoch：<ul><li>通过<code>Acceptor.prepare(epoch)</code>，获取epoch轮次的访问权和当前var的取值；</li><li>如果不能获取，返回<code>&lt;error&gt;</code>。</li></ul></li><li>第二阶段：采用“后者认同前者”的原则执行。<ul><li>如果var取值为null，则肯定旧epoch无法生成确定性取值，则通过<code>Acceptor.accept(var, prepared_epoch, V)</code>提交数据V。<ul><li>成功后返回<code>&lt;ok, V&gt;</code>；</li><li>若accept失败，则说明被更新的epoch抢占或Acceptor故障，返回<code>&lt;error&gt;</code>。</li></ul></li><li>如果var取值存在，则此取值肯定是确定性取值，此时认同它不再更改，直接返回<code>&lt;ok, accepted_value&gt;</code>。</li></ul></li></ul><p><img src="/images/qiangzhanshi.png" alt="qiangzhanshi"></p><p>步骤请看《<a href="https://v.youku.com/v_show/id_XMTI4NTUxNzMwNA==.html?spm=a2h0k.11417342.soresults.dposter" target="_blank" rel="noopener">分布式系统与Paxos算法视频课程</a>》。</p><h3 id="方案二总结"><a href="#方案二总结" class="headerlink" title="方案二总结"></a>方案二总结</h3><p>基于抢占式访问权的核心思想是让Proposal按照epoch递增的顺序抢占式的依次运行，后者会认同前者。在这种机制下，可以避免Proposal机器故障带来的“死锁”问题，并且仍可以保证var取值的一致性。</p><p>但方案二中只有一个Acceptor，单机模块的Acceptor故障时会导致整个系统宕机，无法提供服务，所以我们仍需要引入多个Acceptor。</p><h2 id="Paxos解决方案"><a href="#Paxos解决方案" class="headerlink" title="Paxos解决方案"></a>Paxos解决方案</h2><p>前面铺垫了这么多，总算来到了paxos的解决方案！</p><p>Paxos是在方案二的基础上引入多个Acceptor，在paxos方案里面，Acceptor的实现保持不变，仍然采用“喜新厌旧”的原则运行。由于引进多个Acceptor，所以采用“少数服从多数”的思路。一旦<strong>某个epoch的取值f被半数以上Acceptor接受</strong>，我们就认为这个var的取值被确定为f，不再更改。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p><strong>Acceptor同方案二，但加入多个Acceptor。</strong></p><p><strong>Proposal同方案二，仍旧采用两阶段方式运行propose(var, V)：</strong></p><ul><li>第一阶段：选定epoch，获取epoch访问权和对应的var取值，在paxos中需要获取半数以上Acceptor的访问权和对应一组var取值。</li><li>第二阶段：采用“后者认同前者”的原则执行。<ul><li>如果获取的var取值都为null，则旧的epoch无法形成确定性取值，此时努力使<code>&lt;epoch, V&gt;</code>成为确定性取值：<ul><li>向epoch对应的所有Acceptor提交取值<code>&lt;epoch, V&gt;</code>；</li><li>如果收到半数以上成功，则返回<code>&lt;ok, V&gt;</code>；</li><li>否则返回<code>&lt;error&gt;</code>（被新的epoch抢占或Acceptor故障）。</li></ul></li><li>如果var的取值存在，认同最大的accepted_epoch对应的取值f，努力使<code>&lt;epoch, f&gt;</code>成为确定性取值。<ul><li>如果f出现半数以上，则说明f已经是确定性取值，直接返回<code>ok, f&lt;&gt;</code>；</li><li>否则，向epoch对应的所有Acceptor提交取值<code>&lt;epoch, f&gt;</code>。</li></ul></li></ul></li></ul><p><img src="/images/paxos_run.png" alt="paxos_run"></p><p>步骤请看《<a href="https://v.youku.com/v_show/id_XMTI4NTUxNzMwNA==.html?spm=a2h0k.11417342.soresults.dposter" target="_blank" rel="noopener">分布式系统与Paxos算法视频课程</a>》。</p><h1 id="Paxos总结"><a href="#Paxos总结" class="headerlink" title="Paxos总结"></a>Paxos总结</h1><p>Paxos算法<strong>核心思想</strong>：</p><ul><li>在抢占式访问权基础上引入多个Acceptor；</li><li>保证一个epoch，只有一个Proposal运行，Proposal按照epoch递增的顺序依次运行；</li><li>新epoch的Proposal采用“后者认同前者”的思路运行：<ul><li>在肯定旧的epoch无法生成确定性取值时，新的epoch会提交自己的取值，不会冲突；</li><li>一旦旧的epoch行程确定性取值，新的epoch肯定可以获取到此取值，并且会认同此取值，不会破坏。</li></ul></li></ul><p>Paxos算法可以满足<strong>容错要求</strong>，即半数以下Acceptor出现故障时，存活的Acceptor仍然可以生成var的确定性取值；一旦var值被确定，即使出现半数一下Acceptor故障，此取值可以被获取，并且将不再被更改。</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型及内存可见性</title>
      <link href="/2018/08/01/java-synchronized-volatile/"/>
      <url>/2018/08/01/java-synchronized-volatile/</url>
      
        <content type="html"><![CDATA[<p>本篇是观看<a href="http://www.imooc.com/learn/352" target="_blank" rel="noopener">细说Java多线程之内存可见性</a>后的笔记。</p><h1 id="共享变量在线程间的可见性"><a href="#共享变量在线程间的可见性" class="headerlink" title="共享变量在线程间的可见性"></a>共享变量在线程间的可见性</h1><h2 id="什么是可见性"><a href="#什么是可见性" class="headerlink" title="什么是可见性"></a>什么是可见性</h2><ul><li>可见性：一个线程对共享变量值的修改，能够及时地被其他线程看到；</li><li>共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。</li></ul><h2 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h2><p>Java内存模型（Java Memory Model）描述了Java程序中各种变量（线程共享变量）的访问规则，以及JVM中将<strong>变量</strong>存储到内存和从主内存读取出<strong>变量</strong>这样的底层细节。</p><p>以下所说的<strong>变量</strong>都指的是<strong>共享变量</strong>。</p><ul><li>所有的变量都存储在主内存中；</li><li>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的<strong>副本</strong>（主内存中该变量的一份拷贝）。</li></ul><p><img src="/images/JMM.png" alt="JMM"></p><p>两条规定：</p><ol><li>线程对共享变量的所有操作都必须<strong>在自己的工作内存中进行</strong>，不能直接从主内存中读写；</li><li>不同线程之间<strong>无法直接访问其他线程工作内存中的变量</strong>，线程间变量值的传递需要通过主内存来完成。</li></ol><h2 id="共享变量可见性实现原理"><a href="#共享变量可见性实现原理" class="headerlink" title="共享变量可见性实现原理"></a>共享变量可见性实现原理</h2><p>线程1对共享变量的修改要想被线程2及时看到，必须要经过下面两个步骤：</p><ol><li>把工作内存1中更新过的共享变量刷新到主内存中；</li><li>将主内存中最新的共享变量的值更新到工作内存2中。</li></ol><h1 id="synchronized实现可见性"><a href="#synchronized实现可见性" class="headerlink" title="synchronized实现可见性"></a>synchronized实现可见性</h1><p>synchronized能够实现：</p><ul><li>原子性（同步）</li><li>可见性</li></ul><p>JMM关于synchronized的两条规定：</p><ul><li>线程解锁前，必须把共享变量的最新值刷新到主内存中；</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）。</li></ul><p>以上两条规定可以保证：线程在解锁前对共享变量的修改在下次加锁时对其他线程可见。</p><p>线程执行互斥代码的过程：</p><ol><li>获得<strong>互斥锁</strong>；</li><li>清空工作内存；</li><li>从主内存拷贝变量的最新副本到工作内存；</li><li>执行代码；</li><li>将更改后的共享变量的值刷新到主内存；</li><li>释放互斥锁。</li></ol><h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><p>重排序：代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化。</p><ol><li>编译器优化的重排序（编译器优化）；</li><li>指令级并行重排序（处理器优化）；</li><li>内存系统的重排序（处理器优化）。</li></ol><p>例如（有可能）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码顺序</span></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行顺序</span></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h2><p>as-if-serial：无论如何重排序，程序执行结果应该与代码顺序执行的结果一致（Java编译器、运行时和处理器都会保证Java在单线程下遵循as-if-serial语义）。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> sum = num1 + num2;</span><br></pre></td></tr></table></figure><p>单线程中，第1、2行顺序可以重排，但第3行不能。重排序不会给单线程带来内存可见性问题。但是在多线程中程序交错执行时，重排序可能会造成内存可见性问题。</p><h2 id="可见性分析"><a href="#可见性分析" class="headerlink" title="可见性分析"></a>可见性分析</h2><p>导致共享变量在线程间不可见的原因：</p><ul><li>线程的交叉执行；</li><li>重排序结合线程交叉执行；</li><li>共享变量更新后的值没有在工作内存与主内存间及时更新。</li></ul><h1 id="volatile实现可见性"><a href="#volatile实现可见性" class="headerlink" title="volatile实现可见性"></a>volatile实现可见性</h1><p>volatile关键字：</p><ul><li>能够保证volatile变量的<strong>可见性</strong>；</li><li><strong>不能保证</strong>volatile变量复合操作的<strong>原子性</strong>。</li></ul><p>volatile如何实现内存可见性：深入来说，通过加入内存屏障和禁止重排序优化来实现的。</p><ul><li>对volatile变量执行写操作时，会在写操作后加入一条<strong>store屏障指令</strong>（写后强制刷新到主内存中去）；</li><li>对volatile变量执行读操作时，会在读操作前加入一条<strong>load屏障指令</strong>（强制使工作内存中的变量拷贝失效）。</li></ul><p>通俗的讲，volatile变量在每次被线程访问时，都强迫从主内存中重读改变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新回主内存。这样任何时刻，不同的线程总能看到该变量的最新值。</p><p>线程写volatile变量的过程：</p><ol><li>改变线程工作内存中volatile变量副本的值；</li><li>将改变后的副本的值从工作内存刷新回主内存。</li></ol><p>线程读volatile变量的过程：</p><ol><li>从主内存中读取volatile变量的最新值到线程的工作内存中；</li><li>从工作内存中读取volatile变量的副本。</li></ol><h2 id="volatile使用注意事项"><a href="#volatile使用注意事项" class="headerlink" title="volatile使用注意事项"></a>volatile使用注意事项</h2><p>要在多线程中安全的使用volatile变量，必须同时满足：</p><ol><li>对变量的写入操作不依赖其当前值，即不满足number++、count *= 5等，满足boolean变量等；</li><li>该变量没有包含在具有其他变量的不变式中，即若程序中有多个volatile变量，那么每个volatile变量要独立于其他volatile变量。</li></ol><p>日常中我们很多情况都与上述两点中的一点有冲突，所以volatile并没有synchronized使用得广泛。</p><h1 id="synchronized和volatile比较"><a href="#synchronized和volatile比较" class="headerlink" title="synchronized和volatile比较"></a>synchronized和volatile比较</h1><ul><li>volatile不会加锁，比synchronized更轻量级，不会阻塞线程，执行效率更高；</li><li>从内存可见性角度讲，volatile读相当于加锁，volatile写相当于解锁；</li><li>synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Concurrency </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CuckooFilter详解</title>
      <link href="/2018/07/22/cuckoo-filter/"/>
      <url>/2018/07/22/cuckoo-filter/</url>
      
        <content type="html"><![CDATA[<p>对于海量数据处理业务，我们通常需要一个索引数据结构，用来帮助查询，快速判断数据记录是否存在，这种数据结构通常又叫过滤器(filter)。考虑这样一个场景，上网的时候需要在浏览器上输入URL，这时浏览器需要去判断这是否一个恶意的网站，它将对本地缓存的成千上万的URL索引进行过滤，如果不存在，就放行，如果（可能）存在，则向远程服务端发起验证请求，并回馈客户端给出警告。</p><h1 id="BloomFilter的缺陷"><a href="#BloomFilter的缺陷" class="headerlink" title="BloomFilter的缺陷"></a>BloomFilter的缺陷</h1><p>时下一个非常流行的哈希索引结构就是bloom filter，它类似于bitmap这样的hashset，所以空间利用率很高。其独特的地方在于它使用多个哈希函数来避免哈希碰撞，如图所示（来源wikipedia），bit数组初始化为全0，插入x时，x被3个哈希函数分别映射到3个不同的bit位上并置1，查询x时，只有被这3个函数映射到的bit位全部是1才能说明x可能存在，但凡至少出现一个0表示x肯定不存在。</p><p><img src="/images/bloomFilterWorkflow.png" alt="bloomFilterWorkflow"></p><p>但是，bloom filter的这种位图模式带来两个问题：一个是<strong>误报（false positives）</strong>，在查询时能提供“一定不存在”，但只能提供“可能存在”，因为存在其它元素被映射到部分相同bit位上，导致该位置1，那么一个不存在的元素可能会被误报成存在；另一个是<strong>漏报（false nagatives）</strong>，同样道理，如果删除了某个元素，导致该映射bit位被置0，那么本来存在的元素会被漏报成不存在。由于后者问题严重得多，所以bloom filter必须确保“definitely no”从而容忍“probably yes”，不允许元素的删除。</p><p>关于元素删除的问题，一个改良方案是对bloom filter引入计数（Counting Bloom filters），但这样一来，原来每个bit空间就要扩张成一个计数值，空间效率上又降低了。</p><h1 id="Cuckoo-Filter"><a href="#Cuckoo-Filter" class="headerlink" title="Cuckoo Filter"></a>Cuckoo Filter</h1><p>为了解决这一问题，本文引入了一种新的哈希算法 —— cuckoo filter，它既可以确保该元素存在的必然性，又可以在不违背此前提下删除任意元素，仅仅比bitmap牺牲了微量空间效率。</p><h2 id="Cuckoo-Hash-Tables"><a href="#Cuckoo-Hash-Tables" class="headerlink" title="Cuckoo Hash Tables"></a>Cuckoo Hash Tables</h2><p>我们先来看看cuckoo hashing有什么特点，它的哈希函数是成对的（具体的实现可以根据需求设计），每一个元素都是两个，分别映射到两个位置，一个是记录的位置，另一个是备用位置。这个备用位置是处理碰撞时用的，这就要说到cuckoo这个名词的典故了，中文名叫布谷鸟，这种鸟有一种即狡猾又贪婪的习性，它不肯自己筑巢，而是把蛋下到别的鸟巢里，而且它的幼鸟又会比别的鸟早出生，布谷幼鸟天生有一种残忍的动作，幼鸟会拼命把未出生的其它鸟蛋挤出窝巢，今后以便独享“养父母”的食物。借助生物学上这一典故，cuckoo hashing处理碰撞的方法，就是把原来占用位置的这个元素踢走，不过被踢出去的元素还要比鸟蛋幸运，因为它还有一个备用位置可以安置，如果备用位置上还有人，再把它踢走，如此往复。直到被踢的次数达到一个上限，才确认哈希表已满，并执行rehash操作。</p><p><img src="/images/cuckooPreview.png" alt="cuckooPreview"></p><p>我们不禁要问发生哈希碰撞之前的空间利用率是多少呢？不幸地告诉你，一维数组的哈希表上跟其它哈希函数没什么区别，也就50%而已。但如果是二维的呢？</p><p>一个改进的哈希表如下图所示，每个桶（bucket）有4路槽位（slot）。当哈希函数映射到同一个bucket中，在其它三路slot未被填满之前，是不会有元素被踢的，这大大缓冲了碰撞的几率。笔者自己的简单实现上测过，采用二维哈希表（4路slot）大约80%的占用率（<a href="http://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pdf" target="_blank" rel="noopener">CMU论文</a>数据据说达到90%以上，应该是扩大了slot关联数目所致）。</p><p><img src="/images/cuckooHashing.png" alt="cuckooHashing"></p><p>如上图所示，(a) 表示插入元素x之前已经存在的元素a, b, c。通过计算x的两个可用位置分别被a, b占用了，随机选择一个位置，也就是元素a存放的位置。然后元素a被迁移到它的备用位置，也就是元素c现在的位置。类似的c再做迁移。(c) 表示Cuckoo Hash的一种实现，每个bucket有四个slot。对于 (a) 的情形，则直接把x插入到元素a或b所在的bucket的空的slot里面即可。</p><p>Cuckoo Filter是Cuckoo Hash的一种更节省空间的变体，它在bucket中存放的不是元素本身，而是 fingerprint(x) 值，也是类似于一种哈希值。</p><h2 id="Cuckoo-Filter算法"><a href="#Cuckoo-Filter算法" class="headerlink" title="Cuckoo Filter算法"></a>Cuckoo Filter算法</h2><p>Cuckoo Hash Table的基本单元叫做entry，每个entry存储一个fingerprint。Hash Table由多个bucket组成，每个bucket有多个entry。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>假设对于x的两个可用位置为i1, i2。当出现x需要迁移的时候，我们怎么得到它的另一个位置呢？因为bucket里面存放的是f = fingerprint值，所以i1，i2不能简单的通过两个哈希函数计算得到。这里使用异或运算达到i1，i2可以互相转化的目的。具体算法如下：</p><p><img src="/images/cuckooFilterInsert.png" alt="cuckooFilterInsert"></p><p>另外在我们为元素再分配地址（下面简称reallocate）的时候，如果一直找不到空闲的位置（比如x, y 的两个可用位置i1, i2完全相同），或者可以找到但是需要的时间出于性能方面的考虑不能忍受，这个时候就需要我们做一个限制，比如设置一个最大的reallocate的次数。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>查找很简单，但是需要注意的是存在误判的。</p><p><img src="/images/cuckooFilterLookUp.png" alt="cuckooFilterLookUp"></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除也是删除的元素fingerprint值，存在误删的情况。</p><p><img src="/images/cuckooFilterDelete.png" alt="cuckooFilterDelete"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Cuckoo Filter的优点是不言而喻的：</p><ul><li>支持动态的插入、删除操作</li><li>整个数据结构接近满的时候，Cuckoo Filter具有更佳的查找性能（95%的空间利用率）</li><li>容易实现</li><li>False Positive Rate比Bloom Filter更小，并且具有更高的空间利用率</li></ul><p>同其他的filter比较：</p><p><img src="/images/filterType.png" alt="filterType"></p><p>但Cuckoo Filter还是有一些缺点：</p><ul><li>由于进行XOR运算，使得Filter的个数必须为2的整数次幂</li><li>储存fingerprint在filter内当做特征值，虽然有一定好处，但是也存在碰撞机会而造成false positive</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BloomFilter详解</title>
      <link href="/2018/07/09/bloom-filter/"/>
      <url>/2018/07/09/bloom-filter/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Bloom-Filter"><a href="#什么是Bloom-Filter" class="headerlink" title="什么是Bloom Filter"></a>什么是Bloom Filter</h1><p>Bloom Filter是一种空间效率很高的随机数据结构，它的原理是，当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位阵列（Bit array）中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检索元素一定不在；如果都是1，则被检索元素很可能在。这就是布隆过滤器的基本思想。</p><p>但Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。</p><p>Bloom Filter示例图：</p><p><img src="/images/Bloom_Filter.png" alt="Bloom_Filter"></p><p>在这个示例中, 我们的Bloom Filter由一个30 bits的Bit Vector以及3个Hash Functions来构成。 我们将三个元素<code>$S_1$</code>, <code>$S_2$</code>和<code>$S_3$</code>分别插入这个Bloom Filter中。 然后对另外三个新元素<code>$S_1$</code>, <code>$S_x$</code>和<code>$S_y$</code>进行查询。 由图所示, <code>$S_1$</code>和<code>$S_x$</code>将被认为属于这个Bloom Filter, 因为所以相应的bit位均为1, 而<code>$S_y$</code>则被视为不属于这个Bloom Filter。 但是, 其中<code>$S_x$</code>为一个false positive的答案, 因为在插入的时候我们并没有插入这个元素。False Positive的答案是由Hash Collision造成的。我们可以根据要插入的元素的个数来变化BF的长度，从而减少误判率。</p><h1 id="Bloom-Filter主要参数计算"><a href="#Bloom-Filter主要参数计算" class="headerlink" title="Bloom Filter主要参数计算"></a>Bloom Filter主要参数计算</h1><p>这部分涉及数学推理，不感兴趣的同学可以直接跳过记住结论。</p><p>影响Bloom Filter的性能的参数主要有四个:</p><ul><li>n : 需要插入Bloom Filter的最多的元素的个数</li><li>m : Bloom Filter中bit位的个数</li><li>k : Hash Functions的个数</li><li>p : Bloom Filter的False Positive rate</li></ul><p>其中需要插入Bloom Filter的最多元素的个数n我们是知道的, 或者至少是大致可以估算的。 所以构建一个Bloom Filter的时候, 主要需要设定bit位的个数, 从而来限制false positive rate的大小。 或者控制false positive rate的大小在一个固定值, 从而推算Bloom Filter的bit位的长度。</p><p>我们首先来看一个引理：</p><h2 id="Lemma-1"><a href="#Lemma-1" class="headerlink" title="Lemma 1"></a>Lemma 1</h2><blockquote><p>用k个Hash Functions, 将n个元素插入到一个m bits的Bloom Filter中, 则这个Bloom Filter的任意一个bit位为0的概率将不会大于<code>$e^{−\frac{k*n}{m}}$</code></p></blockquote><p>这个Lemma计算Bloom Filter中任意一个bit位为0的概率。</p><p><strong>证明：</strong><br>用一个Hash Function插入一个元素后，某个特定bit位为0的概率为：<code>$1 - \frac 1 m$</code><br>所以，用k个Hash Functions插入一个元素后，某个特定bit位为0的概率为：<code>$\left(1 - {\frac 1 m}\right)^{kn}$</code><br>并且：<br><code>$$\lim_{m\to \infty}{\left(1 - {\frac 1 m}\right)^{kn}} = e^{−\frac{kn}{m}}$$</code></p><h2 id="Lemma-2"><a href="#Lemma-2" class="headerlink" title="Lemma 2"></a>Lemma 2</h2><blockquote><p>假设我们运用Simple Uniform Hashing Functions对Bloom Filter进行插入操作，则这个Bloom Filter的False Positive率p是m，n和k的函数，并且<code>$p = \left(1 - e^{−\frac{kn}{m}}\right)^k$</code></p></blockquote><p><strong>证明：</strong><br>Simple Uniform Hashing函数会将每一个元素以相等的概率hash去m个bit位中的一个。当用一个确定的hash函数处理一个确定的元素，某个特定的bit位<code>$b_x$</code>没有被设置为1的概率为：<code>$1 - {\frac 1 m}$</code><br>所以，当用k个Hash Function来处理这个元素的时候，某个特定的bit位<code>$b_x$</code>没有被设置为1的概率为：<code>$\left(1 - {\frac 1 m}\right)^k$</code><br>然后，当用k个Hash Function来处理n个元素的时候，某个特定的bit位<code>$b_x$</code>没有被设置为1的概率为：<code>$\left(1 - {\frac 1 m}\right)^{kn}$</code><br>相反，这个bit位被设置为1的概率为：<code>$1 - \left(1 - {\frac 1 m}\right)^{kn}$</code></p><p>在查询阶段，如果这个元素在Bloom Filter中对应的的所有hash bits都被设置为了1，则这个元素被认为存在于查询集中。所以False Positive的概率为：<code>$p = \left(1 - \left(1 - {\frac 1 m}\right)^{kn}\right)^k$</code></p><p>鉴于<br><code>$$\lim_{x\to 0}{\left(1 + x\right)^{\frac 1 x}} = e$$</code><br><code>$$\lim_{m\to \infty}{\left(-\frac 1 m\right)} = 0$$</code><br><code>$$\Rightarrow \lim_{m\to \infty}{\left(1 - \left(1 - {\frac 1 m}\right)^{kn}\right)^k} = \lim_{m\to \infty}{\left(1 - \left(1 - {\frac 1 m}\right)^{-m\times{\frac {-kn} m}}\right)^k} = \left(1 - e^{-\frac {nk} m}\right)^k$$</code></p><h2 id="Lemma-3"><a href="#Lemma-3" class="headerlink" title="Lemma 3"></a>Lemma 3</h2><blockquote><p>假设我们用k个hash functions将n个元素插入到一个含有m个bit位的Bloom Filter中，则非0bit位的个数的期望值是：<code>$m\cdot(1-e^{\frac{-kn}{m}})$</code></p></blockquote><p><strong>证明：</strong><br>假设<code>$X_j$</code>是一组随机变量的集合，并且当第j个bit位为0的时候<code>$X_j$</code>=1，反之<code>$X_j$</code>为0。则，根据<strong>Lemma 2</strong>， <code>$E\left[X_j\right] = (1-\frac{1}{m})^{kn} \approx e^{\frac{-kn}{m}}$</code></p><p>假设X为一个代表仍然为0的bit位的个数的随机变量，则：<code>$E\left[X\right] = E\left[\sum_{i=1}^{m} X_i\right] = \sum_{i=1}^{m} E\left[X_i\right] \approx me^{\frac{-kn}{m}} $</code></p><p>所以非0bit位的个数的期望为：<code>$m\cdot(1-e^{\frac{-kn}{m}})$</code></p><p>增加一个Bloom Filter的bit位的个数，可以减少发生Hash Collisions的几率，从而减少False Positive的概率。但是Bloom Filter的位数越多，它所占的硬盘空间就越大。在这里，我们假设，如果一个Bloom Filter一半的bit位被重置为1，则这个Bloom Filter达到了空间和Hash Collisions的平衡（当然这里你可以做其他假设）。 在这个假设前提下，我们可以来计算Bloom Filter主要参数之间的关系。</p><p>假设当一个Bloom Filter达到平衡状态的时候它含有n个元素，则下面这个方程描述了这个Bloom Filter的bit位的个数，与使用的hash function的个数及插入的元素个数之间的关系：<code>$m = \frac{k \cdot n}{50\%} = 2 \cdot k \cdot n $</code> bits</p><h2 id="Lemma-4"><a href="#Lemma-4" class="headerlink" title="Lemma 4"></a>Lemma 4</h2><blockquote><p>当<code>$e^{-\frac{nk}{m}} = \frac{1}{2}$</code>时， False Positive概率p达到最小值。此时：<code>$k = ln2 \times \frac{m}{n}$</code>， <code>$p = \frac{1}{2}^k = 2^{-ln2 \times \frac{m}{n}}$</code></p></blockquote><p><strong>证明：</strong><br>根据<strong>Lemma 2</strong>，<code>$p = (1-e^{-\frac{nk}{m}})^k$</code><br>所以，p可以被认为是k的一个函数：<code>$p = f(k) = (1-e^{-\frac{nk}{m}})^k$</code></p><p>则：<code>$f(k) = (1 - b^{-k})^k$</code>，<code>$b = e^{-\frac{n}{m}}$</code> （1）<br>对方程（1）两边取log值，可以得到：<code>$ln[ f(k)] = k \cdot ln(1-b^{-k})$</code> （2）<br>对方程（2）两边求导，可以得到：<code>$\frac{1}{f(x)} \cdot f’(x) = ln(1-b^{-k}) + k \cdot \frac{1}{1-b^{-k}} \cdot (-1) \cdot (-b^{-k}) \cdot ln(b) = ln(1-b^{-k}) + k \cdot \frac{b^{-k} \cdot ln(b)}{1-b^{-k}}$</code> （3）<br>当方程（3）等于0的时候，方程（2）达到最小值。这时可以得到：<code>$ln(1-b^{-k}) + k \cdot \frac{b^{-k} \cdot ln(b)}{1 - b^{-k}} = 0$</code> （4）<br>有：<code>$(1- b^{-k}) \cdot ln(1- b^{-k}) = b^{-k} \cdot ln(b^{-k})$</code> （5）<br>根据方程（5）两边的对称性，可以得到：<code>${1 - b^{-k}} = b^{-k}$</code> （6）<br>那么：<code>$e^{-\frac{kn}{m}} = \frac{1}{2}$</code> （7）<br>可得：<code>$k = ln2 \cdot \frac{m}{n}$</code> （8）<br>所以：<code>$p = f(k) = (1-\frac{1}{2})^{k} = (\frac{1}{2})^k = 2 ^ {ln2 \cdot \frac{m}{n}}$</code></p><p>由<strong>Lemma 4</strong>可以推出以下<strong>定理</strong>：</p><p>已知一个Bloom Filter的False Positive为p，以及最多需插入元素的个数为n，则这个Bloom Filter的长度应为：<br><code>$$m = - \frac{n \cdot lnp}{(ln2)^2}$$</code><br>需用到的Hash Function的个数应为：<br><code>$$k = ln2 \cdot \frac{m}{n} = log_2\frac{1}{p}$$</code></p><h1 id="Bloom-Filter应用实例"><a href="#Bloom-Filter应用实例" class="headerlink" title="Bloom Filter应用实例"></a>Bloom Filter应用实例</h1><p>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。例如邮件服务器中的垃圾邮件过滤器。在搜索引擎领域，Bloom-Filter最常用于网络蜘蛛(Spider)的URL过滤，网络蜘蛛通常有一个URL列表，保存着将要下载和已经下载的网页的URL，网络蜘蛛下载了一个网页，从网页中提取到新的URL后，需要判断该URL是否已经存在于列表中。此时，Bloom-Filter算法是最好的选择。</p><h2 id="Key-Value加快查询"><a href="#Key-Value加快查询" class="headerlink" title="Key-Value加快查询"></a>Key-Value加快查询</h2><p>一般Bloom-Filter可以与一些key-value的数据库一起使用，来加快查询。</p><p>通常key-value存储系统的values存在硬盘，查询就是件费时的事。将Storage的数据都插入Filter，在Filter中查询都不存在时，那就不需要去Storage查询了。当False Position出现时，只是会导致一次多余的Storage查询。</p><p>由于Bloom-Filter所用的空间非常小，所有BF可以常驻内存。这样子的话，对于大部分不存在的元素，我们只需要访问内存中的Bloom-Filter就可以判断出来了，只有一小部分，我们需要访问在硬盘上的key-value数据库。从而大大地提高了效率。如图：</p><p><img src="/images/KV_search.png" alt="KV_search"></p><h2 id="网络应用"><a href="#网络应用" class="headerlink" title="网络应用"></a>网络应用</h2><ol><li>P2P网络中查找资源操作，可以对每条网络通路保存Bloom Filter，当命中时，则选择该通路访问。</li><li>广播消息时，可以检测某个IP是否已发包。</li><li>检测广播消息包的环路，将Bloom Filter保存在包里，每个节点将自己添加入Bloom Filter。</li><li>信息队列管理，使用Counter Bloom Filter管理信息流量。</li></ol><h2 id="垃圾邮件地址过滤"><a href="#垃圾邮件地址过滤" class="headerlink" title="垃圾邮件地址过滤"></a>垃圾邮件地址过滤</h2><p>像网易，QQ这样的公众电子邮件（email）提供商，总是需要过滤来自发送垃圾邮件的人（spamer）的垃圾邮件。</p><p>一个办法就是记录下那些发垃圾邮件的email地址。由于那些发送者不停地在注册新的地址，全世界少说也有几十亿个发垃圾邮件的地址，将他们都存起来则需要大量的网络服务器。</p><p>如果用哈希表，每存储一亿个email地址，就需要1.6GB的内存（用哈希表实现的具体办法是将每一个email地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有50%，因此一个email地址需要占用十六个字节。一亿个地址大约要1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百GB的内存。</p><p>而Bloom Filter只需要哈希表1/8到1/4 的大小就能解决同样的问题。</p><p>BloomFilter决不会漏掉任何一个在黑名单中的可疑地址。而至于误判问题，常见的补救办法是在建立一个小的白名单，存储那些可能别误判的邮件地址。</p><h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><p>在工作中使用了改进Guava的BloomFilter时，遇到了线程安全性的问题，在此记录一下自己的思考。</p><p><strong>多线程读</strong></p><p>在不存在写请求时，BloomFilter是一个静态的数据结构，此时每个bit位的0-1都不会被改变，所以多线程读是线程安全的。</p><p><strong>多线程写</strong></p><p>在并发写请求到来时，本质上每个写请求都是将BloomFilter的某几位置为1，《深入Java虚拟机》中对于线程安全的定义如下：</p><blockquote><p>当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。</p></blockquote><p>可见在多线程写的过程中，BloomFilter是非线程安全的，这是由于各个写线程调度情况未知，我们无法预测在写过程中BloomFilter每一位的状态。但对于多线程写，BloomFilter是最终线程安全的，也即当所有写请求处理完，生成的BloomFilter的状态是唯一的。</p><p><strong>多线程读写</strong></p><p>无需多言，多线程读写必然是非线程安全的。</p><p>由此我们可以得出一个结论，BloomFilter是非线程安全的。Guava在早些版本的BloomFilter也是非线程安全的，但在<a href="https://github.com/google/guava/wiki/Release23" target="_blank" rel="noopener">Guava Release 23</a>后，社区推出了BloomFilter的线程安全特性。在<a href="https://github.com/google/guava/commit/6092a4a8b1087f92d0c3169b9e96d53c54ca95c4?diff=split" target="_blank" rel="noopener">该版本的commit</a>中，我们可以看到改进后的BloomFilter是通过<strong>AtomicLongArray原子数组</strong>的方式保证线程一致性的，而早现版本的bitArray则是一个普通的long数组，故而有线程安全问题。</p><p>参考<a href="https://sophiesongge.github.io/big/data/2016/09/06/bloom-filter.html" target="_blank" rel="noopener">Bloom Filter详解</a>、<a href="https://blog.csdn.net/v_july_v/article/details/6685894" target="_blank" rel="noopener">海量数据处理之Bloom Filter详解</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP中TIME_WAIT状态详解</title>
      <link href="/2018/07/03/tcp-ip-time-wait/"/>
      <url>/2018/07/03/tcp-ip-time-wait/</url>
      
        <content type="html"><![CDATA[<blockquote><p>TCP的<code>TIME_WAIT</code>状态是什么？谁会有<code>TIME_WAIT</code>状态？<code>TIME_WAIT</code>状态的作用是什么？如何避免大量的<code>TIME_WAIT</code>状态占用过多的系统资源？</p></blockquote><p><code>TIME_WAIT</code>状态是TCP连接中<strong>主动关闭</strong>连接的一方会进入的状态，在发出最后一个ACK包之后，主动关闭方进入<code>TIME_WAIT</code>状态，从而确保ACK包到达对端，以及等待网络中之前迷路的数据包完全消失，防止端口被复用的时候收到迷路包从而出现收包错误。</p><p><code>TIME_WAIT</code>状态会持续2MSL（max segment lifetime）的时间，一般1分钟到4分钟。在这段时间内端口不能被重新分配使用。</p><p><code>TIME_WAIT</code>并不会占用过多的系统资源，但是可以通过修改内核参数/etc/sysctl.conf来限制<code>TIME_WAIT</code>数量。</p><p><img src="/images/time_wait.png" alt="time_wait"></p><h1 id="TIME-WAIT状态原理"><a href="#TIME-WAIT状态原理" class="headerlink" title="TIME_WAIT状态原理"></a>TIME_WAIT状态原理</h1><p>在通信双方建立连接之后，<strong>主动关闭</strong>连接的一方会进入<code>TIME_WAIT</code>状态。Client端主动关闭连接时，会发送最后一个ACK，然后进入<code>TIME_WAIT</code>状态，再停留2个MSL时间，进入<code>CLOSED</code>状态。</p><p>上图以Client端主动关闭连接为例，说明这个过程。</p><h1 id="TIME-WAIT状态存在理由"><a href="#TIME-WAIT状态存在理由" class="headerlink" title="TIME_WAIT状态存在理由"></a>TIME_WAIT状态存在理由</h1><p>TCP/IP协议这样设计，主要有两个原因：</p><h2 id="可靠地实现TCP全双工连接的可靠终止"><a href="#可靠地实现TCP全双工连接的可靠终止" class="headerlink" title="可靠地实现TCP全双工连接的可靠终止"></a>可靠地实现TCP全双工连接的可靠终止</h2><p>TCP协议在关闭连接的四次握手过程中，最终ACK是由主动关闭连接的一端（以下简称A端）发出的，如果这个ACK丢失，对方（以下简称B端）将重发最终的FIN，因此A端就必须维护状态信息<code>TIME_WAIT</code>允许它发送最终的ACK。如果A端不维持<code>TIME_WAIT</code>的状态，而是处于<code>CLOSED</code>状态，那么A端将响应RST（reset）分节，B端收到后将此分节解释成一个异常（Java中会抛出connection reset的SocketException）。因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节中，任何一个分节丢失的情况，主动关闭连接的A端必须维持<code>TIME_WAIT</code>的状态。</p><h2 id="保证此次连接的重复数据段从网络中消失"><a href="#保证此次连接的重复数据段从网络中消失" class="headerlink" title="保证此次连接的重复数据段从网络中消失"></a>保证此次连接的重复数据段从网络中消失</h2><p>TCP分节可能由于路由器异常而“迷路”，在“迷路”期间，TCP发送端可能因确认超时而重发这个分节，“迷路”的分节在路由器恢复正常后也会被发送到最终的目的地，这个迟到的“迷路”分节到达时可能会引起问题。在关闭“前一个连接”之后，马上又建立起一个相同的IP和端口之间的“新连接”，这会导致“前一个连接”的迷路重复分组在“前一个连接”终止后到达，从而被“新连接”接收到了。</p><p>为了避免以上情况，TCP/IP协议不允许处于<code>TIME_WAIT</code>状态的连接启动一个新的可用连接，因为<code>TIME_WAIT</code>状态持续2MSL，这就可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消失。</p><h1 id="MSL时间"><a href="#MSL时间" class="headerlink" title="MSL时间"></a>MSL时间</h1><p>MSL就是max segment lifetime，这是一个IP数据包能在网络中生存的最长时间，超过这个时间，IP数据包将在网络中消失。MSL在<a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC 793</a>中建议是2分钟，而源自Berkeley的TCP实现传统上使用30秒。</p><h1 id="地址reuse问题"><a href="#地址reuse问题" class="headerlink" title="地址reuse问题"></a>地址reuse问题</h1><p>在写一个unix server程序时，经常需要在命令行重启它，绝大多数时候工作正常，但是某些时候会抛出异常“bind: address already in use”，于是重启失败。</p><p>上面这个就是地址reuse问题，就是由于<code>TIME_WAIT</code>状态产生的，我们有以下方案来解决这个问题：</p><h2 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h2><p>这个socket选项通知内核：如果端口忙，但TCP状态位于<code>TIME_WAIT</code>，可以重用端口。</p><blockquote><p>一个socket由相关五元组构成，协议、本地地址、本地端口、远程地址、远程端口。SO_REUSEADDR仅仅表示可以重用本地本地地址、本地端口，整个相关五元组还是唯一确定的。所以，重启后的服务程序有可能收到非期望数据。必须慎重使用SO_REUSEADDR选项。</p></blockquote><p><strong>一般来说，一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。</strong></p><p>SO_REUSEADDR用于对TCP处于<code>TIME_WAIT</code>状态下的socket，才可以重复绑定使用。server程序总是应该在调用bind()之前设置SO_REUSEADDR选项。先调用close()的一方会进入<code>TIME_WAIT</code>状态。</p><p>SO_REUSEADDR允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现，若不设置此选项，则bind时将出错。</p><h2 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h2><p>Linux网络编程中，socket的选项很多。其中几个比较重要的选项就包括SO_LINGER。</p><p>在默认情况下,当调用close()关闭socket的使用，close()会立即返回,但是,如果send buffer中还有数据，系统会试着先把send buffer中的数据发送出去，SO_LINGER选项则是用来修改这种默认操作的。SO_LINGER是一个socket选项，可以通过setsockopt API进行设置，使用起来比较简单，但其实现机制比较复杂，且字面意思上比较难理解。SO_LINGER的值用如下数据结构表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct linger &#123;</span><br><span class="line">int l_onoff &#x2F;&#x2F;0 &#x3D; off, nonzero &#x3D; on(开关)</span><br><span class="line">int l_linger &#x2F;&#x2F;linger time(延迟时间)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其取值和处理如下：</p><ol><li>设置 l_onoff 为0，则该选项关闭，l_linger的值被忽略，等于内核缺省情况，close()调用会立即返回给调用者，如果可能将会传输任何未发送的数据；</li><li>设置 l_onoff 为非0，l_linger为0，当调用close()的时候,TCP连接会立即断开。send buffer中未被发送的数据将被丢弃，并向对方发送一个RST信息。值得注意的是，由于这种方式，不是以4次握手方式结束TCP连接，所以，TCP连接将不会进入TIME_WAIT状态，这样会导致新建立的可能和旧连接的数据造成混乱。这种关闭方式称为“强制”或“失效”关闭。通常会看到“Connection reset by peer”之类的错误；</li><li>设置 l_onoff 为非0，l_linger为非0，在这种情况下，会使得close()返回得到延迟。调用close()去关闭socket的时候，内核将会延迟。也就是说，如果send buffer中还有数据尚未发送，该进程将会被休眠直到一下任何一种情况发生：</li></ol><blockquote><p>a. send buffer中的所有数据都被发送并且得到对方TCP的应答消息；</p></blockquote><blockquote><p>b.延迟时间消耗完。在延迟时间被消耗完之后，send buffer中的所有数据都将会被丢弃。这种关闭称为“优雅的”关闭。</p></blockquote><p>因此，在正常情况下，在socket调用close()之前设置SO_LINGER超时为0都不是个好的选择。但也有些情况下需要使用SO_LINGER：</p><ul><li>如果server返回无效数据或者超时时，SO_LINGER有助于避免卡在<code>CLOSE_WAIT</code>或<code>TIME_WAIT</code>的状态；</li><li>如果必须启动有数千个客户端连接的app，则可以考虑设置SO_LINGER，从而避免数千个socket处于<code>TIME_WAIT</code>状态，从而减少可用端口在服务重启后，新客户端连接收到的影响；</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面的讨论，我们知道<code>TIME_WAIT</code>状态是友好的，并不是多余的，TCP要保证在所有可能的情况下使得所有的数据都能够正确送达。当你关闭一个socket时，主动关闭一端的socket将进入<code>TIME_WAIT</code>状态，而被动关闭的一方则进入<code>CLOSED</code>状态，这的确能够保证所有的数据都被传送。</p><p>当一个socket关闭的时候，是通过两端四次挥手完成的，当一端调用close()时，就说明本端没有数据要传送了，这好像看来在挥手完成以后，socket就可以处于<code>CLOSED</code>状态了，其实不然，原因是这样安排状态有两个问题，首先我们没有任何机制保证最后的一个ACK能够正常传输，第二，网络仍然可能有残余的数据包，我们也必须能够正常处理。TIME_WAIT状态就是为了解决这两个问题而生的。</p><p>服务端为了解决这个TIME_WAIT问题，可选的方式有3种：</p><ol><li>保证由客户端主动发起关闭</li><li>关闭的时候使用RST方式（set SO_LINGER）</li><li>对处于TIME_WAIT状态的TPC允许重用（set SO_REUSEADDR）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java源码解析 —— ConcurrentHashMap</title>
      <link href="/2018/05/10/java-source-ConcurrentHashMap/"/>
      <url>/2018/05/10/java-source-ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<p>这篇日志记录了自己对ConcurrentHashMap的一些总结，由于JDK6，7，8中实现都不同，需要分开阐述在不同版本中的ConcurrentHashMap。</p><p>并发编程实践中，ConcurrentHashMap是一个经常被使用的数据结构，相比于Hashtable以及Collections.synchronizedMap()，ConcurrentHashMap在线程安全的基础上提供了更好的写并发能力，但同时降低了对读一致性的要求。ConcurrentHashMap的设计与实现非常精巧，大量的利用了volatile，final，CAS等lock-free技术来减少锁竞争对于性能的影响，无论对于Java并发编程的学习还是Java内存模型的理解，ConcurrentHashMap的设计以及源码都值得非常仔细的阅读与揣摩。</p><h1 id="JDK-6与JDK-7中的实现"><a href="#JDK-6与JDK-7中的实现" class="headerlink" title="JDK 6与JDK 7中的实现"></a>JDK 6与JDK 7中的实现</h1><p>HashTable是一个线程安全的类，它使用synchronized来锁住整张Hash表来实现线程安全，即每次锁住整张表让线程独占。ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了<strong>锁分离</strong>技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的Hashtable，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p><p>有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>ConcurrentHashMap使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。如下图是ConcurrentHashMap的内部结构图：</p><p><img src="/images/concurrentHashMap.png" alt="concurrentHashMap"></p><p>从图中可以看到，ConcurrentHashMap内部分为很多个Segment，每一个Segment拥有一把锁，然后每个Segment（继承<strong>ReentrantLock</strong>）声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>Segment继承了ReentrantLock，表明每个segment都可以当做一个锁。这样对每个segment中的数据需要同步操作的话都是使用每个segment容器对象自身的锁来实现。只有对全局需要改变时锁定的是所有的segment。</p><p>Segment下面包含很多个HashEntry列表数组。对于一个key，需要经过三次hash操作，才能最终定位这个元素的位置，这三次hash分别为：</p><ol><li>对于一个key，先进行一次hash操作，得到hash值h1，也即h1 = hash1(key)；</li><li>将得到的h1的高几位进行第二次hash，得到hash值h2，也即h2 = hash2(h1高几位)，通过h2能够确定该元素的放在哪个Segment；</li><li>将得到的h1进行第三次hash，得到hash值h3，也即h3 = hash3(h1)，通过h3能够确定该元素放置在哪个HashEntry。</li></ol><p>ConcurrentHashMap中主要实体类就是三个：ConcurrentHashMap（整个Hash表）,Segment（端），HashEntry（节点），对应上面的图可以看出之间的关系。</p><p>不变(Immutable)和易变(Volatile)ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。HashEntry代表每个hash链中的一个节点，其结构如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> K key;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  </span><br><span class="line">    <span class="keyword">volatile</span> V value;  </span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在JDK 6中，HashEntry中的next指针也定义为final，并且每次插入将新添加节点作为链的头节点（同HashMap实现），而且每次删除一个节点时，会将删除节点之前的所有节点<strong>拷贝一份组成一个新的链</strong>，而将当前节点的上一个节点的next指向当前节点的下一个节点，从而在删除以后<strong>有两条链存在</strong>，因而可以保证即使在同一条链中，有一个线程在删除，而另一个线程在遍历，它们都能工作良好，因为遍历的线程能继续使用原有的链。因而这种实现是一种更加细粒度的happens-before关系，即如果遍历线程在删除线程结束后开始，则它能看到删除后的变化，如果它发生在删除线程正在执行中间，则它会使用原有的链，而不会等到删除线程结束后再执行，即看不到删除线程的影响。如果这不符合你的需求，还是乖乖的用Hashtable或HashMap的synchronized版本，Collections.synchronizedMap()做的包装。</p><p>而HashMap中的Entry只有key是final的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br></pre></td></tr></table></figure><p><strong>不变模式</strong>（immutable）是多线程安全里最简单的一种保障方式。因为你拿他没有办法，想改变它也没有机会。不变模式主要通过final关键字来限定的。在JMM中final关键字还有特殊的语义。Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>先看看ConcurrentHashMap的初始化做了哪些事情，构造函数的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的参数有initialCapacity，loadFactor，concurrencyLevel这三个。</p><ul><li>initialCapacity表示新创建的这个ConcurrentHashMap的初始容量，也就是上面的结构图中的Entry数量。默认值为static final int DEFAULT_INITIAL_CAPACITY = 16;</li><li>loadFactor表示负载因子，就是当ConcurrentHashMap中的元素个数大于loadFactor * 最大容量时就需要rehash，扩容。默认值为static final float DEFAULT_LOAD_FACTOR = 0.75f;</li><li>concurrencyLevel表示并发级别，这个值用来确定Segment的个数，Segment的个数是大于等于concurrencyLevel的第一个2的n次方的数。比如，如果concurrencyLevel为12，13，14，15，16这些数，则Segment的数目为16(2的4次方)。默认值为static final int DEFAULT_CONCURRENCY_LEVEL = 16。理想情况下ConcurrentHashMap的真正的并发访问量能够达到concurrencyLevel，因为有concurrencyLevel个Segment，假如有concurrencyLevel个线程需要访问Map，并且需要访问的数据都恰好分别落在不同的Segment中，则这些线程能够无竞争地自由访问（因为他们不需要竞争同一把锁），达到同时访问的效果。这也是为什么这个参数起名为“并发级别”的原因。如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。</li></ul><p>初始化的一些动作：</p><ol><li>验证参数的合法性，如果不合法，直接抛出异常。</li><li>concurrencyLevel也就是Segment的个数不能超过规定的最大Segment的个数，默认值为static final int MAX_SEGMENTS = 1 &lt;&lt; 16;，如果超过这个值，设置为这个值。</li><li>然后使用循环找到大于等于concurrencyLevel的第一个2的n次方的数ssize，这个数就是Segment数组的大小，并记录一共向左按位移动的次数sshift，并令segmentShift = 32 - sshift，并且segmentMask的值等于ssize - 1，segmentMask的各个二进制位都为1，目的是之后可以通过key的hash值与这个值做&amp;运算确定Segment的索引。</li><li>检查给的容量值是否大于允许的最大容量值，如果大于该值，设置为该值。最大容量值为static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30。</li><li>然后计算每个Segment平均应该放置多少个元素，这个值c是向上取整的值。比如初始容量为15，Segment个数为4，则每个Segment平均需要放置4个元素。</li><li>最后创建一个Segment实例，将其当做Segment数组的第一个元素。</li></ol><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>put操作的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作步骤如下：</p><ol><li>判断value是否为null，如果为null，直接抛出异常。</li><li>key通过一次hash运算得到一个hash值。</li><li>将得到hash值向右按位移动segmentShift位，然后再与segmentMask做&amp;运算得到segment的索引j。在初始化的时候我们说过segmentShift的值等于32-sshift，例如concurrencyLevel等于16，则sshift等于4，则segmentShift为28。hash值是一个32位的整数，将其向右移动28位就变成这个样子：0000 0000 0000 0000 0000 0000 0000 xxxx，然后再用这个值与segmentMask做&amp;运算，也就是取最后四位的值。这个值确定Segment的索引。</li><li>使用Unsafe的方式从Segment数组中获取该索引对应的Segment对象。</li><li>向这个Segment对象中put值，这个put操作也基本是一样的步骤（通过&amp;运算获取HashEntry的索引，然后set）。</li></ol><p>put操作是要加锁的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>get操作的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作步骤为：</p><ol><li>和put操作一样，先通过key进行两次hash确定应该去哪个Segment中取数据。</li><li>使用Unsafe获取对应的Segment，然后再进行一次&amp;运算得到HashEntry链表的位置，然后从链表头开始遍历整个链表（因为Hash可能会有碰撞，所以用一个链表保存），如果找到对应的key，则返回对应的value值，如果链表遍历完都没有找到对应的key，则说明Map中不包含该key，返回null。</li></ol><p>值得注意的是，get操作是不需要加锁的（如果value为null，会调用readValueUnderLock，只有这个步骤会加锁），通过前面提到的volatile和final来确保数据安全。</p><h2 id="rehash方法"><a href="#rehash方法" class="headerlink" title="rehash方法"></a>rehash方法</h2><p>相对于HashMap的resize，ConcurrentHashMap的rehash原理类似，但是Doug Lea为rehash做了一定的优化，避免让所有的节点都进行复制操作：由于扩容是基于2的幂指来操作，假设扩容前某HashEntry对应到Segment中数组的index为i，数组的容量为capacity，那么扩容后该HashEntry对应到新数组中的index只可能为i或者i+capacity，因此大多数HashEntry节点在扩容前后index可以保持不变。基于此，rehash方法中会定位第一个后续所有节点在扩容后index都保持不变的节点，然后将这个节点之前的所有节点重排即可。这部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h2><p>size操作与put和get操作最大的区别在于，size操作需要遍历所有的Segment才能算出整个Map的大小，而put和get都只关心一个Segment。假设我们当前遍历的Segment为SA，那么在遍历SA过程中其他的Segment比如SB可能会被修改，于是这一次运算出来的size值可能并不是Map当前的真正大小。所以一个比较简单的办法就是计算Map大小的时候所有的Segment都Lock住，不能更新(包含put，remove等等)数据，计算完之后再Unlock。这是普通人能够想到的方案，但是牛逼的作者还有一个更好的Idea：<strong>先给3次机会</strong>，不lock所有的Segment，遍历所有Segment，累加各个Segment的大小得到整个Map的大小，如果某相邻的两次计算获取的所有Segment的更新的次数（每个Segment都有一个modCount变量，这个变量在Segment中的Entry被修改时会加一，通过这个值可以得到每个Segment的更新操作的次数）是一样的，说明计算过程中没有更新操作，则直接返回这个值。如果这三次不加锁的计算过程中Map的更新次数有变化，则之后的计算先对所有的Segment加锁，再遍历所有Segment计算Map大小，最后再解锁所有Segment。源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><p>一个Map有4个Segment，标记为S1，S2，S3，S4，现在我们要获取Map的size。计算过程是这样的：第一次计算，不对S1，S2，S3，S4加锁，遍历所有的Segment，假设每个Segment的大小分别为1，2，3，4，更新操作次数分别为：2，2，3，1，则这次计算可以得到Map的总大小为1+2+3+4=10，总共更新操作次数为2+2+3+1=8；第二次计算，不对S1,S2,S3,S4加锁，遍历所有Segment，假设这次每个Segment的大小变成了2，2，3，4，更新次数分别为3，2，3，1，因为两次计算得到的Map更新次数不一致(第一次是8，第二次是9)则可以断定这段时间Map数据被更新，则此时应该再试一次；第三次计算，不对S1，S2，S3，S4加锁，遍历所有Segment，假设每个Segment的更新操作次数还是为3，2，3，1，则因为第二次计算和第三次计算得到的Map的更新操作的次数是一致的，就能说明第二次计算和第三次计算这段时间内Map数据没有被更新，此时可以直接返回第三次计算得到的Map的大小。最坏的情况：第三次计算得到的数据更新次数和第二次也不一样，则只能先对所有Segment加锁再计算最后解锁。</p><h2 id="containsValue方法"><a href="#containsValue方法" class="headerlink" title="containsValue方法"></a>containsValue方法</h2><p>containsValue操作采用了和size操作一样的想法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Same idea as size()</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> hashSum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span> &amp;&amp; (tab = seg.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; tab.length; i++) &#123;</span><br><span class="line">                        HashEntry&lt;K,V&gt; e;</span><br><span class="line">                        <span class="keyword">for</span> (e = entryAt(tab, i); e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            V v = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; value.equals(v)) &#123;</span><br><span class="line">                                found = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span> outer;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (retries &gt; <span class="number">0</span> &amp;&amp; sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>ConcurrentHashMap中的key和value值都不能为null，HashMap中key和value可以为null，HashTable中key和value不能为null。</li><li>ConcurrentHashMap是线程安全的类并不能保证使用了ConcurrentHashMap的操作都是线程安全的。</li><li>ConcurrentHashMap的get操作不需要加锁，put操作需要加锁。</li></ul><h1 id="JDK-8中的实现"><a href="#JDK-8中的实现" class="headerlink" title="JDK 8中的实现"></a>JDK 8中的实现</h1><p>ConcurrentHashMap在JDK8中进行了巨大改动。它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现，利用CAS算法。它沿用了与它同时期的HashMap版本的思想，底层依然由“数组”+链表+红黑树的方式思想(JDK7与JDK8中HashMap的实现)，但是为了做到并发，又增加了很多辅助的类，例如TreeBin，Traverser等对象内部类。</p><h2 id="重要的属性"><a href="#重要的属性" class="headerlink" title="重要的属性"></a>重要的属性</h2><p>首先来看几个重要的属性，与HashMap相同的就不再介绍了，这里重点解释一下sizeCtl这个属性。可以说它是ConcurrentHashMap中出镜率很高的一个属性，因为它是一个控制标识符，在不同的地方有不同用途，而且它的取值不同，也代表不同的含义。</p><ul><li>负数代表正在进行初始化或扩容操作</li><li>-1代表正在初始化</li><li>-N表示有N-1个线程正在进行扩容操作</li><li>正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小，这一点类似于扩容阈值的概念。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 盛装Node元素的数组 它的大小是2的整数次幂</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl; </span><br><span class="line"><span class="comment">// 以下两个是用来控制扩容的时候 单线程进入的变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash值是-1，表示这是一个forwardNode节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash值是-2  表示这是一个TreeBin节点</span></span><br></pre></td></tr></table></figure><h2 id="重要的类"><a href="#重要的类" class="headerlink" title="重要的类"></a>重要的类</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node是最核心的内部类，它包装了key-value键值对，所有插入ConcurrentHashMap的数据都包装在这里面。它与HashMap中的定义很相似，但是但是有一些差别它对value和next属性设置了volatile同步锁(与JDK7的Segment相同)，它不允许调用setValue方法直接改变Node的value域，它增加了find方法辅助map.get()方法。</p><h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h3><p>树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap继承自Node类，而并非HashMap中的集成自LinkedHashMap.Entry&lt;K,V&gt;类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。</p><h3 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h3><p>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。</p><h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h3><p>一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A node inserted at head of bins during transfer operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></span><br><span class="line">        outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">                (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> eh; K ek;</span><br><span class="line">                <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</span><br><span class="line">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                        <span class="keyword">continue</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> e.find(h, k);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Unsafe与CAS"><a href="#Unsafe与CAS" class="headerlink" title="Unsafe与CAS"></a>Unsafe与CAS</h2><p>在ConcurrentHashMap中，随处可以看到U, 大量使用了U.compareAndSwapXXX的方法，这个方法是利用一个CAS算法实现无锁化的修改值的操作，他可以大大降低锁代理的性能消耗。这个算法的基本思想就是不断地去比较当前内存中的变量值与你指定的一个变量值是否相等，如果相等，则接受你指定的修改的值，否则拒绝你的操作。因为当前线程中的值已经不是最新的值，你的修改很可能会覆盖掉其他线程修改的结果。</p><h3 id="unsafe静态块"><a href="#unsafe静态块" class="headerlink" title="unsafe静态块"></a>unsafe静态块</h3><p>unsafe代码块控制了一些属性的修改工作，比如最常用的SIZECTL 。在这一版本的concurrentHashMap中，大量应用来的CAS方法进行变量、属性的修改工作。利用<strong>CAS进行无锁操作</strong>，可以大大提高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TRANSFERINDEX;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASECOUNT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLVALUE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABASE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASHIFT;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = ConcurrentHashMap<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        SIZECTL = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">"sizeCtl"</span>));</span><br><span class="line">        TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">"transferIndex"</span>));</span><br><span class="line">        BASECOUNT = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">"baseCount"</span>));</span><br><span class="line">        CELLSBUSY = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">"cellsBusy"</span>));</span><br><span class="line">        Class&lt;?&gt; ck = CounterCell<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        CELLVALUE = U.objectFieldOffset</span><br><span class="line">            (ck.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        Class&lt;?&gt; ak = Node[]<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">        <span class="keyword">int</span> scale = U.arrayIndexScale(ak);</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"data type scale not a power of two"</span>);</span><br><span class="line">        ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三个核心方法"><a href="#三个核心方法" class="headerlink" title="三个核心方法"></a>三个核心方法</h3><p>ConcurrentHashMap定义了三个原子操作，用于对指定位置的节点进行操作。正是这些原子操作保证了ConcurrentHashMap的线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得在i位置上的Node节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用CAS算法设置i位置上的Node节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用volatile方法设置节点位置的值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化方法initTable"><a href="#初始化方法initTable" class="headerlink" title="初始化方法initTable"></a>初始化方法initTable</h2><p>对于ConcurrentHashMap来说，调用它的构造方法仅仅是设置了一些参数而已。而整个table的初始化是在向ConcurrentHashMap中插入元素的时候发生的。如调用put、computeIfAbsent、compute、merge等方法的时候，调用时机是检查table==null。</p><p>初始化方法主要应用了关键属性sizeCtl 如果这个值小于0，表示其他线程正在进行初始化，就放弃这个操作。在这也可以看出ConcurrentHashMap的初始化只能由一个线程完成。如果获得了初始化权限，就用CAS方法将sizeCtl置为-1，防止其他线程进入。初始化数组后，将sizeCtl的值改为0.75*n。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//sizeCtl表示有其他线程正在进行初始化操作，把线程挂起。对于table的初始化工作，只能有一个线程在进行。</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;<span class="comment">//利用CAS方法把sizectl的值置为-1 表示本线程正在进行初始化</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);<span class="comment">//相当于0.75*n 设置一个扩容的阈值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容方法transfer"><a href="#扩容方法transfer" class="headerlink" title="扩容方法transfer"></a>扩容方法transfer</h2><p>当ConcurrentHashMap容量不足的时候，需要对table进行扩容。这个方法的基本思想跟HashMap是很像的，但是由于它是支持并发扩容的，所以要复杂的多。原因是它支持多线程进行扩容操作，而并没有加锁。我想这样做的目的不仅仅是为了满足concurrent的要求，而是希望利用并发处理去减少扩容带来的时间影响。因为在扩容的时候，总是会涉及到从一个“数组”到另一个“数组”拷贝的操作，如果这个操作能够并发进行，那真真是极好的了。</p><p>整个扩容操作分为两个部分</p><ul><li>第一部分是构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。这个单线程的保证是通过RESIZE_STAMP_SHIFT这个常量经过一次运算来保证的，这个地方在后面会有提到；</li><li>第二个部分就是将原来table中的元素复制到nextTable中，这里允许多线程进行操作。</li></ul><p><strong>先来看一下单线程是如何完成的：</strong></p><p>它的大体思想就是遍历、复制的过程。首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素：</p><ul><li>如果这个位置为空，就在原table中的i位置放入forwardNode节点，这个也是触发并发扩容的关键点；</li><li>如果这个位置是Node节点（fh&gt;=0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</li><li>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上</li><li>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。</li></ul><p><strong>再看一下多线程是如何完成的：</strong></p><p>在代码的68行有一个判断，如果遍历到的节点是forward节点，就向后继续遍历，再加上给节点上锁的机制，就完成了多线程的控制。多线程遍历节点，处理了一个节点，就把对应点的值set为forward，另一个线程看到forward，就向后遍历。这样交叉就完成了复制工作。而且还很好的解决了线程安全的问题。</p><p><img src="/images/multi_thread_transfer.png" alt="multi_thread_transfer"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 一个过渡的table表  只有在扩容的时候才会使用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment">    * above for explanation.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">       <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">           stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">       <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];<span class="comment">//构造一个nextTable对象 它的容量是原来的两倍</span></span><br><span class="line">               nextTab = nt;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">               sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           nextTable = nextTab;</span><br><span class="line">           transferIndex = n;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">       ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);<span class="comment">//构造一个连节点指针 用于标志位</span></span><br><span class="line">       <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;<span class="comment">//并发扩容的关键属性 如果等于true 说明这个节点已经处理过</span></span><br><span class="line">       <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">           <span class="comment">//这个while循环体的作用就是在控制i--  通过i--可以依次遍历原hash表中的节点</span></span><br><span class="line">           <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">               <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">               <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                   advance = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   i = -<span class="number">1</span>;</span><br><span class="line">                   advance = <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                        (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                         nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                      nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                   bound = nextBound;</span><br><span class="line">                   i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                   advance = <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">               <span class="keyword">int</span> sc;</span><br><span class="line">               <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                   <span class="comment">//如果所有的节点都已经完成复制工作  就把nextTable赋值给table 清空临时对象nextTable</span></span><br><span class="line">                   nextTable = <span class="keyword">null</span>;</span><br><span class="line">                   table = nextTab;</span><br><span class="line">                   sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);<span class="comment">//扩容阈值设置为原来容量的1.5倍  依然相当于现在容量的0.75倍</span></span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//利用CAS方法更新这个扩容阈值，在这里面sizectl值减一，说明新加入一个线程参与到扩容操作</span></span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                   i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果遍历到的节点为空 则放入ForwardingNode指针</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">               advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">           <span class="comment">//如果遍历到ForwardingNode节点  说明这个点已经被处理过了 直接跳过  这里是控制并发扩容的核心</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">               advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//节点上锁</span></span><br><span class="line">               <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                       Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                       <span class="comment">//如果fh&gt;=0 证明这是一个Node节点</span></span><br><span class="line">                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                           <span class="comment">//以下的部分在完成的工作是构造两个链表  一个是原链表  另一个是原链表的反序排列</span></span><br><span class="line">                           Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                               <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                               <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                   runBit = b;</span><br><span class="line">                                   lastRun = p;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                               ln = lastRun;</span><br><span class="line">                               hn = <span class="keyword">null</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               hn = lastRun;</span><br><span class="line">                               ln = <span class="keyword">null</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                               <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                               <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                   ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">//在nextTable的i位置上插入一个链表</span></span><br><span class="line">                           setTabAt(nextTab, i, ln);</span><br><span class="line">                           <span class="comment">//在nextTable的i+n的位置上插入另一个链表</span></span><br><span class="line">                           setTabAt(nextTab, i + n, hn);</span><br><span class="line">                           <span class="comment">//在table的i位置上插入forwardNode节点  表示已经处理过该节点</span></span><br><span class="line">                           setTabAt(tab, i, fwd);</span><br><span class="line">                           <span class="comment">//设置advance为true 返回到上面的while循环中 就可以执行i--操作</span></span><br><span class="line">                           advance = <span class="keyword">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//对TreeBin对象进行处理  与上面的过程类似</span></span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                           TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                           TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                           TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                           <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                           <span class="comment">//构造正序和反序两个链表</span></span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                               <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                               TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                   (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                               <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                   <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                       lo = p;</span><br><span class="line">                                   <span class="keyword">else</span></span><br><span class="line">                                       loTail.next = p;</span><br><span class="line">                                   loTail = p;</span><br><span class="line">                                   ++lc;</span><br><span class="line">                               &#125;</span><br><span class="line">                               <span class="keyword">else</span> &#123;</span><br><span class="line">                                   <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                       hi = p;</span><br><span class="line">                                   <span class="keyword">else</span></span><br><span class="line">                                       hiTail.next = p;</span><br><span class="line">                                   hiTail = p;</span><br><span class="line">                                   ++hc;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">//如果扩容后已经不再需要tree的结构 反向转换为链表结构</span></span><br><span class="line">                           ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                               (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                           hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                               (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            <span class="comment">//在nextTable的i位置上插入一个链表    </span></span><br><span class="line">                           setTabAt(nextTab, i, ln);</span><br><span class="line">                           <span class="comment">//在nextTable的i+n的位置上插入另一个链表</span></span><br><span class="line">                           setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">//在table的i位置上插入forwardNode节点  表示已经处理过该节点</span></span><br><span class="line">                           setTabAt(tab, i, fwd);</span><br><span class="line">                           <span class="comment">//设置advance为true 返回到上面的while循环中 就可以执行i--操作</span></span><br><span class="line">                           advance = <span class="keyword">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a>put方法</h2><p>前面的所有的介绍其实都为这个方法做铺垫。ConcurrentHashMap最常用的就是put和get两个方法。现在来介绍put方法，这个put方法依然沿用HashMap的put方法的思想，根据hash值计算这个新插入的点在table中的位置i，如果i位置是空的，直接放进去，否则进行判断，如果i位置是树节点，按照树的方式插入新的节点，否则把i插入到链表的末尾。ConcurrentHashMap中依然沿用这个思想，有一个最重要的不同点就是ConcurrentHashMap不允许key或value为null值。另外由于涉及到多线程，put方法就要复杂一点。在多线程中可能有以下两个情况:</p><ol><li>如果一个或多个线程正在对ConcurrentHashMap进行扩容操作，当前线程也要进入扩容的操作中。这个扩容的操作之所以能被检测到，是因为transfer方法中在空结点上插入forward节点，如果检测到需要插入的位置被forward节点占有，就帮助进行扩容；</li><li>如果检测到要插入的节点是非空且不是forward节点，就对这个节点加锁，这样就保证了线程安全。尽管这个有一些影响效率，但是还是会比hashTable的synchronized要好得多。</li></ol><p>整体流程就是首先定义不允许key或value为null的情况放入，对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在table中的位置。</p><p>如果这个位置是空的，那么直接放入，而且不需要加锁操作。如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。如果是链表节点（fh&gt;0）,则得到的结点就是hash值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到hash值与key值都与新加入节点是一致的情况，则只需要更新value值即可。否则依次向后遍历，直到链表尾插入这个结点。如果加入这个节点以后链表长度大于8，就把这个链表转换成红黑树。如果这个节点的类型已经是树节点的话，直接调用树节点的插入方法进行插入新的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//不允许 key或value为null</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//计算hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//死循环 何时插入成功 何时跳出</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="comment">//如果table为空的话，初始化table</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="comment">//根据hash值计算出在table里面的位置 </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果这个位置没有值 ，直接放进去，不需要加锁</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当遇到表连接点时，需要进行整合表的操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//结点上锁  这里的结点可以理解为hash值相同组成的链表的头结点</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="comment">//fh〉0 说明这个节点是一个链表的节点 不是树的节点</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="comment">//在这里遍历链表所有的结点</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="comment">//如果hash值和key值相同  则修改对应结点的value值</span></span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="comment">//如果遍历到了最后一个结点，那么就证明新的节点需要插入 就把它插入在链表尾部</span></span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果这个节点是树节点，就按照树的方式插入值</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果链表长度已经达到临界值8 就需要把链表转换为树结构</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将当前ConcurrentHashMap的元素数量+1</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以发现JDK8中的实现也是锁分离的思想，只是锁住的是一个Node，而不是JDK7中的Segment，而锁住Node之前的操作是无锁的并且也是线程安全的，建立在之前提到的3个原子操作上。</p><h3 id="helpTransfer方法"><a href="#helpTransfer方法" class="headerlink" title="helpTransfer方法"></a>helpTransfer方法</h3><p>这是一个协助扩容的方法。这个方法被调用的时候，当前ConcurrentHashMap一定已经有了nextTable对象，首先拿到这个nextTable对象，调用transfer方法。回看上面的transfer方法可以看到，当本线程进入扩容方法的时候会直接进入复制阶段。</p><h3 id="treeifyBin方法"><a href="#treeifyBin方法" class="headerlink" title="treeifyBin方法"></a>treeifyBin方法</h3><p>这个方法用于将过长的链表转换为TreeBin对象。但是他并不是直接转换，而是进行一次容量判断，如果容量没有达到转换的要求，直接进行扩容操作并返回；如果满足条件才链表的结构抓换为TreeBin ，这与HashMap不同的是，它并没有把TreeNode直接放入红黑树，而是利用了TreeBin这个小容器来封装所有的TreeNode。</p><h2 id="get方法-1"><a href="#get方法-1" class="headerlink" title="get方法"></a>get方法</h2><p>get方法比较简单，给定一个key来确定value的时候，必须满足两个条件：key相同，hash值相同，对于节点可能在链表或树上的情况，需要分别去查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">        <span class="comment">//计算hash值</span></span><br><span class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">        <span class="comment">//根据hash值确定节点位置</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果搜索到的节点key与传入的key相同且不为null,直接返回这个节点  </span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果eh&lt;0 说明这个节点在树上 直接寻找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">//否则遍历链表 找到对应的值并返回</span></span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="size相关方法"><a href="#size相关方法" class="headerlink" title="size相关方法"></a>size相关方法</h2><p>对于ConcurrentHashMap来说，这个table里到底装了多少东西其实是个不确定的数量，因为不可能在调用size()方法的时候像GC的“stop the world”一样让其他线程都停下来让你去统计，因此只能说这个数量是个估计值。对于这个估计值，ConcurrentHashMap也是大费周章才计算出来的。</p><h3 id="辅助定义"><a href="#辅助定义" class="headerlink" title="辅助定义"></a>辅助定义</h3><p>为了统计元素个数，ConcurrentHashMap定义了一些变量和一个内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A padded cell for distributing counts.  Adapted from LongAdder</span></span><br><span class="line"><span class="comment">     * and Striped64.  See their internal docs for explanation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">        CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际上保存的是hashmap中的元素个数  利用CAS锁进行更新</span></span><br><span class="line"><span class="comment">     但它并不用返回当前hashmap的元素个数 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Table of counter cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><h3 id="mappingCount与Size方法"><a href="#mappingCount与Size方法" class="headerlink" title="mappingCount与Size方法"></a>mappingCount与Size方法</h3><p>mappingCount与size方法的类似。从Java工程师给出的注释来看，应该使用mappingCount代替size方法，两个方法都没有直接返回basecount，而是统计一次这个值，而这个值其实也是一个大概的数值，因此可能在统计的时候有其他线程正在执行插入或删除操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = sumCount();</span><br><span class="line">        <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">                (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">                (<span class="keyword">int</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of mappings. This method should be used</span></span><br><span class="line"><span class="comment">     * instead of &#123;<span class="doctag">@link</span> #size&#125; because a ConcurrentHashMap may</span></span><br><span class="line"><span class="comment">     * contain more mappings than can be represented as an int. The</span></span><br><span class="line"><span class="comment">     * value returned is an estimate; the actual count may differ if</span></span><br><span class="line"><span class="comment">     * there are concurrent insertions or removals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of mappings</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mappingCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = sumCount();</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0L</span>) ? <span class="number">0L</span> : n; <span class="comment">// ignore transient negative values</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">        <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                    sum += a.value;<span class="comment">//所有counter的值求和</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="addCount方法"><a href="#addCount方法" class="headerlink" title="addCount方法"></a>addCount方法</h3><p>在put方法结尾处调用了addCount方法，把当前ConcurrentHashMap的元素个数+1。这个方法一共做了两件事，更新baseCount的值，检测是否进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">        CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">        <span class="comment">//利用CAS方法更新baseCount的值 </span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">            !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">            CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果check值大于等于0 则需要检验是否需要进行扩容操作</span></span><br><span class="line">        <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">            <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                     <span class="comment">//如果已经有其他线程在执行扩容操作</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前线程是唯一的或是第一个发起扩容的线程  此时nextTable=null</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JDK6,7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度，把HashMap分割成若干个Segment，在put的时候需要锁住Segment，get时候不加锁，使用volatile来保证可见性，当要统计全局时（比如size），首先会尝试多次计算modcount来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回size。如果有，则需要依次锁住所有的Segment来计算。</p><p>JDK 7中ConcurrentHashmap中，当长度过长碰撞会很频繁，链表的增改删查操作都会消耗很长的时间，影响性能,所以JDK 8中完全重写了concurrentHashmap，代码量从原来的1000多行变成了6000多行，实现上也和原来的分段式存储有很大的区别。</p><p>主要设计上的变化有以下几点:</p><ol><li>不采用segment而采用node，锁住node来实现减小锁粒度。</li><li>设计了MOVED状态。当resize的过程中，线程2还在put数据，线程2会帮助resize。</li><li>使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。</li><li>sizeCtl的不同值来代表不同含义，起到了控制的作用。</li></ol><p>至于为什么JDK8中使用synchronized而不是ReentrantLock，我猜是因为JDK 8中对synchronized有了足够的优化吧。</p><p>参考：</p><ul><li><a href="https://my.oschina.net/hosee/blog/639352" target="_blank" rel="noopener">ConcurrentHashMap原理分析</a></li><li><a href="http://www.importnew.com/22007.html" target="_blank" rel="noopener">ConcurrentHashMap总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> source code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java源码解析 —— HashSet</title>
      <link href="/2018/05/07/java-source-HashSet/"/>
      <url>/2018/05/07/java-source-HashSet/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天来介绍下HashSet。前面，我们已经系统的对List和Map进行了学习。接下来，我们开始可以学习Set。相信经过Map的了解之后，学习Set会容易很多。毕竟，Set的实现类都是基于Map来实现的(HashSet是通过HashMap实现的)。</p><p>构造图如下:<br>蓝色线条：继承<br>绿色线条：接口实现</p><p><img src="/images/HashSet.png" alt="HashSet"></p><h1 id="HashSet简介"><a href="#HashSet简介" class="headerlink" title="HashSet简介"></a>HashSet简介</h1><p>对于HashSet而言，它是基于HashMap来实现的，底层采用HashMap来保存元素。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>HashSet是一个<strong>没有重复元素的集合</strong>。<br>它是由HashMap实现的，<strong>不保证元素的顺序</strong>，而且<strong>HashSet允许使用null元素</strong>。<br>HashSet是<strong>非同步的</strong>。如果多个线程同时访问一个hashSet，而其中至少一个线程修改了该set，那么它必须保持外部同步。这通常是通过对自然封装该set的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet方法来“包装”set。最好在创建时完成这一操作，以防止对该set进行意外的不同步访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set s = Collections.synchronizedSet(<span class="keyword">new</span> HashSet(...));</span><br></pre></td></tr></table></figure><p>HashSet通过iterator()返回的<strong>迭代器是fail-fast的</strong>。</p><h2 id="HashSet属性"><a href="#HashSet属性" class="headerlink" title="HashSet属性"></a>HashSet属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层使用HashMap来保存HashSet的元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="comment">// 由于Set只使用到了HashMap的key，所以此处定义一个静态的常量Object类，来充当HashMap的value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>看到这里就明白了，和我们前面说的一样，HashSet是用HashMap来保存数据，而主要使用到的就是HashMap的key。</p><p>看到<code>private static final Object PRESENT = new Object();</code>不知道你有没有一点疑问呢。这里使用一个静态的常量Object类来充当HashMap的value，既然这里map的value是没有意义的，为什么不直接使用null值来充当value呢？比如写成这样子<code>private final Object PRESENT = null</code>;我们都知道的是，Java首先将变量PRESENT分配在栈空间，而将new出来的Object分配到堆空间，这里的new Object()是占用堆内存的（一个空的Object对象占用8byte），而null值我们知道，是不会在堆空间分配内存的。那么想一想这里为什么不使用null值。想到什么吗，看一个异常类java.lang.NullPointerException，Java号称没有指针，但是处处碰到NullPointerException。所以为了从根源上避免NullPointerException的出现，采用浪费8个byte，在下面的代码中就不会出现if (xxx == null) { … } else {….}。</p><h2 id="HashSet构造函数"><a href="#HashSet构造函数" class="headerlink" title="HashSet构造函数"></a>HashSet构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用HashMap的默认容量大小16和默认加载因子0.75初始化map，构造一个HashSet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个指定Collection参数的HashSet，这里不仅仅是Set，只要实现Collection接口的容器都可以</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(Math. max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">   <span class="comment">// 使用Collection实现的Iterator迭代器，将集合c的元素一个个加入HashSet中</span></span><br><span class="line">   addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的初始容量大小和加载因子初始化map，构造一个HashSet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的初始容量大小和默认的加载因子0.75初始化map，构造一个HashSet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不对外公开的一个构造方法（默认default修饰），底层构造的是LinkedHashMap，dummy只是一个标示参数，无具体意义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="增加和删除"><a href="#增加和删除" class="headerlink" title="增加和删除"></a>增加和删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用HashMap的put方法实现add方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用HashMap的remove方法实现remove方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一个集合到HashSet中，该方法在AbstractCollection中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">   <span class="comment">// 取得集合c迭代器Iterator</span></span><br><span class="line">   Iterator&lt;? extends E&gt; e = c.iterator();</span><br><span class="line">   <span class="comment">// 遍历迭代器</span></span><br><span class="line">    <span class="keyword">while</span> (e.hasNext()) &#123;</span><br><span class="line">       <span class="comment">// 将集合c的每个元素加入到HashSet中</span></span><br><span class="line">       <span class="keyword">if</span> (add(e.next()))</span><br><span class="line">          modified = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定集合c中的所有元素，该方法在AbstractSet中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前HashSet元素个数和指定集合c的元素个数，目的是减少遍历次数</span></span><br><span class="line">    <span class="keyword">if</span> (size() &gt; c.size()) &#123;</span><br><span class="line">        <span class="comment">// 如果当前HashSet元素多，则遍历集合c，将集合c中的元素一个个删除</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;?&gt; i = c.iterator(); i.hasNext(); )</span><br><span class="line">            modified |= remove(i.next());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果集合c元素多，则遍历当前HashSet，将集合c中包含的元素一个个删除</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;?&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.contains(i.next())) &#123;</span><br><span class="line">                i.remove();</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="是否包含"><a href="#是否包含" class="headerlink" title="是否包含"></a>是否包含</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用HashMap的containsKey方法实现contains方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查是否包含指定集合中所有元素，该方法在AbstractCollection中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 取得集合c的迭代器Iterator</span></span><br><span class="line">   Iterator&lt;?&gt; e = c.iterator();</span><br><span class="line">   <span class="comment">// 遍历迭代器，只要集合c中有一个元素不属于当前HashSet，则返回false</span></span><br><span class="line">    <span class="keyword">while</span> (e.hasNext())</span><br><span class="line">       <span class="keyword">if</span> (!contains(e.next()))</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于HashMap基于hash表实现，hash表实现的容器最重要的一点就是可以快速存取，那么HashSet对于contains方法，利用HashMap的containsKey方法，效率是非常之快的。</p><h2 id="容量检查"><a href="#容量检查" class="headerlink" title="容量检查"></a>容量检查</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of elements in this set (its cardinality).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashSet遍历方式"><a href="#HashSet遍历方式" class="headerlink" title="HashSet遍历方式"></a>HashSet遍历方式</h2><p><strong>通过Iterator遍历HashSet</strong></p><ol><li>根据iterator()获取HashSet的迭代器。</li><li>遍历迭代器获取各个元素。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator iterator = set.iterator();</span><br><span class="line">       iterator.hasNext(); ) &#123; </span><br><span class="line">    iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过for-each遍历HashSet</strong></p><ol><li>根据toArray()获取HashSet的元素集合对应的数组。</li><li>遍历数组，获取各个元素。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = (String[])set.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (String str : arr)</span><br><span class="line">    System.out.printf(<span class="string">"for each : %s\n"</span>, str);</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="HashSet和HashMap的区别"><a href="#HashSet和HashMap的区别" class="headerlink" title="HashSet和HashMap的区别"></a>HashSet和HashMap的区别</h2><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>HashMap实现了Map接口</td><td>HashSet实现了Set接口</td></tr><tr><td>HashMap存储键值对KV</td><td>HashSet仅仅存储对象</td></tr><tr><td>使用put()方法将元素放进map中</td><td>使用add()方法将元素放到set中</td></tr><tr><td>HashMap使用key对象来计算hashcode值</td><td>HashSet中使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以用equals()方法来判断对象的相等性，如果两个对象不同返回false</td></tr><tr><td>HashMap比较快，因为用唯一的key来获取对象</td><td>较HashMap来说比较慢</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> source code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java源码解析 —— Map总结</title>
      <link href="/2018/04/28/java-source-Map/"/>
      <url>/2018/04/28/java-source-Map/</url>
      
        <content type="html"><![CDATA[<h1 id="各类Map详解"><a href="#各类Map详解" class="headerlink" title="各类Map详解"></a>各类Map详解</h1><p>Map接口定义了一个保存key-value的对象，该对象中key值是不存在重复的，每个key值至多对应一个value。</p><p>在前面几篇的文章中分别介绍了Map的实现类，如HashMap、Hashtable、TreeMap，详细可以查看：</p><ul><li><a href="https://sagittariusyx.github.io/2017/03/19/java-source-HashMap/" target="_blank" rel="noopener">Java源码解析 —— HashMap</a></li><li><a href="https://sagittariusyx.github.io/2017/03/21/java-source-HashTable/" target="_blank" rel="noopener">Java源码解析 —— HashTable</a></li><li><a href="https://sagittariusyx.github.io/2017/04/09/java-source-TreeMap/" target="_blank" rel="noopener">Java源码解析 —— TreeMap</a></li></ul><h1 id="类图结构"><a href="#类图结构" class="headerlink" title="类图结构"></a>类图结构</h1><p><img src="/images/Map.png" alt="Map"></p><p>如上图所示是实现Map接口的类图结构，主要包含了如下的类与接口：</p><ul><li>Map接口：定义将键值映射到值的对象，Map规定不能包含重复的键值，每个键最多可以映射一个值,这个接口是用来替换Dictionary类。</li><li>AbstractMap类：提供了一个Map骨架的实现,尽量减少了实现Map接口所需要的工作量</li><li>HashMap类：HashMap是实现了Map接口的key-value集合，实现了所有map的操作，允许key和value为null,它相当于Hashtable，与之存在的区别是hashMap不是线程安全的，HashMap允许null值。</li><li>TreeMap类：TreeMap是基于红黑树的实现，也是记录了key-value的映射关系，该映射根据key的自然排序进行排序或者根据构造方法中传入的比较器进行排序，也就是说TreeMap是有序的key-value集合</li><li>Hashtable类：它是类似与HashMap的key-value的哈希表，不允许key-value为NULL值，另外一点值得注意的是Hashtable是线程安全的</li><li>Serializable接口：实现了该接口标识了类可以被序列化和反序列化，具体的 查询序列化详解</li><li>Cloneable接口：实现了该接口的类可以显示的调用Object.clone()方法，合法的对该类实例进行字段复制，如果没有实现Cloneable接口的实例上调用Obejct.clone()方法，会抛出CloneNotSupportException异常。正常情况下，实现了Cloneable接口的类会以公共方法重写Object.clone()</li></ul><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>虽然HashMap、Hashtable、TreeMap这三个都是Map接口的实现，其内部实现及性能等还是存在区别，下面将从区别及性能两个方面去分析。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul><li>HashMap：初始化容量为16，扩容每次为2 * oldCap, key-value可以为NULL值</li><li>Hashtable：初始化容量为11，扩容每次为2 * oldCap + 1, key-value不可以为NULL值</li><li>TreeMap：初始化容量为0，内部是红黑树结构，不存在hash冲突的情况，不存在扩容的操作, key-value不可以为NULL值</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>HashMap：实现了Map接口，继承了AbstractMap类</li><li>Hashtable：实现了Map接口，继承了AbstractMap类</li><li>TreeMap：由于TreeMap是有序的，所以其除了实现了Map接口，还实现了SortedMap、NavigableMap接口</li></ul><h3 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h3><ul><li>HashMap：HashMap是散列表实现，内部是数组+链表或者红黑树的结构</li><li>Hashtable：Hashtable也是散列表实现，内部是数组+链表的结构</li><li>TreeMap：TreeMap内部是红黑树的结构</li></ul><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><ul><li>HashMap：不是线程安全的，其实通过<code>Map m = Collections.synchronizeMap(hashMap)</code>的方式也可以使得HashMap变成线程安全的，但是这样做对程序的性能可能是噩梦，在后面会介绍ConcurrentHashMap，建议在多线程的情况下可以使用ConcurrentHashMap替换HashMap</li><li>Hashtable：是线程安全的，内部方法使用关键字synchronized修饰</li><li>TreeMap：不是线程安全的</li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>按照如下代码对HashMap、Hashtable、TreeMap的性能进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapProgress</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义用于测试的HashMap</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//定义用于测试的Hashtable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hashtable&lt;Integer,Integer&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">    <span class="comment">//定义用于测试的TreeMap</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeMap&lt;Integer,Integer&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应的map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 添加个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(Map&lt;Integer,Integer&gt; map, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            map.put(i,i);</span><br><span class="line">        &#125;</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"添加("</span> + count + <span class="string">")个元素使用时间:"</span> + (endTime - startTime) + <span class="string">"s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取元素的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getEntry</span><span class="params">(Map&lt;Integer,Integer&gt; map, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            map.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"获取("</span> + count + <span class="string">")个元素使用时间:"</span> + (endTime - startTime) + <span class="string">"s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-------HashMap测试开始-----"</span>);</span><br><span class="line">        addEntry(hashMap,<span class="number">1000000</span>);</span><br><span class="line">        getEntry(hashMap,<span class="number">1000000</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------HashMap测试结束-----"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------Hashtable测试开始-----"</span>);</span><br><span class="line">        addEntry(hashtable,<span class="number">1000000</span>);</span><br><span class="line">        getEntry(hashtable,<span class="number">1000000</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------Hashtable测试结束-----"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------TreeMap测试开始-----"</span>);</span><br><span class="line">        addEntry(treeMap,<span class="number">1000000</span>);</span><br><span class="line">        getEntry(treeMap,<span class="number">1000000</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------TreeMap测试结束-----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别测试了100000, 1000000, 10000000个数据的情况，测试结果如下所示：</p><table><thead><tr><th>数据量</th><th>HashMap</th><th>HashTable</th><th>TreeMap</th></tr></thead><tbody><tr><td>100000</td><td>插入用时：18s 查询用时：9s</td><td>插入用时：14s 查询用时：5s</td><td>插入用时：33s 查询用时：17s</td></tr><tr><td>1000000</td><td>插入用时：98s 查询用时：20s</td><td>插入用时：625s 查询用时：31s</td><td>插入用时：242s 查询用时： 145s</td></tr><tr><td>1000000</td><td>插入用时：9773s 查询用时：811s</td><td>插入用时：15055s 查询用时：3369s</td><td>插入用时：22354s 查询用时： 3889s</td></tr></tbody></table><p>通过上表可以看出随着数据量的增加，时间变化差异还是很大的，而在单线程的情况下还是尽量使用HashMap，相对于Hashtable、TreeMap性能更好，而针对特定的情况需视情况而论。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> source code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用GPB协议</title>
      <link href="/2018/04/23/google-protocol-buffer/"/>
      <url>/2018/04/23/google-protocol-buffer/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要使用GPB协议"><a href="#为什么要使用GPB协议" class="headerlink" title="为什么要使用GPB协议"></a>为什么要使用GPB协议</h1><p>GPB（Google Protocol Buffer）协议，与常用的数据通讯、存储方式相比，优点如下：</p><ul><li>跨平台（语言）：相比于Java序列化、Python的pickle序列化工具，GPB是独立于语言的，如果项目对这方面有要求，GPB就脱颖而出了。序列化还有一个问题，如果你改了数据结构，很容易造成序列化失败。</li><li>快：采用类似二进制的协议，更加高效。这一点主要是相比于XML、JSON这两种常用的数据标准而言的。</li><li>扩展性、维护性：在后续扩展协议的时候，GPB可以很好的兼容；协议源文件跟随代码做版本控制，容易维护。</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>结合Python的google.protobuf模块做一些深入讨论。</p><p>首先新建一个文件<code>person.proto</code>，假设这个是某接口的通讯协议——要传name和id两个Field（都是必填字段）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message PERSON &#123;</span><br><span class="line">    required string name = <span class="number">4</span>;</span><br><span class="line">    required int32 id = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个协议的源文件，Python还不能直接使用，需要通过工具编译成 py 文件才能用。不像XML、JSON直接用纯文本文件，它还要多经过一步“编译过程”以适应不同的程序语言（C++、Java、Python）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I&#x3D;. --python_out&#x3D;.&#x2F;GPB GPB&#x2F;person.proto</span><br></pre></td></tr></table></figure><p>执行后会发现GPB子目录下多了一个文件<code>person_pb2.py</code>，这个文件就是 <code>person.proto</code>经过编译得到的文件，可以直接在Python中引用。下面用几行代码实现写入一个PERSON对象，然后再读出来，中途把GPB字符串的原始内容打印出来（注意两个核心方法<code>SerializeToString</code>、<code>ParseFromString</code>都是<code>google.protobuf</code>模块提供的）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> GPB <span class="keyword">import</span> person_pb2</span><br><span class="line"></span><br><span class="line">person_write = person_pb2.PERSON(name = <span class="string">'shaw'</span>, id = <span class="number">15</span>)</span><br><span class="line">s = person_write.SerializeToString()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> len(s), <span class="string">"%r"</span> % s</span><br><span class="line"></span><br><span class="line">person_read = person_pb2.PERSON()</span><br><span class="line">person_read.ParseFromString(s)</span><br><span class="line"><span class="keyword">print</span> person_read</span><br></pre></td></tr></table></figure><p>可以看到输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="string">'"\x04shaw(\x0f'</span></span><br><span class="line">name: <span class="string">"shaw"</span></span><br><span class="line">id: <span class="number">15</span></span><br></pre></td></tr></table></figure><p>可以看到GPB只用了8个字节传输。如果是JSON格式传输<code>{&quot;name&quot;: &quot;shaw&quot;,&quot;id&quot;: 15}</code>则要23个字节，更不要提XML了！更进一步，为什么GPB能这么省呢，原因也大概猜的到，它没有传 “name” “id”这些键值，而是用一个数字id代替，解析的时候也是通过这个id去关联键值。具体还是从上面序列化后的字符串s下手，它是一个二进制的字符串，我用一个特殊的语法来表示这8个字节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0010 0010, 0000 0100, s, h, a, w, 0010 1000, 0000 1111</span><br></pre></td></tr></table></figure><p>可以看到，是通过 Key Value Key Value 的形式排列的，Key与message中定义的Field的取值及类型有关。定义如下:</p><blockquote><p><strong>(field_number &lt;&lt; 3) | wire_type</strong></p></blockquote><p>wire_type 的取值跟类型有关，可以<a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">查表</a>获得：</p><table><thead><tr><th>Type</th><th>Meaning</th><th>Used For</th></tr></thead><tbody><tr><td>0</td><td>Varint</td><td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr><td>1</td><td>64-bit</td><td>fixed64, sfixed64, double</td></tr><tr><td>2</td><td>Length-delimited</td><td>string, bytes, embedded messages, packed repeated fields</td></tr><tr><td>5</td><td>32-bit</td><td>fixed32, sfixed32, float</td></tr></tbody></table><p>有了这个公式就知道GPB传输的Key是怎么算出来的了：</p><p>第一个字节： 4 &lt;&lt; 3 | 2 = 34 (0010 0010)<br>第二个字节： 4 （后面的字节长度）<br>第七个字节： 5 &lt;&lt; 3 | 0 = 40 (0010 1000，Key)<br>第八个字节： 15 （0000 1111，Value）</p><p>另外，GPB还使用了Varint来表示数字，它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。对于可选的Field，如果消息中不存在该field，那么在最终的Message Buffer中就没有该field，这些特性都有助于节约消息本身的大小。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面的例子，应该可以看到，GPB在网络、IO上十分高效，对其跨平台、可扩展性等方面会加深一点认识了。我想比较适合它的场景应该是：</p><ul><li>对性能有高要求</li><li>有跨平台需求、对扩展性要求高</li></ul><p>同时也应该看到一些缺点：</p><ul><li>可读性差（相比JSON、XML）</li><li>需要少量学习成本</li></ul>]]></content>
      
      
      <categories>
          
          <category> Protocol </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java源码解析 —— TreeMap</title>
      <link href="/2018/04/09/java-source-TreeMap/"/>
      <url>/2018/04/09/java-source-TreeMap/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TreeMap是基于红黑树结构实现的一种Map，要分析TreeMap的实现首先就要对红黑树有所了解。</p><p>构造图如下:<br>蓝色线条：继承<br>绿色线条：接口实现</p><p><img src="/images/treemap.png" alt="treemap"></p><h1 id="红黑树简介"><a href="#红黑树简介" class="headerlink" title="红黑树简介"></a>红黑树简介</h1><p>TreeMap底层是基于<strong>红黑树（Red-Black tree）</strong>实现，所以在学习TreeMap之前我们先来了解下红黑树。</p><p>红黑树又称红-黑二叉树，它首先是一颗二叉树，它具有二叉树所有的特性。同时红黑树更是一棵自平衡的排序二叉树。</p><p>我们知道一颗基本的二叉排序树他们都需要满足一个基本性质–即树中的任何节点的值大于它的左子节点，且小于它的右子节点。按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉排序树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右/左子树），这样势必会导致二叉树的检索效率大大降低（O(n)），所以为了维持二叉排序树的平衡，大牛们提出了各种实现的算法，如：AVL，SBT，伸展树，TREAP，红黑树等等。</p><p>平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。</p><p>红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树而言我们必须增加如下规则：</p><ol><li>每个节点都只能是红色或者黑色</li><li>根节点是黑色</li><li>每个叶节点（NIL节点，空节点）是黑色的</li><li>如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li></ol><p>红黑树示意图如下：</p><p><img src="/images/red-black_tree.png" alt="red-black_tree"></p><p>但是在在添加或删除节点后，红黑树就发生了变化，可能不再满足上面的5个特性，为了保持红黑树的以上特性，就有了三个动作：左旋、右旋、着色。</p><p>下面来看下什么是红黑树的左旋和右旋：</p><p><img src="/images/rotate_left.png" alt="rotate_left"></p><p><strong>对x进行左旋，意味着”将x变成一个左节点”。</strong></p><p><img src="/images/rotate_right.png" alt="rotate_right"></p><p><strong>对y进行右旋，意味着”将y变成一个右节点”。</strong></p><p>如果还是没看明白，下面找了两张左旋和右旋的动态图:</p><p><img src="/images/rotate_left.gif" alt="rotate_left"></p><p><img src="/images/rotate_right.gif" alt="rotate_right"></p><h1 id="TreeMap简介"><a href="#TreeMap简介" class="headerlink" title="TreeMap简介"></a>TreeMap简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><ul><li>TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。</li><li>TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合。</li><li>TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合。</li><li>TreeMap 实现了Cloneable接口，意味着它能被克隆。</li><li>TreeMap 实现了java.io.Serializable接口，意味着它支持序列化。</li></ul><p>TreeMap<strong>基于红黑树（Red-Black tree）实现</strong>。该映射根据<strong>其键的自然顺序进行排序</strong>，或者根据<strong>创建映射时提供的Comparator进行排序</strong>，具体取决于使用的构造方法。</p><p>TreeMap的基本操作containsKey、get、put和remove的时间复杂度是log(n)。</p><p>另外，TreeMap是<strong>非同步</strong>的。它的iterator方法返回的<strong>迭代器是fail-fast</strong>的。</p><h2 id="TreeMap属性"><a href="#TreeMap属性" class="headerlink" title="TreeMap属性"></a>TreeMap属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "fail-fast"集合修改记录</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>TreeMap的本质是R-B Tree(红黑树)，它包含几个重要的成员变量：root, size, comparator。</p><ul><li>root是红黑数的根节点。它是Entry类型，Entry是红黑数的节点，它包含了红黑数的6个基本组成成分：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)。Entry节点根据key进行排序，Entry节点包含的内容为value。</li><li>红黑数排序时，根据Entry中的key进行排序；Entry中的key比较大小是根据比较器comparator来进行判断的，默认按照key的自然顺序排序。</li><li>size是红黑数中节点的个数。</li></ul><p>Entry是树的节点类，我们来看一下Entry的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 左孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    <span class="comment">// 右孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// 红黑树用来表示节点颜色的属性，默认为黑色</span></span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用key，value和父节点构造一个Entry，默认为黑色</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> keyHash = (key==<span class="keyword">null</span> ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> valueHash = (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">"="</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry类理解起来比较简单（因为我们前面看过很多的Entry类了），主要是定义了树的孩子和父亲节点引用，和红黑颜色属性，并对equals和hashCode进行重写，以利于比较是否相等。</p><h2 id="TreeMap构造函数"><a href="#TreeMap构造函数" class="headerlink" title="TreeMap构造函数"></a>TreeMap构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造方法，comparator为空，代表使用key的自然顺序来维持TreeMap的顺序，这里要求key必须实现Comparable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用指定的比较器构造一个TreeMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个指定map的TreeMap，同样比较器comparator为空，使用key的自然顺序排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个指定SortedMap的TreeMap，根据SortedMap的比较器来来维持TreeMap的顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法中可以看出，要创建一个红黑树实现的TreeMap必须要有一个用于比较大小的比较器，因为只有能够比较大小才能实现红黑树的<code>左孩子 &lt; 树根 &lt; 右孩子</code>的特点。</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="红黑树的添加原理及TreeMap的put实现"><a href="#红黑树的添加原理及TreeMap的put实现" class="headerlink" title="红黑树的添加原理及TreeMap的put实现"></a>红黑树的添加原理及TreeMap的put实现</h2><p>将一个节点添加到红黑树中，通常需要下面几个步骤：</p><p>1.将红黑树当成一颗二叉查找树，将节点插入。<br>这一步比较简单，就上开始我们自己写的二叉查找树的操作一样，至于为什么可以这样插入，是因为红黑树本身就是一个二叉查找树。<br>2.将新插入的节点设置为红色。<br>有没有疑问，为什么新插入的节点一定要是红色的，因为新插入节点为红色，不会违背红黑规则第5条，少违背一条就少处理一种情况。<br>3.通过旋转和着色，使它恢复平衡，重新变成一颗符合规则的红黑树。<br>要想知道怎么样进行左旋和右旋，首先就要知道为什么要进行左旋和右旋。</p><p>我们来对比下红黑树的规则和新插入节点后的情况，看下新插入节点会违背哪些规则。</p><blockquote><p>① 节点是红色或黑色。<br>这一点肯定是不会违背的了。<br>② 根节点是黑色。<br>这一点也不会违背了，如果是根节点，只需将根节点插入就好了，因为默认是黑色。<br>③ 每个叶节点（NIL节点，空节点）是黑色的。<br>这一点也不会违背的，我们插入的是非空的节点，不会影响空节点。<br>④ 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)<br><strong>这一点是有可能违背的，我们将新插入的节点都设置成红色，如果其父节点也是红色的话，那就产生冲突了。</strong><br>⑤ 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br>这一点也不会违背，因为我们将新插入的节点都设置成红色。</p></blockquote><p>了解了红黑树左旋和右旋操作，以及新插入节点主要是可能会违背红黑树的规则④后，我们来分析下，添加新节点的过程有哪几种情况：</p><ol><li>新插入节点为根节点。这种情况直接将新插入节点设置为根节点即可，无需进行后续的旋转和着色处理。</li><li>新插入节点的父节点是黑色。这种情况直接将新节点插入即可，不会违背规则④。</li><li>新插入节点的父节点是红色。这种情况会违背规则④，而这种情况又分为了以下几种，下面进行图解：</li></ol><p>(1) 新插入节点N的父节点P和叔叔节点U都是红色。方法是：<strong>将祖父节点G设置为红色，父节点P和叔叔节点U设置为黑色</strong>，这时候就看似平衡了。但是，如果祖父节点G的父节点也是红色，这时候又违背规则④了，怎么办，方法是：将GPUN这一组看成一个新的节点，按照前面的方案递归；又但是根节点为红就违反规则②了，怎么办，方法是直接将根节点设置为黑色（两个连续黑色是没问题的）。</p><p><img src="/images/case1.png" alt="case1"></p><p>(2) 新插入节点N的父节点P是红色，叔叔节点U是黑色或者缺少，且新节点N是P的右孩子。方法是：<strong>左旋父节点P</strong>。左旋后N和P角色互换，但是P和N还是连续的两个红色节点，还没有平衡，怎么办，看第三种情况。</p><p><img src="/images/case2.png" alt="case2"></p><p>(3) 新插入节点N的父节点P是红色，叔叔节点U是黑色或者缺少，且新节点N是P的左孩子。方法是：<strong>右旋祖父节点G，然后将P设置为黑色，G设置为红色，达到平衡</strong>。此时父节点P是黑色，所以不用担心P的父节点是红色。</p><p>当然上面说的三种情况都是基于一个前提：<strong>新插入节点N的父节点P是祖父节点G的左孩子</strong>，如果P是G的右孩子又是什么情况呢？其实情况和上面是相似的，只需要调整左旋还是右旋，这里就不细说了。</p><p>下面看一下TreeMap的put实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="comment">// 如果根节点为空，则直接创建一个根节点，返回</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;K,V&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录比较结果</span></span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    <span class="comment">// 当前使用的比较器</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator ;</span><br><span class="line">    <span class="comment">// 如果比较器不为空，就是用指定的比较器来维护TreeMap的元素顺序</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// do while循环，查找key要插入的位置（也就是新节点的父节点是谁）</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 记录上次循环的节点t</span></span><br><span class="line">            parent = t;</span><br><span class="line">            <span class="comment">// 比较当前节点的key和新插入的key的大小</span></span><br><span class="line">            cmp = cpr.compare(key, t. key);</span><br><span class="line">             <span class="comment">// 新插入的key小的话，则以当前节点的左孩子节点为新的比较节点</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="comment">// 新插入的key大的话，则以当前节点的右孩子节点为新的比较节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">          <span class="comment">// 如果当前节点的key和新插入的key想的的话，则覆盖map的value，返回</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        <span class="comment">// 只有当t为null，也就是没有要比较节点的时候，代表已经找到新节点要插入的位置</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果比较器为空，则使用key作为比较器进行比较</span></span><br><span class="line">        <span class="comment">// 这里要求key不能为空，并且必须实现Comparable接口</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="comment">// 和上面一样，循环查找新节点要插入的位置</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t. key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t. left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t. right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到新节点的父节点后，创建节点对象</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;K,V&gt;(key, value, parent);</span><br><span class="line">    <span class="comment">// 如果新节点key的值小于父节点key的值，则插在父节点的左侧</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="comment">// 如果新节点key的值大于父节点key的值，则插在父节点的右侧</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    <span class="comment">// 插入新的节点后，为了保持红黑树平衡，对红黑树进行调整</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    <span class="comment">// map元素个数+1</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/** 新增节点后对红黑树的调整方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将新插入节点的颜色设置为红色</span></span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while循环，保证新插入节点x不是根节点或者新插入节点x的父节点不是红色（这两种情况不需要调整）</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="comment">// 如果新插入节点x的父节点是祖父节点的左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            <span class="comment">// 取得新插入节点x的叔叔节点</span></span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="comment">// 如果新插入x的父节点是红色-------------------①</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">// 将x的父节点设置为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// 将x的叔叔节点设置为黑色</span></span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                <span class="comment">// 将x的祖父节点设置为红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// 将x指向祖父节点，如果x的祖父节点的父节点是红色，按照上面的步奏继续循环</span></span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果新插入x的叔叔节点是黑色或缺少，且x的父节点是祖父节点的右孩子-------------------②</span></span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    <span class="comment">// 左旋父节点</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果新插入x的叔叔节点是黑色或缺少，且x的父节点是祖父节点的左孩子-------------------③</span></span><br><span class="line">                <span class="comment">// 将x的父节点设置为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// 将x的祖父节点设置为红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// 右旋x的祖父节点</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果新插入节点x的父节点是祖父节点的右孩子，下面的步奏和上面的相似，只不过左旋右旋的区分，不在细讲</span></span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后将根节点设置为黑色，不管当前是不是红色，反正根节点必须是黑色</span></span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对红黑树的节点(x)进行左旋转</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 左旋示意图(对节点x进行左旋)：</span></span><br><span class="line"><span class="comment"> *      px                              px</span></span><br><span class="line"><span class="comment"> *     /                               /</span></span><br><span class="line"><span class="comment"> *    x                               y               </span></span><br><span class="line"><span class="comment"> *   /  \      --(左旋)--             / \                </span></span><br><span class="line"><span class="comment"> *  lx   y                          x  ry    </span></span><br><span class="line"><span class="comment"> *     /   \                       /  \</span></span><br><span class="line"><span class="comment"> *    ly   ry                     lx  ly </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 取得要选择节点p的右孩子</span></span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        <span class="comment">// "p"和"r的左孩子"的相互指向...</span></span><br><span class="line">        <span class="comment">// 将"r的左孩子"设为"p的右孩子"</span></span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="comment">// 如果r的左孩子非空，将"p"设为"r的左孩子的父亲"</span></span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// "p的父亲"和"r"的相互指向...</span></span><br><span class="line">        <span class="comment">// 将"p的父亲"设为"y的父亲"</span></span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="comment">// 如果"p的父亲"是空节点，则将r设为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="comment">// 如果p是它父节点的左孩子，则将r设为"p的父节点的左孩子"</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果p是它父节点的左孩子，则将r设为"p的父节点的左孩子"</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        <span class="comment">// "p"和"r"的相互指向...</span></span><br><span class="line">        <span class="comment">// 将"p"设为"r的左孩子"</span></span><br><span class="line">        r.left = p;</span><br><span class="line">        <span class="comment">// 将"p的父节点"设为"r"</span></span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对红黑树的节点进行右旋转</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 右旋示意图(对节点y进行右旋)：</span></span><br><span class="line"><span class="comment"> *            py                               py</span></span><br><span class="line"><span class="comment"> *           /                                /</span></span><br><span class="line"><span class="comment"> *          y                                x                 </span></span><br><span class="line"><span class="comment"> *         /  \      --(右旋)--             /  \                     </span></span><br><span class="line"><span class="comment"> *        x   ry                           lx   y </span></span><br><span class="line"><span class="comment"> *       / \                                   / \                   </span></span><br><span class="line"><span class="comment"> *      lx  rx                                rx  ry</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 取得要选择节点p的左孩子</span></span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        <span class="comment">// 将"l的右孩子"设为"p的左孩子"</span></span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="comment">// 如果"l的右孩子"不为空的话，将"p"设为"l的右孩子的父亲"</span></span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">        <span class="comment">// 将"p的父亲"设为"l的父亲"</span></span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="comment">// 如果"p的父亲"是空节点，则将l设为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="comment">// 如果p是它父节点的右孩子，则将l设为"p的父节点的右孩子"</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="comment">//如果p是它父节点的左孩子，将l设为"p的父节点的左孩子"</span></span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        <span class="comment">// 将"p"设为"l的右孩子"</span></span><br><span class="line">        l.right = p;</span><br><span class="line">        <span class="comment">// 将"l"设为"p父节点"</span></span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树的删除原理及TreeMap的remove实现"><a href="#红黑树的删除原理及TreeMap的remove实现" class="headerlink" title="红黑树的删除原理及TreeMap的remove实现"></a>红黑树的删除原理及TreeMap的remove实现</h2><p>TODO</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> source code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程编程 —— Future模式</title>
      <link href="/2018/04/03/java-future/"/>
      <url>/2018/04/03/java-future/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于多线程的设计模式，主要包括：Future模式、Master-Worker模式、Guarded Suspeionsion模式、不变模式和生产者-消费者模式等。</p></blockquote><blockquote><p>近期由于需求，用到了Future设计模式，说来惭愧，对于设计模式偶尔用过，但没有系统化的归纳和总结。接下来一段时间，希望能够完善这部分的知识空白吧。</p></blockquote><h1 id="Future模式的核心思想"><a href="#Future模式的核心思想" class="headerlink" title="Future模式的核心思想"></a>Future模式的核心思想</h1><p>Future模式的核心在于：去除了主函数的等待时间，并使得原本需要等待的时间段可以用于处理其他业务逻辑（根据《Java程序性能优化》）。</p><p>Future模式有点类似于商品订单。在网上购物时，提交订单后，在收货的这段时间里无需一直在家里等候，可以先干别的事情。类推到程序设计中时，当提交请求时，期望得到答复时，如果这个答复可能很慢。传统的时一直等待到这个答复收到时再去做别的事情，但如果利用Future设计模式就无需等待答复的到来，在等待答复的过程中可以干其他事情。</p><p>例如如下的请求调用过程时序图。当call请求发出时，需要很长的时间才能返回。左边的图需要一直等待，等返回数据后才能继续其他操作；而右边的Future模式的图中客户端则无需等到可以做其他的事情。服务器段接收到请求后立即返回结果给客户端，这个结果并不是真实的结果（是虚拟的结果），也就是先获得一个假数据，然后执行其他操作。</p><p><img src="/images/future_call.png" alt="future_call.png"></p><h1 id="Future模式的Java实现"><a href="#Future模式的Java实现" class="headerlink" title="Future模式的Java实现"></a>Future模式的Java实现</h1><h2 id="Client实现"><a href="#Client实现" class="headerlink" title="Client实现"></a>Client实现</h2><p>Client主要完成的功能包括：</p><ol><li>返回一个FutureData；</li><li>开启一个线程用于构造RealData。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">request</span><span class="params">(<span class="keyword">final</span> String string)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">final</span> FutureData futureData = <span class="keyword">new</span> FutureData();  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="comment">// RealData的构建很慢，所以放在单独的线程中运行  </span></span><br><span class="line">                RealData realData = <span class="keyword">new</span> RealData(string);  </span><br><span class="line">                futureData.setRealData(realData);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;).start();  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> futureData; <span class="comment">// 先直接返回FutureData  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Data接口"><a href="#Data接口" class="headerlink" title="Data接口"></a>Data接口</h2><p>无论是FutureData还是RealData都实现该接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span> </span>&#123;  </span><br><span class="line">    <span class="function">String <span class="title">getResult</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FutureData实现"><a href="#FutureData实现" class="headerlink" title="FutureData实现"></a>FutureData实现</h2><p>FutureData是Future模式的关键，它实际上是<strong>真实数据RealData的代理，封装了获取RealData的等待过程</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;  </span><br><span class="line">    RealData realData = <span class="keyword">null</span>; <span class="comment">// FutureData是RealData的封装  </span></span><br><span class="line">    <span class="keyword">boolean</span> isReady = <span class="keyword">false</span>;  <span class="comment">// 是否已经准备好  </span></span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realData)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(isReady)  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        <span class="keyword">this</span>.realData = realData;  </span><br><span class="line">        isReady = <span class="keyword">true</span>;  </span><br><span class="line">        notifyAll(); <span class="comment">// RealData已经被注入到FutureData中了，通知getResult()方法  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getResult</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(!isReady) &#123;  </span><br><span class="line">            wait(); <span class="comment">// 一直等到RealData注入到FutureData中  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> realData.getResult();   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RealData实现"><a href="#RealData实现" class="headerlink" title="RealData实现"></a>RealData实现</h2><p>RealData是最终需要使用的数据，主要体现了被调用的线程处理任务的过程，它的构造函数处理很慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">protected</span> String data;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String data)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 利用sleep方法来表示RealData构造过程是非常缓慢的  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">this</span>.data = data;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> data;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>主函数主要负责调用Client发起请求，并使用返回的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        Client client = <span class="keyword">new</span> Client();  </span><br><span class="line">        <span class="comment">// 这里会立即返回，因为获取的是FutureData，而非RealData  </span></span><br><span class="line">        Data data = client.request(<span class="string">"name"</span>);  </span><br><span class="line">        <span class="comment">// 这里可以用一个sleep代替对其他业务逻辑的处理  </span></span><br><span class="line">        <span class="comment">// 在处理这些业务逻辑过程中，RealData也正在创建，从而充分了利用等待时间  </span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">        <span class="comment">// 使用真实数据  </span></span><br><span class="line">        System.out.println(<span class="string">"数据 = "</span> + data.getResult());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Future模式的JDK内置实现"><a href="#Future模式的JDK内置实现" class="headerlink" title="Future模式的JDK内置实现"></a>Future模式的JDK内置实现</h1><p>由于Future是非常常用的多线程设计模式，因此在JDK中内置了Future模式的实现。这些类在java.util.concurrent包里面。其中最为重要的是FutureTask类，它实现了Runnable接口，作为单独的线程运行。在其run()方法中，通过Sync内部类调用Callable接口，并维护Callable接口的返回对象。当使用FutureTask.get()方法时，将返回Callable接口的返回对象。同样，针对上述的实例，如果使用JDK自带的实现，则需要作如下调整。</p><p>首先，Data接口和FutureData就不需要了，JDK帮我们实现了。</p><p>其次，RealData改为这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">protected</span> String data;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String data)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.data = data;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">// 利用sleep方法来表示真是业务是非常缓慢的  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> data;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        FutureTask&lt;String&gt; futureTask =   </span><br><span class="line">                <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> RealData(<span class="string">"name"</span>));  </span><br><span class="line">        ExecutorService executor =   </span><br><span class="line">                Executors.newFixedThreadPool(<span class="number">1</span>); <span class="comment">// 使用线程池  </span></span><br><span class="line">        <span class="comment">// 执行FutureTask，相当于上例中的client.request("name")发送请求  </span></span><br><span class="line">        executor.submit(futureTask);  </span><br><span class="line">        <span class="comment">// 这里可以用一个sleep代替对其他业务逻辑的处理  </span></span><br><span class="line">        <span class="comment">// 在处理这些业务逻辑过程中，RealData也正在创建，从而充分了利用等待时间  </span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">        <span class="comment">// 使用真实数据  </span></span><br><span class="line">        <span class="comment">// 如果call()没有执行完成依然会等待  </span></span><br><span class="line">        System.out.println(<span class="string">"数据="</span> + futureTask.get());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Runnable：在并发编程时，一般使用runnable，然后扔给线程池完事，这种情况下不需要线程的结果，所以run的返回值是void类型。</li><li>Callable：如果是一个多线程协作程序，比如斐波那契数列，1，1，2，3，5，8…使用多线程来计算。但后者需要前者的结果，就需要用callable接口了。callable用法和runnable一样，只不过调用的是call方法，该方法有一个泛型返回值类型，你可以任意指定。</li><li>Future：Future可以从别的线程中得到函数返回值。Future可以监视目标线程调用call的情况，当你调用Future的get()方法以获得结果时，当前线程就开始阻塞，直到call方法结束返回结果。</li></ul><blockquote><p>参考《<a href="https://blog.csdn.net/ghuil/article/details/41048017" target="_blank" rel="noopener">Java多线程编程中Future模式的详解</a>》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Concurrency </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java Stream详解</title>
      <link href="/2018/03/28/java-8-stream/"/>
      <url>/2018/03/28/java-8-stream/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在讨论Stream之前，我们有必要介绍一下lambda的作用域，因为stream通常是与lambda搭配来使用的，并且最近在工作中也遇到了作用域上面的问题（无法访问接口的默认方法）。</p></blockquote><h1 id="lambda的作用域"><a href="#lambda的作用域" class="headerlink" title="lambda的作用域"></a>lambda的作用域</h1><p>在Lambda中，变量的作用域与访问操作主要遵循以下规则：</p><ul><li>本地变量(Local Variable)可以访问但是不可以修改</li><li>类成员变量与静态变量可以被读写，即闭包中的this实际指向的是创建该Lambda表达式的方法的this参数</li><li>函数式接口的默认方法不可以在Lambda表达式中被访问</li></ul><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p><strong>lambda表达式的方法体与嵌套代码块有着相同的作用域</strong>。因此它也适用同样的命名冲突和屏蔽规则。在lambda表达式中不允许声明一个与局部变量同名的参数或者局部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Path first = Paths.get(<span class="string">"/usr/bin"</span>);</span><br><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt;</span><br><span class="line">    Integer.compare(first.length(), second.length());</span><br><span class="line"><span class="comment">// 错误，变量first已经定义了</span></span><br></pre></td></tr></table></figure><p><strong>在一个方法里，你不能有两个同名的局部变量</strong>，因此，你也不能在lambda表达式中引入这样的变量。在下一个示例中，lambda表达式有两个自由变量，text和count。数据结构表示lambda表达式必须存储这两个变量的值，即“Hello”和20。我们可以说，这些值已经被lambda表达式捕获了（这是一个技术实现的细节。例如，你可以将一个lambda表达式转换为一个只含一个方法的对象，这样自由变量的值就会被复制到该对象的实例变量中）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java8test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        repeatMessage(<span class="string">"Hello"</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                System.out.println(text);</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>当你在lambda表达式中使用this关键字，你会引用创建该lambda表达式的方法的this参数，以下面的代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable runner = () -&gt; &#123;....;System.out.println(<span class="keyword">this</span>.toString());......&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式this.toString()会调用Application对象的toString()方法，而不是Runnable实例的toString()方法。<strong>在lambda表达式中使用this，与在其他地方使用this没有什么不同</strong>。lambda表达式的作用域被嵌套在doWork()方法中，并且无论this位于方法的何处，其意义都是一样的。</p><h2 id="引用的变量不可更改"><a href="#引用的变量不可更改" class="headerlink" title="引用的变量不可更改"></a>引用的变量不可更改</h2><p>Lambda表达式可以捕获闭合作用域中的变量值。在Java中，为了确保被捕获的值是被良好定义的，需要遵守一个重要的约束。在lambda表达式中，被引用的变量的值不可以被更改。例如，下面这个表达式是不合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    Runnable r = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--;        <span class="comment">// 错误，不能更改已捕获变量的值</span></span><br><span class="line">            System.out.println(text);</span><br><span class="line">            Thread.yield();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要指望编译器会捕获所有并发访问错误。不可变的约束只作用在局部变量上，如果是一个实例变量或者闭合类的静态变量，那么不会有任何错误被报告出来，即使结果同样不确定。同样，改变一个共享对象也是完全合法的，即使这样并不恰当。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Path&gt; matches = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Path p : files)</span><br><span class="line"><span class="comment">// 你可以改变matches的值，但是在多线程下是不安全的</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;<span class="keyword">if</span>(p中包含某些属性) matches.add(p);&#125;).start();</span><br></pre></td></tr></table></figure><p>注意matches是“有效final”的（一个有效的final变量被初始化后，就永远不会再被赋一个新值的变量）。在我们的示例中，matches总是引用同一个ArrayList对象，但是，<strong>这个对象是可变的，因此是线程不安全的</strong>。如果多个线程同时调用add方法，结果将无法预测。</p><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>这里不对Stream的API做过多的介绍，更多的是分析一下原理，所以比较枯燥。关于Stream的API，请移步<a href="http://colobu.com/2016/03/02/Java-Stream/" target="_blank" rel="noopener">这里</a>。</p><h2 id="Stream简介"><a href="#Stream简介" class="headerlink" title="Stream简介"></a>Stream简介</h2><p>Stream是java 8中新增加的特性。</p><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的Iterator。原始版本的Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream会隐式地在内部进行遍历，做出相应的数据转换。</p><p>Stream就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p><p>而和迭代器又不同的是，Stream可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个item读完后再读下一个item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream的并行操作依赖于Java 7中引入的Fork/Join框架来拆分任务和加速处理过程。Java的并行API演变历程基本如下：</p><blockquote><p>1.0-1.4 中的 java.lang.Thread<br>5.0 中的 java.util.concurrent<br>6.0 中的 Phasers 等<br>7.0 中的 Fork/Join 框架<br>8.0 中的 Lambda</p></blockquote><p>Stream 的另外一大特点是，数据源本身可以是无限的。</p><h2 id="parallelStream简介"><a href="#parallelStream简介" class="headerlink" title="parallelStream简介"></a>parallelStream简介</h2><p>parallelStream其实就是一个并行执行的流。它通过默认的ForkJoinPool，可能提高你的多线程任务的速度。</p><p>parallelStream具有平行处理能力，处理的过程会分而治之，也就是将一个大任务切分成多个小任务，这表示每个任务都是一个操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">numbers.parallelStream().forEach(out::println);</span><br></pre></td></tr></table></figure><p>得到的展示顺序不一定会是1、2、3、4、5、6、7、8、9，而可能是任意的顺序，就forEach()这个操作來讲，如果平行处理时，希望最后顺序是按照原来Stream的数据顺序，那可以调用forEachOrdered()。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">numbers.parallelStream().forEachOrdered(out::println);</span><br></pre></td></tr></table></figure><p>注意：如果forEachOrdered()中间有其他如filter()的中介操作，会试着平行化处理，然后最终forEachOrdered()会以原数据顺序处理，因此，使用forEachOrdered()这类的有序处理,可能会（或完全失去）失去平行化的一些优势，实际上中介操作亦有可能如此，例如sorted()方法。</p><h1 id="parallelStream背后的男人：ForkJoinPool"><a href="#parallelStream背后的男人：ForkJoinPool" class="headerlink" title="parallelStream背后的男人：ForkJoinPool"></a>parallelStream背后的男人：ForkJoinPool</h1><p>要想深入的研究parallelStream之前，我们必须先了解ForkJoin框架和ForkJoinPool。本文旨在parallelStream，但因为两种关系甚密，故在此简单介绍一下ForkJoinPool。</p><p>ForkJoin框架是从jdk7中的特性，它同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么默认值为<strong>当前计算机可用的CPU数量会被设置为线程数量</strong>。</p><p>ForkJoinPool主要用来使用分治法(Divide-and-Conquer Algorithm)来解决问题。典型的应用比如快速排序算法。这里的要点在于，ForkJoinPool需要使用相对少的线程来处理大量的任务。比如要对1000万个数据进行排序，那么会将这个任务分割成两个500万的排序任务和一个针对这两组500万数据的合并任务。以此类推，对于500万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于10时，会停止分割，转而使用插入排序对它们进行排序。那么到最后，所有的任务加起来会有大概2000000+个。问题的关键在于，对于一个任务而言，<strong>只有当它所有的子任务完成之后，它才能够被执行</strong>。</p><p>所以当使用ThreadPoolExecutor时，使用分治法会存在问题，因为ThreadPoolExecutor中的线程无法像任务队列中再添加一个任务并且在等待该任务完成之后再继续执行。而使用ForkJoinPool时，就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。</p><p><strong><em>使用ThreadPoolExecutor或者ForkJoinPool，会有什么性能的差异呢？</em></strong><br>首先，使用ForkJoinPool能够使用数量有限的线程来完成非常多的具有父子关系的任务，比如使用4个线程来完成超过200万个任务。但是，使用ThreadPoolExecutor时，是不可能完成的，因为ThreadPoolExecutor中的Thread无法选择优先执行子任务，需要完成200万个具有父子关系的任务时，也需要200万个线程，显然这是不可行的。</p><h2 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h2><p>forkjoin最核心的地方就是利用了现代硬件设备多核,在一个操作时候会有空闲的cpu,那么如何利用好这个空闲的cpu就成了提高性能的关键,而这里我们要提到的工作窃取（work-stealing）算法就是整个forkjion框架的核心理念,工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</p><p><strong><em>为什么需要使用工作窃取算法？</em></strong><br>假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会<strong>使用双端队列</strong>，<strong>被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行</strong>。</p><blockquote><p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p></blockquote><h2 id="用看forkjoin的眼光来看ParallelStreams"><a href="#用看forkjoin的眼光来看ParallelStreams" class="headerlink" title="用看forkjoin的眼光来看ParallelStreams"></a>用看forkjoin的眼光来看ParallelStreams</h2><p>我们提到了在Java 8引入了自动并行化的概念。它能够让一部分Java代码自动地以并行的方式执行，也就是我们使用了ForkJoinPool的ParallelStream。</p><p>Java 8为ForkJoinPool添加了一个通用线程池，这个线程池用来处理那些没有被显式提交到任何线程池的任务。它是ForkJoinPool类型上的一个静态元素，它拥有的<strong>默认线程数量等于运行计算机上的处理器数量</strong>。当调用Arrays类上添加的新方法时，自动并行化就会发生。比如用来排序一个数组的并行快速排序，用来对一个数组中的元素进行并行遍历。自动并行化也被运用在Java 8新添加的Stream API中。</p><p>比如下面的代码用来遍历列表中的元素并执行需要的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserInfo&gt; userInfoList =</span><br><span class="line">    DaoContainers.getUserInfoDAO().queryAllByList(<span class="keyword">new</span> UserInfoModel());</span><br><span class="line">userInfoList.parallelStream().forEach(RedisUserApi::setUserIdUserInfo);</span><br></pre></td></tr></table></figure><p>对于列表中的元素的操作都会以并行的方式执行。forEach方法会为每个元素的计算操作创建一个任务，该任务会被前文中提到的ForkJoinPool中的通用线程池处理。以上的并行计算逻辑当然也可以使用ThreadPoolExecutor完成，但是就代码的可读性和代码量而言，使用ForkJoinPool明显更胜一筹。</p><p>对于ForkJoinPool通用线程池的线程数量，通常使用默认值就可以了，即运行时计算机的处理器数量。我这里提供了一个示例的代码让你了解jvm所使用的ForkJoinPool的线程数量, 你可以可以通过设置系统属性：<code>-Djava.util.concurrent.ForkJoinPool.common.parallelism = N</code> （N为线程数量），来调整ForkJoinPool的线程数量。</p><p>forEach会将执行forEach本身的线程也作为线程池中的一个工作线程。因此，即使将ForkJoinPool的通用线程池的线程数量设置为1，实际上也会有2个工作线程。因此在使用forEach的时候，线程数为1的ForkJoinPool通用线程池和线程数为2的ThreadPoolExecutor是等价的。</p><p>所以当ForkJoinPool通用线程池实际需要4个工作线程时，可以将它设置成3，那么在运行时可用的工作线程就是4了。</p><h1 id="ParallelStreams的陷阱"><a href="#ParallelStreams的陷阱" class="headerlink" title="ParallelStreams的陷阱"></a>ParallelStreams的陷阱</h1><p>上文中我们已经看到了ParallelStream强大无比的特性，但ParallelStreams不是万金油，而是一把双刃剑，如果错误的使用反倒可能伤人伤己.</p><p>以下是一个我们项目里使用parallel streams的很常见的情况。在这个例子中，我们想同时调用不同地址的api中并且获得第一个返回的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">query</span><span class="params">(String q, List&lt;String&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    Optional&lt;String&gt; result = engines.stream()</span>.<span class="title">parallel</span><span class="params">()</span>.<span class="title">map</span><span class="params">((base)</span> -&gt; </span>&#123;</span><br><span class="line">      String url = base + q;</span><br><span class="line">      <span class="keyword">return</span> WS.url(url).get();</span><br><span class="line">      &#125;).findAny();</span><br><span class="line">    <span class="keyword">return</span> result.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们仔细思考一下整个功能究竟是如何运转的。首先我们的集合元素engines由ParallelStreams并行的去进行map操作(ParallelStreams使用JVM默认的forkJoin框架的线程池由当前线程去执行并行操作)。</p><p>然而,这里需要注意的一地方是我们在调用第三方的api请求是一个响应略慢而且会阻塞操作的一个过程。所以在某时刻所有线程都会调用get()方法并且在那里等待结果返回。</p><p>再回过头仔细思考一下这个功能的实现过程是我们一开始想要的吗？我们是在同一时间等待所有的结果，而不是遍历这个列表按顺序等待每个回答。然而，由于ForkJoinPool workers的存在，这样平行的等待相对于使用主线程的等待会产生的一种副作用。</p><p>现在ForkJoin pool（关于forkjion的更多实现你可以去搜索引擎中去看一下他的具体实现方式）的实现是：它并不会因为产生了新的workers而抵消掉阻塞的workers。那么在某个时间所有ForkJoinPool.common()的线程都会被用光。也就是说，下一次你调用这个查询方法，就可能会在一个时间与其他的parallel stream同时运行，而导致第二个任务的性能大大受损。或者说，例如你在这个功能里是用来快速返回调用的第三方api的，而在其他的功能里是用于一些简单的数据并行计算的，但是假如你先调用了这个功能，同一时间之后调用计算的函数，那么这里forkjoinPool的实现会让你计算的函数大打折扣。</p><p>不过也不要急着去吐槽ForkJoinPool的实现，在不同的情况下你可以给它一个<strong>ManagedBlocker实例</strong>并且确保它知道在一个阻塞调用中应该什么时候去抵消掉卡住的workers。现在有意思的一点是，在一个parallel stream处理中并不一定是阻塞调用会拖延程序的性能。任何被用于映射在一个集合上的长时间运行的函数都会产生同样的问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从stream和parallelStream方法中进行选择时,我们可以考虑以下几个问题：</p><p><strong>是否需要并行？</strong><br>你需要弄清楚你要解决的问题是什么，数据量有多大，计算的特点是什么？并不是所有的问题都适合使用并发程序来求解，比如当数据量不大时，顺序执行往往比并行执行更快。毕竟，准备线程池和其它相关资源也是需要时间的。但是，当任务涉及到I/O操作并且任务之间不互相依赖时，那么并行化就是一个不错的选择。通常而言，将这类程序并行化之后，执行速度会提升好几个等级。</p><p><strong>任务之间是否是独立的？是否会引起任何竞态条件？</strong><br>如果任务之间是独立的，并且代码中不涉及到对同一个对象的某个状态或者某个变量的更新操作，那么就表明代码是可以被并行化的。</p><p><strong>结果是否取决于任务的调用顺序？</strong><br>由于在并行环境中任务的执行顺序是不确定的，因此对于依赖于顺序的任务而言，并行化也许不能给出正确的结果。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java源码解析 —— HashMap</title>
      <link href="/2018/03/19/java-source-HashMap/"/>
      <url>/2018/03/19/java-source-HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前对于List结构，我们分析了<a href="https://sagittariusyx.github.io/2018/03/15/java-source-ArrayList/" target="_blank" rel="noopener">ArrayList</a>和<a href="https://sagittariusyx.github.io/2018/03/18/java-source-LinkedList/" target="_blank" rel="noopener">LinkedList</a>，就这两者而言，反映的是两种思想：</p><ul><li>ArrayList以数组形式实现，顺序插入、查找快，插入、删除较慢</li><li>LinkedList以链表形式实现，顺序插入、查找较慢，插入、删除方便</li></ul><p>那么是否有一种数据结构能够结合上面两种的优点呢？有，答案就是HashMap。它是基于哈希表的 Map 接口的实现，以key-value的形式存在。</p><p>构造图如下:<br>蓝色线条：继承<br>绿色线条：接口实现</p><p><img src="/images/HashMap.png" alt="HashMap"></p><p>要理解HashMap， 就必须要知道了解其底层的实现， 而底层实现里最重要的就是它的数据结构了，HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p>在分析要理解HashMap源码前有必要对hashcode进行说明：</p><ol><li>hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；</li><li>如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；</li><li>如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；</li><li>两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。</li></ol><blockquote><p>hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有<br>例如内存中有这样的位置<br>0 1 2 3 4 5 6 7<br>而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。<br>但如果用hashcode那就会使效率提高很多。<br>我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。</p></blockquote><blockquote><p>但是如果两个类有相同的hashcode怎么办（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义equals了。<br>也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过equals来在这个桶里找到我们要的类。<br>那么。重写了equals()，为什么还要重写hashCode()呢？<br>想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊</p></blockquote><h1 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>HashMap是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p><h2 id="HashMap属性"><a href="#HashMap属性" class="headerlink" title="HashMap属性"></a>HashMap属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量为16，必须为2的n次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量为2的30次方</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认加载因子为0.75f</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry数组，长度必须为2的n次幂</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已存储元素的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下次扩容的临界值，size &gt;= threshold就会扩容，threshold等于capacity * loadFactor</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>HashMap是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, size, threshold, loadFactor, modCount。</p><ul><li>table是一个Node[]数组类型，而Node实际上就是一个单向链表。哈希表的“key-value键值对”都是存储在Node数组中的。</li><li>size是HashMap的大小，它是HashMap保存的键值对的数量。</li><li>threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值 = “容量 * 加载因子”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。</li><li>loadFactor就是加载因子。</li><li>modCount是用来实现fail-fast机制的。</li></ul><p>可以看出HashMap底层是用Node数组存储数据，同时定义了初始容量，最大容量，加载因子等参数，至于为什么容量必须是2的幂，加载因子又是什么，下面再说，先来看一下Node的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;  <span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node是HashMap的内部类，它继承了Map中的Entry接口，它定义了键(key)，值(value)，和下一个节点的引用(next)，以及hash值。很明确的可以看出Node是什么结构，它是单线链表的一个节点。也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。</p><p><img src="/images/HashMap-structure.png" alt="HashMap-structure"></p><p>为什么会有这样的设计？之前介绍的List中查询时需要遍历所有的数组，为了解决这个问题HashMap采用hash算法将key散列为一个int值，这个int值对应到数组的下标，再做查询操作的时候，拿到key的散列值，根据数组下标就能直接找到存储在数组的元素。但是由于hash可能会出现相同的散列值，为了解决冲突，<strong>HashMap采用将相同的散列值存储到一个链表中，也就是说在一个链表中的元素他们的散列值绝对是相同的</strong>。找到数组下标取出链表，再遍历链表是不是比遍历整个数组效率好的多呢？</p><p>我们来看一下HashMap的具体实现。</p><h2 id="HashMap构造函数"><a href="#HashMap构造函数" class="headerlink" title="HashMap构造函数"></a>HashMap构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个使用默认初始容量(16)和默认加载因子(0.75)的HashMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个指定初始容量的HashMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个指定初始容量和加载因子的HashMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个指定map的HashMap，所创建HashMap使用默认加载因子(0.75)和足以容纳指定map的初始容量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap提供了四个构造函数：</p><ul><li>HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空HashMap。</li><li>HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空HashMap。</li><li>HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空HashMap。</li><li>public HashMap(Map&lt;? extends K, ? extends V&gt; m)：包含“子Map”的构造函数。</li></ul><p>在这里提到了两个参数：初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>HashMap会对null值key进行特殊处理，总是放到table[0]位置<br>put过程是先计算hash然后通过hash与table.length取模计算index值，然后将key放到table[index]位置，当table[index]已存在其它元素时，会在table[index]位置形成一个链表，将新添加的元素放在table[index]，原来的元素通过Entry的next进行链接，这样<strong>以链表形式解决hash冲突问题</strong>，当元素数量达到临界值(capactiyfactor)时，则进行扩容，是table数组长度变为table.length * 2。</p><p><img src="/images/HashMap_put.png" alt="HashMap_put"></p><ol><li>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</li><li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3；</li><li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals；</li><li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；</li><li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li><li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 步骤②：计算index，并对null做处理</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">// 步骤⑥：超过最大容量，就扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resize扩容"><a href="#resize扩容" class="headerlink" title="resize扩容"></a>resize扩容</h2><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><p>分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入新的容量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用扩容前的Entry数组</span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        <span class="comment">// 修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 初始化一个新的Entry数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// ！！将数据转移到新的Entry数组里</span></span><br><span class="line">    transfer(newTable);</span><br><span class="line">    <span class="comment">// HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">// 修改阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// src引用了旧的Entry数组</span></span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">// 遍历旧的Entry数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; </span><br><span class="line">        <span class="comment">// 取得旧Entry数组的每个元素</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                <span class="comment">// 标记[i]</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                <span class="comment">// 将元素放在数组上</span></span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                <span class="comment">// 访问下一个Entry链上的元素</span></span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor = 1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p><p><img src="/images/hashmap_resize.png" alt="hashmap_resize"></p><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="/images/hashMap_hash_1.8.png" alt="hashMap_hash_1.8"></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="/images/hashMap_hash_1.8_2.png" alt="hashMap_hash_1.8_2"></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p><p><img src="/images/hashmap_resize_1.8.png" alt="hashmap_resize_1.8"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>get的过程是先计算hash然后通过hash与table.length取模计算index值，然后遍历table[index]上的链表，直到找到key，然后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据hash值找到桶，查看第一个Node的key若相等，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 若是红黑树结构，调用红黑树的getTreeNode方法返回</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 遍历链表，返回key-value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><p>计算hash，计算index，然后遍历查找，将找到的元素从table[index]链表移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt; e;</span><br><span class="line">     <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">         <span class="keyword">null</span> : e.value;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">     <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             node = p;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">do</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                         ((k = e.key) == key ||</span><br><span class="line">                          (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                         node = e;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     p = e;</span><br><span class="line">                 &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                              (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">             <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                 tab[index] = node.next;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 <span class="comment">// 链表删除节点操作</span></span><br><span class="line">                 p.next = node.next;</span><br><span class="line">             ++modCount;</span><br><span class="line">             --size;</span><br><span class="line">             afterNodeRemoval(node);</span><br><span class="line">             <span class="keyword">return</span> node;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="clear方法"><a href="#clear方法" class="headerlink" title="clear方法"></a>clear方法</h2><p>clear方法非常简单，就是遍历table然后把每个位置置为null，同时修改元素个数为0。<br>需要注意的是clear方法只会清除里面的元素，并不会重置capactiy。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="containsKey方法"><a href="#containsKey方法" class="headerlink" title="containsKey方法"></a>containsKey方法</h2><p>containsKey方法调用<code>getNode</code>方法，返回取到的Node是否为空。</p><h2 id="containsValue方法"><a href="#containsValue方法" class="headerlink" title="containsValue方法"></a>containsValue方法</h2><p>containsValue方法就比较粗暴了，就是直接遍历所有元素直到找到value，由此可见HashMap的containsValue方法本质上和普通数组和list的contains方法没什么区别，别指望它会像containsKey那么高效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">     <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">             <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                     (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="entrySet-、values-、keySet-方法"><a href="#entrySet-、values-、keySet-方法" class="headerlink" title="entrySet()、values()、keySet()方法"></a>entrySet()、values()、keySet()方法</h2><p>它们3个的原理类似，这里以entrySet()为例来说明。<br>entrySet()的作用是<strong>返回“HashMap中所有Entry的集合”，它是一个集合</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回“HashMap的Entry集合”，实际是返回一个EntrySet对象</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EntrySet对应的集合</span></span><br><span class="line"><span class="comment">// EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap是通过拉链法实现的散列表。表现在HashMap包括许多的Node，而每一个Node本质上又是一个单向链表。那么HashMap遍历key-value键值对的时候，是如何逐个去遍历的呢？</p><p>下面我们就看看<strong>HashMap是如何通过entrySet()遍历的</strong>。<br>entrySet()实际上是通过newEntryIterator()实现的。 下面我们看看它的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个“entry迭代器”</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry的迭代器</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextNode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。</span></span><br><span class="line"><span class="comment">// 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下一个元素</span></span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    <span class="comment">// 当前元素</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="comment">// expectedModCount用于实现fast-fail机制。</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">    <span class="comment">// 当前索引</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="comment">// 将next指向table中第一个不为null的元素。</span></span><br><span class="line">            <span class="comment">// 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意！！！</span></span><br><span class="line">        <span class="comment">// 一个Entry就是一个单向链表</span></span><br><span class="line">        <span class="comment">// 若该Entry的下一个节点不为空，就将next指向下一个节点;</span></span><br><span class="line">        <span class="comment">// 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。</span></span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除当前元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们通过entrySet()获取到的Iterator的next()方法去遍历HashMap时，实际上调用的是nextEntry() 。而nextEntry()的实现方式，先遍历Entry(根据Entry在table中的序号，从小到大的遍历)；然后对每个Entry(即每个单向链表)，逐个遍历。</p><h2 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h2><p>JDK 1.8 中的hash方法简便了许多,只做一次16位无符号右位移异或混合，而不是四次，并且1.8中取消了indexFor方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()为哈希算法，返回初始哈希值</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>HashMap和Hashtable的区别</strong></p><ol><li><strong>两者最主要的区别在于Hashtable是线程安全，而HashMap则非线程安全</strong>。Hashtable的实现方法里面都添加了synchronized关键字来确保线程同步，因此相对而言HashMap性能会高一些，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步,当然了实际上操作的还是我们传入的HashMap实例，简单的说就是Collections.synchronizedMap()方法帮我们在操作HashMap时自动添加了synchronized来实现线程同步，类似的其它Collections.synchronizedXX方法也是类似原理）<br>HashMap可以使用null作为key，而Hashtable则不允许null作为key</li><li>虽说HashMap支持null值作为key，不过建议还是尽量避免这样使用，因为一旦不小心使用了，若因此引发一些问题，排查起来很是费事。HashMap以null作为key时，总是存储在table数组的第一个节点上</li><li>HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类</li><li>HashMap的初始容量为16，HashTable初始容量为11，两者的填充因子默认都是0.75。HashMap扩容时是当前容量翻倍即:capacity * 2，Hashtable扩容时是容量翻倍+1即:capacity * 2+1</li><li>HashMap和Hashtable的底层实现都是数组 + 链表结构实现</li><li>JDK1.8引入红黑树大程度优化了HashMap的性能</li><li>HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap</li></ol><p>参考一个介绍HashMap的好的<a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Blog</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> source code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java源码解析 —— LinkedList</title>
      <link href="/2018/03/18/java-source-LinkedList/"/>
      <url>/2018/03/18/java-source-LinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。</p><p>构造图如下:<br>蓝色线条：继承<br>绿色线条：接口实现</p><p><img src="/images/LinkedList.png" alt="LinkedList"></p><h1 id="LinkedList简介"><a href="#LinkedList简介" class="headerlink" title="LinkedList简介"></a>LinkedList简介</h1><p>LinkedList是基于链表结构的一种List，LinkedList就是基于双向链表设计的。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。<br>LinkedList 实现 List 接口，能对它进行队列操作。<br>LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。<br>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。<br>LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。<br>LinkedList 是非同步的。</p><h2 id="LinkedList属性"><a href="#LinkedList属性" class="headerlink" title="LinkedList属性"></a>LinkedList属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>LinkedList中提供了上面三个属性，其中size和ArrayList中一样用来计数，表示list的元素数量；first是链表的第一个节点，last是链表的最后一个节点。Node则是链表的节点对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item; <span class="comment">// 当前存储元素</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">// 下一个元素节点</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">// 上一个元素节点</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node为LinkedList的内部类，其中定义了当前存储的元素，以及该元素的上一个元素和下一个元素。</p><h2 id="LinkedList构造函数"><a href="#LinkedList构造函数" class="headerlink" title="LinkedList构造函数"></a>LinkedList构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构造一个空的LinkedList .</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>();</span><br><span class="line">      addAll(c);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将一个元素添加至list尾部</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 将节点e连至末尾</span></span><br><span class="line">     linkLast(e);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在指定位置添加元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 检查index是否越界</span></span><br><span class="line">     checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (index == size)</span><br><span class="line">         linkLast(element);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         linkBefore(element, node(index));</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 若在前半段，从前往后遍历；反之，从后往前遍历。返回index处的非空节点</span></span><br><span class="line">     <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">         Node&lt;E&gt; x = first;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">             x = x.next;</span><br><span class="line">         <span class="keyword">return</span> x;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;E&gt; x = last;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">             x = x.prev;</span><br><span class="line">         <span class="keyword">return</span> x;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">     first = newNode;</span><br><span class="line">     <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">         last = newNode;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         f.prev = newNode;</span><br><span class="line">     size++;</span><br><span class="line">     modCount++;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">     last = newNode;</span><br><span class="line">     <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">         first = newNode;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         l.next = newNode;</span><br><span class="line">     size++;</span><br><span class="line">     modCount++;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">     succ.prev = newNode;</span><br><span class="line">     <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">         first = newNode;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         pred.next = newNode;</span><br><span class="line">     size++;</span><br><span class="line">     modCount++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加一个集合元素到list中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 将集合元素添加到list最后的尾部</span></span><br><span class="line">     <span class="keyword">return</span> addAll(size, c);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 越界检查</span></span><br><span class="line">     checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">     Object[] a = c.toArray();</span><br><span class="line">     <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">     <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     Node&lt;E&gt; pred, succ;</span><br><span class="line">     <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">         succ = <span class="keyword">null</span>;</span><br><span class="line">         pred = last;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         succ = node(index);</span><br><span class="line">         pred = succ.prev;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">         Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">         <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">             first = newNode;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             pred.next = newNode;</span><br><span class="line">         pred = newNode;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">         last = pred;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         pred.next = succ;</span><br><span class="line">         succ.prev = pred;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     size += numNew;</span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>看似代码逻辑比较复杂，其实核心就是双向链表的存储结构，核心逻辑：</p><ol><li>将元素转换为链表节点；</li><li>增加该节点的前后引用（即prev和next分别指向哪一个节点）；</li><li>前后节点对该节点的引用（前节点的next指向该节点，后节点的prev指向该节点）。</li></ol><p>核心就是改变前后的互相指向关系。删除同理。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要修改该节点上的元素就好了。</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><code>get()</code>方法的主体还是调用了node(int index)方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查找指定索引位置的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     checkElementIndex(index);</span><br><span class="line">     <span class="keyword">return</span> node(index).item;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>为了优化查询效率，LinkedList采用了一次简单的二分，判断index和size中间位置的距离，采取从后向前还是从前向后遍历。</p><p>到这里我们明白，基于双向链表实现的LinkedList，通过索引Index的操作时低效的，<strong>index所对应的元素越靠近中间所费时间越长</strong>。而向链表两端插入和删除元素则是非常高效的（如果不是两端的话，都需要对链表进行遍历查找）。</p><h2 id="是否包含"><a href="#是否包含" class="headerlink" title="是否包含"></a>是否包含</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indexOf查询元素位于容器的索引位置，都是需要对链表进行遍历操作，当然也就是低效了。</p><h2 id="Deque双端队列"><a href="#Deque双端队列" class="headerlink" title="Deque双端队列"></a>Deque双端队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the specified element as the tail (last element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Queue#offer&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list, or &#123;<span class="doctag">@code</span> null&#125; if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null first node f.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves, but does not remove, the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list, or &#123;<span class="doctag">@code</span> null&#125; if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the first element in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the first element in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pushes an element onto the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, inserts the element at the front of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addFirst&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to push</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the beginning of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as first element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Deque的实现还是很简单的，逻辑都是基于上面讲的链表操作的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>LinkedList实际上是通过双向链表去实现的。<br>它包含一个非常重要的内部类：Node。Node是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。</li><li>从LinkedList的实现方式中可以发现，它不存在容量不足的问题。</li><li>LinkedList的克隆函数，即是将全部元素克隆到一个新的LinkedList对象中。</li><li>LinkedList实现java.io.Serializable。当写入到输出流时，先写入“容量”，再依次写入“每一个节点保护的值”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。</li><li>由于LinkedList实现了Deque，而Deque接口定义了在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。</li></ol><h1 id="对LinkedList以及ArrayList的迭代效率比较"><a href="#对LinkedList以及ArrayList的迭代效率比较" class="headerlink" title="对LinkedList以及ArrayList的迭代效率比较"></a>对LinkedList以及ArrayList的迭代效率比较</h1><p>先说结论：<strong>ArrayList使用最普通的for循环遍历比较快，LinkedList使用foreach循环比较快</strong>。</p><p>ArrayList是实现了RandomAccess接口而LinkedList则没有实现这个接口。事实上，<strong>如果使用普通for循环遍历LinkedList，其遍历速度将慢得令人发指</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size; i++) &#123;</span><br><span class="line">    list.get(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foreach or iterator（做foreach的时候，编译器默认使用这个集合的iterator）</span></span><br><span class="line"><span class="keyword">for</span> (Iterator i = list.iterator(); i.hasNext()) &#123;</span><br><span class="line">    i.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们上面说到了LinkedList的get()方法实现，也就不难理解为何使用for循环迭代LinkedList如此之慢了。</p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p><strong>ArrayList和LinkedList的比较</strong></p><ol><li>顺序插入速度ArrayList会比较快，因为ArrayList是基于数组实现的，数组是事先new好的，只要往指定位置塞一个数据就好了；LinkedList则不同，每次顺序插入的时候LinkedList将new一个对象出来，如果对象比较大，那么new的时间势必会长一点，再加上一些引用赋值的操作，所以顺序插入LinkedList必然慢于ArrayList。</li><li>基于上一点，因为LinkedList里面不仅维护了待插入的元素，还维护了Node的前置Node和后继Node，如果一个LinkedList中的Node非常多，那么LinkedList将比ArrayList更耗费一些内存。</li><li>数据遍历的速度，看最后一部分，这里就不细讲了，结论是：<strong>使用各自遍历效率最高的方式，ArrayList的遍历效率会比LinkedList的遍历效率高一些</strong>。</li><li>有些说法认为LinkedList做插入和删除更快，这种说法其实是不准确的：</li></ol><blockquote><ul><li>LinkedList做插入、删除的时候，慢在寻址，快在只需要改变前后Entry的引用地址</li><li>ArrayList做插入、删除的时候，慢在数组元素的批量copy，快在寻址</li></ul></blockquote><p><strong>所以，如果待插入、删除的元素是在数据结构的前半段尤其是非常靠前的位置的时候，LinkedList的效率将大大快过ArrayList，因为ArrayList将批量copy大量的元素；越往后，对于LinkedList来说，因为它是双向链表，所以在第2个元素后面插入一个数据和在倒数第2个元素后面插入一个元素在效率上基本没有差别，但是ArrayList由于要批量copy的元素越来越少，操作速度必然追上乃至超过LinkedList。</strong></p><p>从这个分析看出，如果你十分确定你插入、删除的元素是在前半段，那么就使用LinkedList；如果你十分确定你删除、删除的元素在比较靠后的位置，那么可以考虑使用ArrayList。如果你不能确定你要做的插入、删除是在哪儿呢？那还是建议你使用LinkedList吧，因为一来LinkedList整体插入、删除的执行效率比较稳定，没有ArrayList这种越往后越快的情况；二来插入元素的时候，弄得不好ArrayList就要进行一次扩容，记住，<strong>ArrayList底层数组扩容是一个既消耗时间又消耗空间的操作</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> source code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java源码解析 —— ArrayList</title>
      <link href="/2018/03/15/java-source-ArrayList/"/>
      <url>/2018/03/15/java-source-ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ArrayList继承了AbstractList，实现了List。ArrayList在工作中经常用到，所以要弄懂这个类是极其重要的。</p><p>构造图如下:<br>蓝色线条：继承<br>绿色线条：接口实现</p><p><img src="/images/ArrayList.png" alt="ArrayList.png"></p><h1 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>ArrayList 是一个<strong>数组队列</strong>，相当于<strong>动态数组</strong>。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。</p><p>ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p><p>ArrayList 实现了RandomAccess接口，即提供了随机访问功能。RandomAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。</p><p>ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p><p>ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。</p><p>和Vector不同，<strong>ArrayList中的操作不是线程安全的</strong>！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。</p><h2 id="ArrayList属性"><a href="#ArrayList属性" class="headerlink" title="ArrayList属性"></a>ArrayList属性</h2><p>顾名思义，ArrayList就是用数组实现的List容器，既然是用数组实现，当然底层用数组来保存数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存ArrayList中数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">// ArrayList中实际数据的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>ArrayList包含了两个重要的对象：elementData 和 size。</p><ol><li>elementData 是”Object[]类型的数组”，它保存了添加到ArrayList中的元素。实际上，elementData是个动态数组，我们能通过构造函数<code>ArrayList(int initialCapacity)</code>来执行它的初始容量为initialCapacity；如果通过不含参数的构造函数<code>ArrayList()</code>来创建ArrayList，则elementData的容量默认是<strong>10</strong>。elementData数组的大小会根据ArrayList容量的增长而动态的增长，具体的增长方式，请参考源码分析中的<code>ensureCapacity()</code>函数；</li><li>size 则是动态数组的实际大小。</li></ol><h2 id="ArrayList构造函数"><a href="#ArrayList构造函数" class="headerlink" title="ArrayList构造函数"></a>ArrayList构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList带容量大小的构造函数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 新建一个数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 指向空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList构造函数。默认容量是10。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向空数组</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个包含指定元素的list，这些元素的是按照Collection的迭代器返回的顺序排列的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一个构造方法使用提供的initialCapacity来初始化elementData数组的大小。</li><li>第二个构造方法调用第一个构造方法并传入参数10，即默认elementData数组的大小为10。</li><li>第三个构造方法则将提供的集合转成数组返回给elementData（返回若不是Object[]将调用Arrays.copyOf方法将其转为Object[]）。</li></ul><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 进行扩容检查</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 将e增加至list的数据尾部，容量+1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在指定位置添加一个元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断索引是否越界</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行扩容检查</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 对数组进行复制处理，目的就是空出index的位置插入element，并将index后的元素位移一个位置</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    <span class="comment">// 将指定的index位置赋值为element</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// list容量+1</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加一个集合元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//将c转换为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">//扩容检查</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    <span class="comment">//将c添加至list的数据尾部</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    <span class="comment">//更新当前容器大小</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定位置，增加一个集合元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算需要移动的长度（index之后的元素个数）</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="comment">// 数组复制，空出第index到index+numNum的位置，即将数组index后的元素向右移动numNum个位置</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew, numMoved);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将要插入的集合元素复制到数组空出的位置中</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组容量检查，不够时则进行扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 分配原capacity的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果新扩容的数组长度还是比最小需要的容量小，则以最小需要的容量为长度进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行数据拷贝，Arrays.copyOf底层实现是System.arrayCopy()</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据索引位置删除元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 数组越界检查</span></span><br><span class="line">      rangeCheck(index);</span><br><span class="line"></span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="comment">// 取出要删除位置的元素，供返回使用</span></span><br><span class="line">      E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 计算数组要复制的数量</span></span><br><span class="line">      <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 数组复制，就是将index之后的元素往前移动一个位置</span></span><br><span class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">          System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">          <span class="comment">// 将数组最后一个元素置空（因为删除了一个元素，然后index后面的元素都向前移动了，所以最后一个就没用了），好让gc尽快回收</span></span><br><span class="line">          elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据元素内容删除，只删除匹配的第一个</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 对数据元素进行遍历查找，知道找到第一个要删除的元素，删除后进行返回，如果要删除的元素正好是最后一个那就惨了，时间复杂度可达O(n)</span></span><br><span class="line">      <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="comment">// null值要用==比较</span></span><br><span class="line">              <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  fastRemove(index);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">              <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                  fastRemove(index);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(c);</span><br><span class="line">      <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">      <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">              <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                  elementData[w++] = elementData[r];</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">              System.arraycopy(elementData, r,</span><br><span class="line">                               elementData, w,</span><br><span class="line">                               size - r);</span><br><span class="line">              w += size - r;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">              <span class="comment">// clear to let GC do its work</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                  elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">              modCount += size - w;</span><br><span class="line">              size = w;</span><br><span class="line">              modified = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> modified;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="comment">// 原理和之前的add一样，还是进行数组复制，将index后的元素向前移动一个位置</span></span><br><span class="line">      <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">          System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">      elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码是很简单，主要需要特别关心的就两个地方：</p><ol><li>数组扩容</li><li>数组复制</li></ol><p>这两个操作都是极费效率的，最惨的情况下(添加到list第一个位置，删除list最后一个元素或删除list第一个索引位置的元素)时间复杂度可达O(n)。</p><p>上面讲增加元素可能会进行扩容，而删除元素却不会进行缩容，如果在已删除为主的场景下使用list，一直不停的删除而很少进行增加，那么会出现什么情况？再或者数组进行一次大扩容后，我们后续只使用了几个空间，如何处理这种情况呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将底层数组的容量调整为当前实际元素的大小，来释放空间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 如果当前实际元素大小小于当前数组的容量，则进行缩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size和length是不同的：size是私有变量，只能通过size()来访问，返回当前数组的实际元素大小；length是数组的属性，返回当前数组的容量。</p><h2 id="关于ArrayList删除元素的坑"><a href="#关于ArrayList删除元素的坑" class="headerlink" title="关于ArrayList删除元素的坑"></a>关于ArrayList删除元素的坑</h2><p>关于ArrayList的remove方法，在使用中经常会遇到坑，这也是面试中经常会问的点 —— 输出是什么？为什么会这样？我觉得有必要把它单独拿出来说明一下。</p><p>我们经常遇到的需求是：当集合中的某些元素符合一定的条件时，需要删除这个元素，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">       List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">       Collections.addAll(intList, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>);  </span><br><span class="line">       <span class="comment">// for循环优化写法，只获取一次长度  </span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, size = intList.size(); i &lt; size; i++) &#123;  </span><br><span class="line">           Integer value = intList.get(i);  </span><br><span class="line">           <span class="comment">// 符合条件，删除元素  </span></span><br><span class="line">           <span class="keyword">if</span>(value == <span class="number">3</span> || value == <span class="number">5</span>) &#123;  </span><br><span class="line">              intList.remove(i);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       System.out.println(intList);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行之后，会抛出IndexOutOfBoundsException，因为ArrayList删除掉符合条件的元素后，长度动态发生了改变，由于长度只获取了一次，导致越界。</p><p>去掉for循环优化的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">       List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">       Collections.addAll(intList, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>);  </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intList.size(); i++) &#123;  </span><br><span class="line">           Integer value = intList.get(i);  </span><br><span class="line">           <span class="comment">// 符合条件，删除元素  </span></span><br><span class="line">           <span class="keyword">if</span>(value == <span class="number">3</span> || value == <span class="number">5</span>) &#123;  </span><br><span class="line">              intList.remove(i);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       System.out.println(intList);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：[1, 2, 5, 6]。</p><p>因为在i == 2时，值为3，删除后，后面的元素往前补一位，所以跳过了5。</p><p>使用foreach：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">       List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">       Collections.addAll(intList, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>);  </span><br><span class="line">       <span class="keyword">for</span>(Integer value : intList) &#123;  </span><br><span class="line">           <span class="comment">// 符合条件，删除元素  </span></span><br><span class="line">           <span class="keyword">if</span>(value == <span class="number">3</span> || value == <span class="number">5</span>) &#123;  </span><br><span class="line">              intList.remove(value);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       System.out.println(intList);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后，会抛出ConcurrentModificationException，意思是并发修改异常，异常追踪信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception inthread &quot;main&quot; java.util.ConcurrentModificationException</span><br><span class="line">     atjava.util.AbstractList$Itr.checkForComodification(AbstractList.java:449)</span><br><span class="line">     at java.util.AbstractList$Itr.next(AbstractList.java:420)</span><br><span class="line">     at ListTest.main(ListTest.java:13)</span><br></pre></td></tr></table></figure><p>大概看出是执行到AbstractList中内部类的checkForComodification方法抛出的异常。集合遍历是使用Iterator，Iterator是工作在一个独立的线程中，并且拥有一个互斥锁。Iterator被创建之后会建立一个指向原来对象的<strong>单链索引表</strong>，当原来的对象数量发生变化时，<strong>这个索引表的内容不会同步改变</strong>，所以当索引指针往后移动的时候就找不到要迭代的对象。</p><p>AbstractList$Itr.checkForComodification：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以记住一点：<strong>Iterator在工作的时候是不允许被迭代的对象被改变的</strong>。</p><p>那么正确删除ArrayList元素的姿势是什么呢？这里有三种方法：</p><h3 id="使用Iterator的remove方法"><a href="#使用Iterator的remove方法" class="headerlink" title="使用Iterator的remove方法"></a>使用Iterator的remove方法</h3><p>该方法会删除当前迭代对象的同时，维护索引的一致性。</p><p>Iterator的remove方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">            cursor--;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Iterator删除元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">       List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">       Collections.addAll(intList, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>);  </span><br><span class="line">       Iterator&lt;Integer&gt; it = intList.iterator();  </span><br><span class="line">       <span class="keyword">while</span>(it.hasNext()) &#123;  </span><br><span class="line">           Integer value = it.next();  </span><br><span class="line">           <span class="keyword">if</span>(value == <span class="number">3</span> || value == <span class="number">5</span>) &#123;  </span><br><span class="line">              it.remove();  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       System.out.println(intList);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：[1, 2, 6]。</p><h3 id="自己维护索引"><a href="#自己维护索引" class="headerlink" title="自己维护索引"></a>自己维护索引</h3><p>即，删除元素后，索引-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">       List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">       Collections.addAll(intList, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>);  </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intList.size(); i++) &#123;  </span><br><span class="line">           Integer value = intList.get(i);  </span><br><span class="line">           <span class="keyword">if</span>(value == <span class="number">3</span> || value == <span class="number">5</span>) &#123;  </span><br><span class="line">              intList.remove(i);  </span><br><span class="line">              i--;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">        System.out.println(intList);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：[1, 2, 6]。</p><h3 id="从后向前遍历"><a href="#从后向前遍历" class="headerlink" title="从后向前遍历"></a>从后向前遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">       List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">       Collections.addAll(intList, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>);  </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = intList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">           Integer value = intList.get(i);  </span><br><span class="line">           <span class="keyword">if</span>(value == <span class="number">3</span> || value == <span class="number">5</span>) &#123;  </span><br><span class="line">              intList.remove(i);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">        System.out.println(intList);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：[1, 2, 6]。</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定位置的元素更新为新元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组越界检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出要更新位置的元素，供返回使用</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 将该位置赋值为行的元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 返回旧元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>ArrayList 实际上是通过一个数组去保存数据的。当我们构造ArrayList时；若使用默认构造函数，则ArrayList的默认容量大小是10。</li><li>当ArrayList容量不足以容纳全部元素时，ArrayList会重新设置容量：新的容量=“原始容量 * 1.5”。</li><li>ArrayList的克隆函数，即是将全部元素克隆到一个数组中。</li><li>ArrayList实现java.io.Serializable的方式。当写入到输出流时，先写入“容量”，再依次写入“每一个元素”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。</li></ol><h1 id="ArrayList遍历方式"><a href="#ArrayList遍历方式" class="headerlink" title="ArrayList遍历方式"></a>ArrayList遍历方式</h1><p>ArrayList支持3种遍历方式：</p><h2 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer value = <span class="keyword">null</span>;</span><br><span class="line">Iterator iter = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    value = (Integer)iter.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h2><p>即通过索引值去遍历，由于ArrayList实现了RandomAccess接口，它支持通过索引值去随机访问元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer value = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> size = list.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    value = (Integer)list.get(i);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for-each遍历"><a href="#for-each遍历" class="headerlink" title="for-each遍历"></a>for-each遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer value = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">    value = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历ArrayList时，使用随机访问(即，通过索引序号访问)效率最高，而使用迭代器的效率最低。</strong></p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p><strong>ArrayList和LinkedList的区别</strong></p><ol><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li><li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</li><li>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</li></ol><p><strong>ArrayList和Vector的区别</strong></p><ol><li>Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。</li><li>Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。</li><li>Vector还有一个子类Stack.</li></ol><p>附：集合框架思维导图</p><p><img src="/images/collection.png" alt="collection"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> source code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Comparable和Comparator对比</title>
      <link href="/2018/03/09/java-array-sort/"/>
      <url>/2018/03/09/java-array-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>自定义的类要按照一定的方式进行排序，比如一个Person类要按照年龄进行从小到大排序，比如一个Student类要按照成绩进行由高到低排序。</p><p>这里我们采用两种方式。</p><h2 id="使用Comparable接口"><a href="#使用Comparable接口" class="headerlink" title="使用Comparable接口"></a>使用Comparable接口</h2><p>让待排序对象所在的类实现Comparable接口，并<strong>重写Comparable接口中的compareTo()方法</strong>，缺点是只能按照一种规则排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若在调用Arrays.sort()时，Comparator的参数值为空(如下)，直接调用sort():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">        legacyMergeSort(a);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ComparableTimSort.sort(a, <span class="number">0</span>, a.length, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>legacyMergeSort()中调用compareTo()，这也是为什么我们要重写Comparable接口中的compareTo()方法的原因:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">legacyMergeSort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    Object[] aux = a.clone();</span><br><span class="line">    mergeSort(aux, a, <span class="number">0</span>, a.length, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Object[] src,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Object[] dest,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> low,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> high,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> off)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = high - low;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insertion sort on smallest arrays</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;high; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;low &amp;&amp;</span><br><span class="line">                     ((Comparable) dest[j-<span class="number">1</span>]).compareTo(dest[j])&gt;<span class="number">0</span>; j--)</span><br><span class="line">                swap(dest, j, j-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively sort halves of dest into src</span></span><br><span class="line">    <span class="keyword">int</span> destLow  = low;</span><br><span class="line">    <span class="keyword">int</span> destHigh = high;</span><br><span class="line">    low  += off;</span><br><span class="line">    high += off;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(dest, src, low, mid, -off);</span><br><span class="line">    mergeSort(dest, src, mid, high, -off);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If list is already sorted, just copy from src to dest.  This is an</span></span><br><span class="line">    <span class="comment">// optimization that results in faster sorts for nearly ordered lists.</span></span><br><span class="line">    <span class="keyword">if</span> (((Comparable)src[mid-<span class="number">1</span>]).compareTo(src[mid]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        System.arraycopy(src, low, dest, destLow, length);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge sorted halves (now in src) into dest</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=<span class="number">0</span>)</span><br><span class="line">            dest[i] = src[p++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dest[i] = src[q++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Comparator接口"><a href="#使用Comparator接口" class="headerlink" title="使用Comparator接口"></a>使用Comparator接口</h2><p>编写多个排序方式类实现Comparator接口，并<strong>重写新Comparator接口中的compare()方法</strong>，在调用Arrays的sort()时<strong>将排序类对象作为参数传入</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Arrays.sort()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sort(a);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据指定比较器产生的顺序对指定对象数组进行排序。数组中的所有元素都必须是通过指定比较器可相互比较的(也就是说，对于数组中的任何e1和e2元素而言，c.compare(e1, e2)不得抛出ClassCastException)。</p><p>优点是可以按照多种方式排序，你要按照什么方式排序，就创建一个实现Comparator接口的排序方式类，然后将该排序类的对象传入到Arrays.sort(待排序对象，该排序方式类的对象)。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="使用Comparable接口-1"><a href="#使用Comparable接口-1" class="headerlink" title="使用Comparable接口"></a>使用Comparable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 使用Comparable接口：让待排序对象所在的类实现Comparable接口，并重写Comparable接口中的compareTo()方法 </span></span><br><span class="line"><span class="comment"> * 缺点是只能按照一种规则排序 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSort</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Person[] persons = <span class="keyword">new</span> Person[<span class="number">5</span>];  </span><br><span class="line">        persons[<span class="number">0</span>] =<span class="keyword">new</span> Person(<span class="string">"tom"</span>,<span class="number">45</span>);  </span><br><span class="line">        persons[<span class="number">1</span>] =<span class="keyword">new</span> Person(<span class="string">"jack"</span>,<span class="number">12</span>);  </span><br><span class="line">        persons[<span class="number">2</span>] =<span class="keyword">new</span> Person(<span class="string">"bill"</span>,<span class="number">21</span>);  </span><br><span class="line">        persons[<span class="number">3</span>] =<span class="keyword">new</span> Person(<span class="string">"kandy"</span>,<span class="number">34</span>);  </span><br><span class="line">        persons[<span class="number">4</span>] =<span class="keyword">new</span> Person();  </span><br><span class="line">        Arrays.sort(persons);  </span><br><span class="line">        <span class="keyword">for</span> (Person person : persons) &#123;  </span><br><span class="line">            System.out.println(person);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"unknown"</span>, <span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//重写该类的compareTo()方法，使其按照从小到大顺序排序  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> age - o.age;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//重写Student类的toString()方法，在输入对象时按照以下方式输出  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person[name:"</span>+name+<span class="string">",age:"</span>+age+<span class="string">"]"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Comparator接口-1"><a href="#使用Comparator接口-1" class="headerlink" title="使用Comparator接口"></a>使用Comparator接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;  </span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 使用Comparator接口：编写多个排序方式类实现Comparator接口，并重写新Comparator接口中的compare()方法 </span></span><br><span class="line"><span class="comment"> * public static &lt;T&gt; void sort(T[] a,Comparator&lt;? super T&gt; c),根据指定比较器产生的顺序对指定对象数组进行排序。数组中的所有元素都必须是通过指定比较器可相互比较的 </span></span><br><span class="line"><span class="comment"> * （也就是说，对于数组中的任何 e1 和 e2 元素而言，c.compare(e1, e2) 不得抛出 ClassCastException）。 </span></span><br><span class="line"><span class="comment"> * 优点是可以按照多种方式排序，你要按照什么方式排序，就创建一个实现Comparator接口的排序方式类，然后将该排序类的对象传入到Arrays.sort(待排序对象，该排序方式类的对象) </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorUse</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Student[] persons = <span class="keyword">new</span> Student[<span class="number">5</span>];  </span><br><span class="line">        persons[<span class="number">0</span>] =<span class="keyword">new</span> Student(<span class="string">"tom"</span>,<span class="number">1</span>,<span class="number">88</span>,<span class="number">45</span>);  </span><br><span class="line">        persons[<span class="number">1</span>] =<span class="keyword">new</span> Student(<span class="string">"jack"</span>,<span class="number">6</span>,<span class="number">80</span>,<span class="number">12</span>);  </span><br><span class="line">        persons[<span class="number">2</span>] =<span class="keyword">new</span> Student(<span class="string">"bill"</span>,<span class="number">4</span>,<span class="number">68</span>,<span class="number">21</span>);  </span><br><span class="line">        persons[<span class="number">3</span>] =<span class="keyword">new</span> Student(<span class="string">"kandy"</span>,<span class="number">2</span>,<span class="number">98</span>,<span class="number">34</span>);  </span><br><span class="line">        persons[<span class="number">4</span>] =<span class="keyword">new</span> Student(<span class="string">"lily"</span>,<span class="number">5</span>,<span class="number">94</span>,<span class="number">20</span>);  </span><br><span class="line">        System.out.println(<span class="string">"排序前的数据："</span>);  </span><br><span class="line">        <span class="keyword">for</span> (Student student : persons) &#123;  </span><br><span class="line">            System.out.println(student);  </span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建SortByNumber对象，将其作为参数传入Arrays.sort(persons, sortByNumber)方法中  </span></span><br><span class="line">        SortByNumber sortByNumber = <span class="keyword">new</span> SortByNumber();  </span><br><span class="line">        Arrays.sort(persons, sortByNumber);  </span><br><span class="line">        System.out.println(<span class="string">"根据学生编号由低到高排序："</span>);  </span><br><span class="line">        <span class="keyword">for</span> (Student student : persons) &#123;  </span><br><span class="line">            System.out.println(student);  </span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">        SortByScore sortByScore = <span class="keyword">new</span> SortByScore();  </span><br><span class="line">        Arrays.sort(persons, sortByScore);  </span><br><span class="line">        System.out.println(<span class="string">"根据学生成绩由高到低排序："</span>);  </span><br><span class="line">        <span class="keyword">for</span> (Student student : persons) &#123;  </span><br><span class="line">            System.out.println(student);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> number, <span class="keyword">int</span> score, <span class="keyword">int</span> age)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.number = number;  </span><br><span class="line">        <span class="keyword">this</span>.score = score;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//重写Student类的toString()方法，在输入对象时按照以下方式输出  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student[name:"</span>+name+<span class="string">",age:"</span>+age+<span class="string">",number:"</span>+number+<span class="string">",score:"</span>+score+<span class="string">"]"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> number;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.number = number;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> score;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.score = score;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//按照学号由低到高排列,创建SortByNumber类，该类实现Comparator，重写该接口的compare()  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortByNumber</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student</span>&gt;</span>&#123;  </span><br><span class="line">    <span class="comment">//重写该接口的compare()使其按照学号由小到大排序（前者减去后者）  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> o1.getNumber() - o2.getNumber();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//按照分数由高到低排列，创建SortByScore类，该类实现Comparator，重写该接口的compare()  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortByScore</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student</span>&gt;</span>&#123;  </span><br><span class="line">    <span class="comment">//重写该接口的compare()使其按照分数由高到低排序（后者减去前者）  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> o2.getScore() - o1.getScore();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Arrays-sort-实现原理"><a href="#Arrays-sort-实现原理" class="headerlink" title="Arrays.sort()实现原理"></a>Arrays.sort()实现原理</h1><p>既然说了这么多，还是分析一下Arrays.sort()的实现原理吧。java中Arrays.sort()使用了两种排序方法，<strong>快速排序和优化的归并排序</strong>。快速排序主要是对那些<strong>基本类型数据</strong>(int, short, long等)排序，而归并排序用于对<strong>对象类型</strong>进行排序。</p><p>使用不同类型的排序算法主要是由于<strong>快速排序是不稳定的</strong>，而<strong>归并排序是稳定的</strong>。这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。对于基本数据类型，稳定性没有意义，而对于对象类型，稳定性是比较重要的，因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的顺序与排序前一致；另外一个原因是由于归并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，比较一般比移动耗时。</p><p>归并排序的时间复杂度是n*logn, 快速排序的平均时间复杂度也是n*logn，但是归并排序的需要额外的n个引用的空间。</p><p>我们注意到在上面提到的<code>sort(T[] a, Comparator&lt;? super T&gt; c)</code>。sort的第2个参数里面的&lt;? super T&gt;意味着比较器所接受的类型可以是T或者它的超类. 为什么是超类呢? 答案是这允许使用同一个比较器对不同的子类对象进行比较。</p><h2 id="基本类型源码"><a href="#基本类型源码" class="headerlink" title="基本类型源码"></a>基本类型源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sorts the specified array into ascending numerical order.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span></span><br><span class="line"><span class="comment">     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</span></span><br><span class="line"><span class="comment">     * offers O(n log(n)) performance on many data sets that cause other</span></span><br><span class="line"><span class="comment">     * quicksorts to degrade to quadratic performance, and is typically</span></span><br><span class="line"><span class="comment">     * faster than traditional (one-pivot) Quicksort implementations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a the array to be sorted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从名字可见确实是快排。</p><h2 id="对象类型源码"><a href="#对象类型源码" class="headerlink" title="对象类型源码"></a>对象类型源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">        legacyMergeSort(a);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ComparableTimSort.sort(a, <span class="number">0</span>, a.length, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ComparableTimSort.sort:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Object[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> a != <span class="keyword">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nRemaining  = hi - lo;</span><br><span class="line">    <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// Arrays of size 0 and 1 are always sorted</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If array is small, do a "mini-TimSort" with no merges</span></span><br><span class="line">    <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">        <span class="keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi);</span><br><span class="line">        binarySort(a, lo, hi, lo + initRunLen);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * March over the array once, left to right, finding natural runs,</span></span><br><span class="line"><span class="comment">     * extending short natural runs to minRun elements, and merging runs</span></span><br><span class="line"><span class="comment">     * to maintain stack invariant.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ComparableTimSort ts = <span class="keyword">new</span> ComparableTimSort(a, work, workBase, workLen);</span><br><span class="line">    <span class="keyword">int</span> minRun = minRunLength(nRemaining);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// Identify next run</span></span><br><span class="line">        <span class="keyword">int</span> runLen = countRunAndMakeAscending(a, lo, hi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If run is short, extend to min(minRun, nRemaining)</span></span><br><span class="line">        <span class="keyword">if</span> (runLen &lt; minRun) &#123;</span><br><span class="line">            <span class="keyword">int</span> force = nRemaining &lt;= minRun ? nRemaining : minRun;</span><br><span class="line">            binarySort(a, lo, lo + force, lo + runLen);</span><br><span class="line">            runLen = force;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Push run onto pending-run stack, and maybe merge</span></span><br><span class="line">        ts.pushRun(lo, runLen);</span><br><span class="line">        ts.mergeCollapse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Advance to find next run</span></span><br><span class="line">        lo += runLen;</span><br><span class="line">        nRemaining -= runLen;</span><br><span class="line">    &#125; <span class="keyword">while</span> (nRemaining != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge all remaining runs to complete sort</span></span><br><span class="line">    <span class="keyword">assert</span> lo == hi;</span><br><span class="line">    ts.mergeForceCollapse();</span><br><span class="line">    <span class="keyword">assert</span> ts.stackSize == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里发现如果元素少于MIN_MERGE == 32采用binarySort(二分排序)；后面还有些判断bla bla，最后采用mergeForceCollapse(归并排序)。</p><p>我们之后会看到<code>Java.util.Collections#sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>与<code>Arrays.sort()</code>使用类似的思想。</p><p>BTW，有些东西还是要看源码才清楚的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CMS垃圾回收分析</title>
      <link href="/2017/09/16/cms-gc-analysis/"/>
      <url>/2017/09/16/cms-gc-analysis/</url>
      
        <content type="html"><![CDATA[<p>继上次对于JVM原理以及各种垃圾算法进行说明，本文主要对于CMS的回收过程以及日志进行分析。</p><h1 id="JVM配置"><a href="#JVM配置" class="headerlink" title="JVM配置"></a>JVM配置</h1><blockquote><p>-Xms3g -Xmx3g<br>-XX:+UseConcMarkSweepGC<br>-XX:CMSMaxAbortablePrecleanTime=5000<br>-XX:+CMSClassUnloadingEnabled<br>-XX:CMSInitiatingOccupancyFraction=80 (old区百分之80触发cms gc,跟UseCMSInitiatingOccupancyOnly一起配合使用)<br>-XX:+UseCMSInitiatingOccupancyOnly</p></blockquote><h1 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h1><blockquote><p>2017-05-15T02:23:07.219-0200<strong>[1]</strong> : 64.322<strong>[2]</strong> :[GC<strong>[3]</strong> (Allocation Failure<strong>[4]</strong> ) 64.322: [ParNew<strong>[5]</strong> : 274061K-&gt;1740K<strong>[6]</strong> (306688K)<strong>[7]</strong> , 0.0186772 secs<strong>[8]</strong> ] 1027804K-&gt;755578K<strong>[9]</strong> (3111680K)<strong>[10]</strong> , 0.0190341 secs<strong>[11]</strong> ][Times: user=0.08 sys=0.01, real=0.01 secs]<strong>[12]</strong></p></blockquote><ol><li>2017-05-15T02:23:07.219-0200 – GC发生的时间；</li><li>64.322 – GC开始，相对JVM启动的相对时间，单位是秒；</li><li>GC – 区别MinorGC和FullGC的标识，这次代表的是MinorGC;</li><li>Allocation Failure – MinorGC的原因，在这个case里边，由于年轻代不满足申请的空间，因此触发了MinorGC;</li><li>ParNew – 收集器的名称，它预示了年轻代使用一个并行的 mark-copy stop-the-world 垃圾收集器；</li><li>274061K-&gt;1740K – 收集前后年轻代的使用情况；</li><li>(306688K) – 整个年轻代的容量；</li><li>0.0186772 secs 耗时</li><li>1027804K-&gt;755578K – 收集前后整个堆的使用情况；</li><li>3111680K 整个堆的容量；</li><li>0.0190341 secs – ParNew收集器标记和复制年轻代活着的对象所花费的时间（包括和老年代通信的开销、对象晋升到老年代时间、垃圾收集周期结束一些最后的清理对象等的花销）；</li><li>[Times: user=0.78 sys=0.01, real=0.11 secs] – GC事件在不同维度的耗时，</li></ol><blockquote><ol><li>user – Total CPU time that was consumed by Garbage Collector threads during this collection</li><li>sys – Time spent in OS calls or waiting for system event</li><li>real – Clock time for which your application was stopped. With Parallel GC this number should be close to (user time + system time) divided by the number of threads used by the Garbage Collector. In this particular case 8 threads were used. Note that due to some activities not being parallelizable, it always exceeds the ratio by a certain amount.</li></ol></blockquote><p>开始的时候：整个堆的大小是 1027804K，年轻代大小是274061K，这说明老年代大小是 1027804K-274061K=753743k，<br>收集完成之后：整个堆的大小是 755578K，年轻代大小是1740K，这说明老年代大小是 755578K-1740K=753838k，<br>老年代的大小增加了：753838k-753743k=95k，也就是说 年轻代到年老代promot了95k的数据；</p><p><img src="/images/cms_gc.png" alt="cmc_gc"></p><h1 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h1><blockquote><p>4391.322: [GC [1 CMS-initial-mark: 655374K(1310720K)] 662197K(1546688K), 0.0303050 secs] [Times: user=0.02 sys=0.02, real=0.03 secs]<br>4391.352: [CMS-concurrent-mark-start]4391.779: [CMS-concurrent-mark: 0.427/0.427 secs] [Times: user=1.24 sys=0.31, real=0.42 secs]<br>4391.779: [CMS-concurrent-preclean-start]<br>4391.821: [CMS-concurrent-preclean: 0.040/0.042 secs] [Times: user=0.13 sys=0.03, real=0.05 secs]<br>4391.821: [CMS-concurrent-abortable-preclean-start]<br>4392.511: [CMS-concurrent-abortable-preclean: 0.349/0.690 secs] [Times: user=2.02 sys=0.51, real=0.69 secs]<br>4392.516: [GC[YG occupancy: 111001 K (235968 K)]<br>4392.516: [Rescan (parallel) , 0.0309960 secs]<br>4392.547: [weak refs processing, 0.0417710 secs] [1 CMS-remark: 655734K(1310720K)] 766736K(1546688K), 0.0932010 secs] [Times: user=0.17 sys=0.00, real=0.09 secs]<br>4392.609: [CMS-concurrent-sweep-start]<br>4394.310: [CMS-concurrent-sweep: 1.595/1.701 secs] [Times: user=4.78 sys=1.05, real=1.70 secs]<br>4394.310: [CMS-concurrent-reset-start]<br>4394.364: [CMS-concurrent-reset: 0.054/0.054 secs] [Times: user=0.14 sys=0.06, real=0.06 secs]</p></blockquote><h2 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h2><blockquote><ul><li>触发动作</li><li>初始标记(CMS-initial-mark)</li><li>并发标记(Concurrent marking)</li><li>并发预清理(Concurrent precleaning)</li><li>重新标记(STW remark)</li><li>并发清理(Concurrent sweeping)</li><li>并发重置(Concurrent reset)</li></ul></blockquote><h3 id="触发动作"><a href="#触发动作" class="headerlink" title="触发动作"></a>触发动作</h3><p>根据CMSInitiatingOccupancyFraction,UseCMSInitiatingOccupancyOnly来决定什么时间开始垃圾收集。</p><p>如果没有设置-XX:+UseCMSInitiatingOccupancyOnly，那么系统会根据统计数据自行决定什么时候触发cms gc。</p><h3 id="CMS-initial-mark"><a href="#CMS-initial-mark" class="headerlink" title="CMS-initial-mark"></a>CMS-initial-mark</h3><p>此阶段是初始标记阶段，是stop the world阶段，垃圾回收的”根对象”开始，只扫描到能够和”根对象”直接关联的对象，并作标记;</p><p><img src="/images/cms_init_mark.png" alt="cms_init_mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMS-initial-mark：961330K（1572864K），指标记时，old代的已用空间和总空间</span><br></pre></td></tr></table></figure><h3 id="CMS-concurrent-mark"><a href="#CMS-concurrent-mark" class="headerlink" title="CMS-concurrent-mark"></a>CMS-concurrent-mark</h3><p>阶段是和应用线程并发执行的，主要作用是在初始标记的基础上继续向下追溯标记,标记可达的对象.<br>这个阶段会遍历整个老年代并且标记所有存活的对象，从“初始化标记”阶段找到的GC Roots开始。并不是老年代的所有存活对象都会被标记，因为标记的同时应用程序会改变一些对象的引用等。</p><p><img src="/images/cms_concurrent_mark.png" alt="cms_concurrent_mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMS-concurrent-mark-start</span><br><span class="line">CMS-concurrent-mark</span><br></pre></td></tr></table></figure><h3 id="Concurrent-precleaning"><a href="#Concurrent-precleaning" class="headerlink" title="Concurrent-precleaning"></a>Concurrent-precleaning</h3><p>前一个阶段在并行运行的时候，一些对象的引用已经发生了变化，当这些引用发生变化的时候，JVM会标记堆的这个区域为Dirty Card(包含被标记但是改变了的对象，被认为”dirty”)，这就是 Card Marking。</p><p><img src="/images/concurrent_precleaning.png" alt="concurrent_precleaning"></p><p>那些能够从dirty card对象到达的对象也会被标记，这个标记做完之后，dirty card标记就会被清除了。</p><p><img src="/images/dirty_card_cleaning.png" alt="dirty_card_cleaning"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMS-concurrent-mark-start</span><br><span class="line">CMS-concurrent-mark</span><br></pre></td></tr></table></figure><h3 id="Abortable-preclean"><a href="#Abortable-preclean" class="headerlink" title="Abortable-preclean"></a>Abortable-preclean</h3><p>这个阶段尝试着去承担STW的Final Remark阶段足够多的工作。这个阶段持续的时间依赖好多的因素，由于这个阶段是重复的做相同的事情直到发生aboart的条件（比如：重复的次数、多少量的工作、持续的时间等等）之一才会停止。</p><blockquote><p>此阶段涉及几个参数：<br>-XX:CMSMaxAbortablePrecleanTime：当abortable-preclean阶段执行达到这个时间时才会结束<br>-XX:CMSScheduleRemarkEdenSizeThreshold（默认2m）：控制abortable-preclean阶段什么时候开始执行， 即当eden使用达到此值时，才会开始abortable-preclean阶段<br>-XX:CMSScheduleRemarkEdenPenetratio（默认50%）：控制abortable-preclean阶段什么时候结束执行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMS-concurrent-abortable-preclean-start</span><br><span class="line">CMS-concurrent-abortable-preclean</span><br></pre></td></tr></table></figure><h3 id="Final-remark"><a href="#Final-remark" class="headerlink" title="Final-remark"></a>Final-remark</h3><p>第二个stop the world阶段了，此阶段暂停应用线程，对对象进行重新扫描并标记。由于之前的预处理是并发的，它可能跟不上应用程序改变的速度，这个时候，STW是非常需要的来完成这个严酷考验的阶段。</p><blockquote><p>YG occupancy：964861K（2403008K），指执行时young代的情况<br>CMS remark：961330K（1572864K），指执行时old代的情况</p></blockquote><h3 id="Sweeping"><a href="#Sweeping" class="headerlink" title="Sweeping"></a>Sweeping</h3><p>这个阶段的目的就是移除那些不用的对象，回收他们占用的空间并且为将来使用。</p><p><img src="/images/sweeping.png" alt="sweeping"></p><h3 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h3><p>这个阶段并发执行，重新设置CMS算法内部的数据结构，准备下一个CMS生命周期的使用。</p><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full-GC"></a>Full-GC</h3><p>有2种情况会触发full gc，在full gc时，整个应用会暂停。</p><ul><li>concurrent-mode-failure：当cms gc正进行时，此时有新的对象要进行old代，但是old代空间不足造成的；</li><li>promotion-failed：当进行young gc时，有部分young代对象仍然可用，但是S1或S2放不下，因此需要放到old代，但此时old代空间无法容纳这些对象。</li></ul><blockquote><p>影响cms gc时长及触发的参数是以下2个：<br>-XX:CMSMaxAbortablePrecleanTime=5000<br>-XX:CMSInitiatingOccupancyFraction=80<br>解决也是针对这两个参数来的，根本的原因是每次请求消耗的内存量过大解决方式：</p></blockquote><blockquote><ul><li>针对cms gc的触发阶段，调整</li><li>XX:CMSInitiatingOccupancyFraction=50，提早触发cms gc，就可以缓解当old代达到80%，cms gc处理不完，从而造成concurrent mode failure引发full gc</li><li>修改-XX:CMSMaxAbortablePrecleanTime=500，缩小CMS-concurrent-abortable-preclean阶段的时间</li><li>考虑到cms gc时不会进行compact，因此加入</li><li>XX:+UseCMSCompactAtFullCollection （cms gc后会进行内存的compact）和-XX:CMSFullGCsBeforeCompaction=4（在full gc4次后会进行compact）参数</li></ul></blockquote><h1 id="CMS缺点"><a href="#CMS缺点" class="headerlink" title="CMS缺点"></a>CMS缺点</h1><blockquote><ul><li>CMS回收器采用的基础算法是Mark-Sweep。所以CMS不会整理、压缩堆空间。这样就会有一个问题：经过CMS收集的堆会产生空间碎片。 CMS不对堆空间整理压缩节约了垃圾回收的停顿时间，但也带来的堆空间的浪费。为了解决堆空间浪费问题，CMS回收器不再采用简单的指针指向一块可用堆空 间来为下次对象分配使用。而是把一些未分配的空间汇总成一个列表，当JVM分配对象空间的时候，会搜索这个列表找到足够大的空间来hold住这个对象。</li><li>需要更多的CPU资源。从上面的图可以看到，为了让应用程序不停顿，CMS线程和应用程序线程并发执行，这样就需要有更多的CPU，单纯靠线程切 换是不靠谱的。并且，重新标记阶段，为空保证STW快速完成，也要用到更多的甚至所有的CPU资源。当然，多核多CPU也是未来的趋势！</li><li>CMS的另一个缺点是它需要更大的堆空间。因为CMS标记阶段应用程序的线程还是在执行的，那么就会有堆空间继续分配的情况，为了保证在CMS回 收完堆之前还有空间分配给正在运行的应用程序，必须预留一部分空间。也就是说，CMS不会在老年代满的时候才开始收集。相反，它会尝试更早的开始收集，以避免上面提到的情况：在回收完成之前，堆没有足够空间分配！默认当老年代使用68%的时候，CMS就开始行动了。 通过–XX:CMSInitiatingOccupancyFraction = n 来设置这个阀值。</li></ul></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，CMS回收器减少了回收的停顿时间，但是降低了堆空间的利用率。<br>如果你的应用程序对停顿比较敏感，并且在应用程序运行的时候可以提供更大的内存和更多的CPU(也就是硬件牛逼)，那么使用CMS来收集会给你带来好处。还有，如果在JVM中，有相对较多存活时间较长的对象(老年代比较大)会更适合使用CMS。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> GC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM调优（四） - 分代GC详解</title>
      <link href="/2017/09/10/jvm-generation-GC/"/>
      <url>/2017/09/10/jvm-generation-GC/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要分代"><a href="#为什么要分代" class="headerlink" title="为什么要分代"></a>为什么要分代</h1><p>分代的垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p>试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用<strong>分治</strong>的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</p><h1 id="如何分代"><a href="#如何分代" class="headerlink" title="如何分代"></a>如何分代</h1><p><img src="/images/GC_generation.jpg" alt="GC_generation"></p><p>如上图所示：</p><p>虚拟机中的共划分为三个代：<strong>年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation）</strong>。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。</p><p>一个关于分代的比喻很形象：</p><p>“假设你是一个普通的 Java 对象，你出生在 Eden 区，在 Eden 区有许多和你差不多的小兄弟、小姐妹，可以把 Eden 区当成幼儿园，在这个幼儿园里大家玩了很长时间。Eden 区不能无休止地放你们在里面，所以当年纪稍大，你就要被送到学校去上学，这里假设从小学到高中都称为 Survivor 区。开始的时候你在 Survivor 区里面划分出来的的“From”区，读到高年级了，就进了 Survivor 区的“To”区，中间由于学习成绩不稳定，还经常来回折腾。直到你 18 岁的时候，高中毕业了，该去社会上闯闯了。于是你就去了年老代，年老代里面人也很多。在年老代里，你生活了 20 年 (每次 GC 加一岁)，最后寿终正寝，被 GC 回收。有一点没有提，你在年老代遇到了一个同学，他的名字叫爱德华 (慕光之城里的帅哥吸血鬼)，他以及他的家族永远不会死，那么他们就生活在永生代。”</p><h2 id="Young-Generation"><a href="#Young-Generation" class="headerlink" title="Young Generation"></a>Young Generation</h2><p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。</p><p>需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor区过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p><h2 id="Old-Generation"><a href="#Old-Generation" class="headerlink" title="Old Generation"></a>Old Generation</h2><p>在年轻代中经历了N次回收后仍然没有被清除的对象，就会被放到年老代中，可以说他们都是久经沙场而不亡的一代，都是生命周期较长的对象。对于年老代和永久代，就不能再采用像年轻代中那样搬移腾挪的回收算法，因为那些对于这些回收战场上的老兵来说是小儿科。通常会在老年代内存被占满时将会触发Full GC,回收整个堆内存。</p><h2 id="Permanent-Generation"><a href="#Permanent-Generation" class="headerlink" title="Permanent Generation"></a>Permanent Generation</h2><p>用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p><p>持久代大小通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxPermSize&#x3D;&lt;N&gt;</span><br></pre></td></tr></table></figure><p>进行设置。</p><h1 id="什么情况下触发GC"><a href="#什么情况下触发GC" class="headerlink" title="什么情况下触发GC"></a>什么情况下触发GC</h1><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：<strong>Scavenge GC</strong> 和 <strong>Full GC</strong>。</p><h2 id="Scavenge-GC"><a href="#Scavenge-GC" class="headerlink" title="Scavenge GC"></a>Scavenge GC</h2><p>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden区能尽快空闲出来。</p><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：</p><ul><li>年老代（Tenured）被写满</li><li>持久代（Perm）被写满</li><li>System.gc()被显式调用</li><li>上一次GC之后Heap的各域分配策略动态变化</li></ul><h1 id="分代过程"><a href="#分代过程" class="headerlink" title="分代过程"></a>分代过程</h1><p>下面一组图片展示了JVM垃圾回收的一般过程，从对象分配到对象逐渐变老。</p><p>1、首先，所有新生成的对象都是放在年轻代的Eden分区的，初始状态下两个Survivor分区都是空的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</p><p><img src="/images/object_allocation.jpg" alt="object_allocation"></p><p>2、当Eden区满的的时候，小垃圾收集就会被触发。</p><p><img src="/images/eden_full.jpg" alt="eden_full"></p><p>3、当Eden分区进行清理的时候，会把引用对象移动到第一个Survivor分区，无引用的对象删除。</p><p><img src="/images/copy_reference_objects.jpg" alt="copy_reference_objects"></p><p>4、在下一个小垃圾收集的时候，在Eden分区中会发生同样的事情：无引用的对象被删除，引用对象被移动到另外一个Survivor分区（S1）。此外，从上次小垃圾收集过程中第一个Survivor分区（S0）移动过来的对象年龄增加，然后被移动到S1。当所有的幸存对象移动到S1以后，S0和Eden区都会被清理。注意到，此时的Survivor分区存储有不同年龄的对象。</p><p><img src="/images/object_aging.jpg" alt="object_aging"></p><p>5、在下一个小垃圾收集，同样的过程反复进行。然而，此时Survivor分区的角色发生了互换，引用对象被移动到S0，幸存对象年龄增大。Eden和S1被清理。</p><p><img src="/images/additional_aging.jpg" alt="additional_aging"></p><p>6、这幅图展示了从年轻代到老年代的提升。当进行一个小垃圾收集之后，如果此时年老对象此时到达了某一个个年龄阈值（例子中使用的是8），JVM会把他们从年轻代提升到老年代。</p><p><img src="/images/promotion.jpg" alt="promotion"></p><p>7、随着小垃圾收集的持续进行，对象将会被持续提升到老年代。</p><p><img src="/images/generation_promotion.jpg" alt="generation_promotion"></p><p>8、这样几乎涵盖了年轻一代的整个过程。最终，在老年代将会进行大垃圾收集，这种收集方式会清理-压缩老年代空间。</p><p><img src="/images/GC_process_summary.jpg" alt="GC_process_summary"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本系列对Java中的JVM进行了较为详细的介绍。我们知道了堆和垃圾收集器在Java JVM中是非常重要的部分。自动的垃圾收集是通过分代垃圾收集的方法来完成的。一旦我们知道了这一原理，我们就可以通过Visual VM虚拟机工具来观察整个过程。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
          <category> GC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM调优（三） - GC面临的问题</title>
      <link href="/2017/08/27/jvm-GC-problems/"/>
      <url>/2017/08/27/jvm-GC-problems/</url>
      
        <content type="html"><![CDATA[<h1 id="如何区分垃圾"><a href="#如何区分垃圾" class="headerlink" title="如何区分垃圾"></a>如何区分垃圾</h1><p>上面说到的“引用计数”法，通过统计控制生成对象和删除对象时的引用数来判断。垃圾回收程序收集<strong>计数为0</strong>的对象即可。但是这种方法无法解决循环引用。</p><p>所以，后来实现的垃圾判断算法中，都是从程序运行的根节点出发，遍历整个对象引用，查找存活的对象。那么在这种方式的实现中，垃圾回收从哪儿开始的呢？即，从哪儿开始查找哪些对象是正在被当前系统使用的。</p><p>上面分析的堆和栈的区别，其中栈是真正进行程序执行地方，所以要获取哪些对象正在被使用，则需要从Java栈开始。同时，一个栈是与一个线程对应的，因此，如果有多个线程的话，则必须对这些线程对应的所有的栈进行检查。</p><p>同时，除了栈外，还有系统运行时的寄存器等，也是存储程序运行数据的。这样，以栈或寄存器中的引用为起点，我们可以找到堆中的对象，又从这些对象找到对堆中其他对象的引用，这种引用逐步扩展，最终以null引用或者基本类型结束，这样就形成了一颗以Java栈中引用所对应的对象为根节点的一颗对象树，如果栈中有多个引用，则最终会形成多颗对象树。在这些对象树上的对象，都是当前系统运行所需要的对象，不能被垃圾回收。而其他剩余对象，则可以视为无法被引用到的对象，可以被当做垃圾进行回收。</p><p>因此，垃圾回收的起点是一些根对象（java栈, 静态变量, 寄存器…）。而最简单的Java栈就是Java程序执行的main函数。这种回收方式，也是上面提到的“标记-清除”的回收方式。</p><h1 id="如何处理碎片"><a href="#如何处理碎片" class="headerlink" title="如何处理碎片"></a>如何处理碎片</h1><p>由于不同Java对象存活时间是不一定的，因此，在程序运行一段时间以后，如果不进行内存整理，就会出现零散的内存碎片。碎片最直接的问题就是会导致无法分配大块的内存空间，以及程序运行效率降低。</p><p>在上面提到的基本垃圾回收算法中，“复制”方式和“标记-整理”方式，都可以解决碎片的问题。</p><h1 id="如何解决同时存在的对象创建和对象回收问题"><a href="#如何解决同时存在的对象创建和对象回收问题" class="headerlink" title="如何解决同时存在的对象创建和对象回收问题"></a>如何解决同时存在的对象创建和对象回收问题</h1><p>垃圾回收线程是回收内存的，而程序运行线程则是消耗（或分配）内存的，一个回收内存，一个分配内存，从这点看，两者是矛盾的。因此，在现有的垃圾回收方式中，要进行垃圾回收前，一般都需要暂停整个应用（即：暂停内存的分配），然后进行垃圾回收，回收完成后再继续应用。这种实现方式是最直接，而且最有效的解决二者矛盾的方式。</p><p>但是这种方式有一个很明显的<strong>弊端</strong>，就是当堆空间持续增大时，垃圾回收的时间也将会相应的持续增大，对应应用暂停的时间也会相应的增大。一些对相应时间要求很高的应用，比如最大暂停时间要求是几百毫秒，那么当堆空间大于几个G时，就很有可能超过这个限制，在这种情况下，垃圾回收将会成为系统运行的一个瓶颈。</p><p>为解决这种矛盾，有了并发垃圾回收算法，使用这种算法，垃圾回收线程与程序运行线程同时运行。在这种方式下，解决了暂停的问题，但是因为需要在新生成对象的同时又要回收对象，算法复杂性会大大增加，系统的处理能力也会相应降低，同时，“碎片”问题将会比较难解决。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
          <category> GC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM调优（二） - 基本垃圾回收算法和垃圾收集器</title>
      <link href="/2017/08/25/jvm-GC-algorithms/"/>
      <url>/2017/08/25/jvm-GC-algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="基本的垃圾回收算法"><a href="#基本的垃圾回收算法" class="headerlink" title="基本的垃圾回收算法"></a>基本的垃圾回收算法</h1><h2 id="引用计数（Reference-Counting）"><a href="#引用计数（Reference-Counting）" class="headerlink" title="引用计数（Reference Counting）"></a>引用计数（Reference Counting）</h2><p>比较古老的回收算法。原理是此对象有一个引用，则增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。</p><p>此算法最致命的是无法处理<strong>循环引用</strong>的问题。</p><h2 id="标记-清除（Mark-Sweep）"><a href="#标记-清除（Mark-Sweep）" class="headerlink" title="标记-清除（Mark-Sweep）"></a>标记-清除（Mark-Sweep）</h2><p><img src="/images/mark_sweep.jpg" alt="mark_sweep"></p><p>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。</p><p>缺点是此算法需要<strong>暂停整个应用</strong>，同时，会产生<strong>内存碎片</strong>。</p><h2 id="复制（Copying）"><a href="#复制（Copying）" class="headerlink" title="复制（Copying）"></a>复制（Copying）</h2><p><img src="/images/copying.jpg" alt="copying"></p><p>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。</p><p>当然，此算法的缺点也是很明显的，就是需要<strong>两倍内存空间</strong>。</p><h2 id="标记-整理（Mark-Compact）"><a href="#标记-整理（Mark-Compact）" class="headerlink" title="标记-整理（Mark-Compact）"></a>标记-整理（Mark-Compact）</h2><p><img src="/images/mark_compact.jpg" alt="mark_compact"></p><p>此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p><p>但标记-整理算法唯一的缺点就是<strong>效率不高</strong>，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。</p><h2 id="分代GC"><a href="#分代GC" class="headerlink" title="分代GC"></a>分代GC</h2><p>以上算法各有缺陷，最终，大神们找到了一个GC算法中的神级算法 – 分代GC，详见<a href="https://sagittariusyx.github.io/2017/04/10/jvm-generation-GC/" target="_blank" rel="noopener">分代GC详述</a>。</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="自动垃圾收集机制"><a href="#自动垃圾收集机制" class="headerlink" title="自动垃圾收集机制"></a>自动垃圾收集机制</h2><p>自动垃圾收集机制是查看堆内存、区分在使用的对象和未使用的对象、删除未使用的对象的一个过程。对于使用对象或者引用对象，指的是你的程序持有一个指向那个对象的引用。对于未使用的对象或者是无引用对象，则不被你程序的任何部分持有引用。所以，无引用对象使用的内存是可以被重新回收利用的。</p><p>在类C语言的编程语言中，内存的分配和回收都是手动的。而在Java中，内存的回收是由垃圾回收器自动处理的。基本的步骤可以描述如下：</p><h3 id="步骤一：标记"><a href="#步骤一：标记" class="headerlink" title="步骤一：标记"></a>步骤一：标记</h3><p>第一步是标记，通过这一步骤来区分哪块内存在使用，那哪块内存未使用。</p><p><img src="/images/marking.jpg" alt="marking"></p><p>引用对象用蓝色标识，未引用的对象用金色标识。在标记阶段，扫描所有的对象并判断。如果系统中所有的对象都要被扫描的，那么这一步骤可能非常耗时。</p><h3 id="步骤二（a）：正常删除"><a href="#步骤二（a）：正常删除" class="headerlink" title="步骤二（a）：正常删除"></a>步骤二（a）：正常删除</h3><p>正常删除移除无引用对象，留下引用对象及指向空闲空间的指针。</p><p><img src="/images/normal_deletion.jpg" alt="normal_deletion"></p><p>内存分配器持有空闲内存的引用，这些空闲内存都链接到一个List中，当需要的时候可以分配给新的对象。</p><h3 id="步骤二（b）：带压缩删除"><a href="#步骤二（b）：带压缩删除" class="headerlink" title="步骤二（b）：带压缩删除"></a>步骤二（b）：带压缩删除</h3><p>为了进一步改善性能，除了删除未引用的对象，用户也可以压缩存活的引用对象。把引用对象移动到一起，通过这种方法可以使更快速、更方便的分配新的内存。</p><p><img src="/images/deletion_with_compacting.jpg" alt="deletion_with_compacting"></p><h2 id="JVM垃圾收集器种类"><a href="#JVM垃圾收集器种类" class="headerlink" title="JVM垃圾收集器种类"></a>JVM垃圾收集器种类</h2><p>现在我们已经知道垃圾收集器的一些基本原理。本节将会详细讲解Java可以使用的垃圾回收器，以及在命令行如何选用配置它们。配置JVM有很多可以用的命令行参数，本节选用常用的配置参数进行详细解。</p><p><strong>与堆配置相关的命令行参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-Xms</td><td align="left">JVM启动的时候设置初始堆的大小</td></tr><tr><td align="left">-Xmx</td><td align="left">设置最大堆的大小</td></tr><tr><td align="left">-Xmn</td><td align="left">设置年轻代的大小</td></tr><tr><td align="left">-XX:PermSize</td><td align="left">设置持久代的初始大小</td></tr><tr><td align="left">-XX:MaxPermSize</td><td align="left">设置持久代的最大值</td></tr></tbody></table><h3 id="串行（Serial）收集器"><a href="#串行（Serial）收集器" class="headerlink" title="串行（Serial）收集器"></a>串行（Serial）收集器</h3><p>在Java SE 5和6中，Serial收集器是客户端环境机器的默认设置。在这种情况下，小垃圾收集和大垃圾收集都是串行进行的（使用单个的虚拟CPU）。</p><p><strong>使用的算法：</strong></p><p>串行收集器在年轻代使用的是<strong>拷贝算法</strong>，这个算法比较简单，在这里不做详述。而年老代和持久代使用<strong>标记-清扫-压缩（mark-sweep-compact）算法</strong>。</p><p>标记阶段，收集器识别哪些对象仍然活着。清扫阶段“扫荡”整个代，识别垃圾。之后，收集器执行平移压缩（sliding compaction），将存活的对象平移到代的前端（持久代类似），相应的在尾部留下一整块连续的空闲空间。压缩后，以后的分配就可以在年老代和持久代使用空闲指针（bump-the-pointer）技术。这种压缩算法能够在堆上迅速分配内存块。</p><p>在有大量JVM运行在同一个机器上（在某些情况下，JVM的个数比可以用的处理器的个数多）的应用环境下，串行垃圾收集器也被广泛使用。在这种环境下，要进行垃圾回收的JVM最好使用一个处理器，虽然这样会使垃圾回收的时间变得更长，但可以降低与其他JVM的冲突。这时，使用串行垃圾回收器能够获得很好的权衡。最后，如果在较小的内存和较少的CPU核心上对硬件进行稍加扩充，将能获得更好的性能。</p><p><strong>命令行参数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br></pre></td></tr></table></figure><h3 id="并行（Parallel）收集器"><a href="#并行（Parallel）收集器" class="headerlink" title="并行（Parallel）收集器"></a>并行（Parallel）收集器</h3><p>并行垃圾收集器在年轻代使用多线程进行垃圾回收。默认情况下，在N个CPU的主机上，并行垃圾收集器使用N个垃圾收集器线程进行垃圾回收。垃圾收集器线程的个数可以在命令行进行设置：-XX:ParallelGCThreads=&lt;期望的数值&gt;</p><p><strong>使用的算法：</strong></p><p>年轻代：与Serial垃圾收集器年轻代相同的<strong>拷贝算法</strong>，只不过是该算法的并行版本，使用多个CPU并行的运行，减少了垃圾收集的开销，因此增加了吞吐量。</p><p>年老代：与Serial垃圾收集器老年代相同的<strong>标记-清扫-压缩（mark-sweepcompact）算法</strong>，只不过是该算法的并行版本。</p><p><strong>命令行参数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br></pre></td></tr></table></figure><p>使用这个命令行参数，就会将年轻代设置为多线程的收集器，老年代使用单线程的收集器。该选项还会在老年代进行单线程的压缩工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelOldGC</span><br></pre></td></tr></table></figure><p>使用该参数，年轻代和老年代都会使用多线程的收集器，同时，也使用多线程的压缩收集器。HotSpot仅仅在老年代进行整理，在年轻代是一个复制收集器，因此没必要进行整理。</p><p><strong>压缩</strong>描述的是这样一种行为：移动对象使得个对象之间没有空闲位置。再一次垃圾收集的清理之后，存活对象在内存中的存储位置之间可能存在空闲区。整理移动对象，使得对象的存储都是顺序的，彼此之间没有空闲区。垃圾收集器可能也是一个不带压缩的收集器。所以，<strong>并行收集器和并行压缩收集器</strong>之间的区别就是后者在垃圾收集清理操作之后，对内存空间进行一次整理。</p><h3 id="并发标记清理（CMS）收集器"><a href="#并发标记清理（CMS）收集器" class="headerlink" title="并发标记清理（CMS）收集器"></a>并发标记清理（CMS）收集器</h3><p>并发标记清理收集器（CMS，又叫作并发低暂停收集器）在<strong>老年代</strong>进行收集。由于垃圾收集能使用应用线程的并发进行大多数的垃圾收集工作，所以它降低了应用程序的暂停时间。</p><p>正常说来，并发低暂停的收集器对存活对象不进行复制和压缩的工作。这种情况下，垃圾收集器没有移动任何存活对象。如果因此而带来了内存的碎片问题，那就为其分配一个更大的堆。</p><p>注意：<strong>CMS收集器在年轻代使用和并行收集器一样的算法。</strong></p><p><strong>命令行参数：</strong></p><p>如果要使用CMS收集器，使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><p>同时，可以设置并发的线程数目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelCMSThreads&#x3D;&lt;n&gt;</span><br></pre></td></tr></table></figure><h3 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h3><p>在Java 7中可以使用G1垃圾回收器，它设计的初衷是用于长期取代CMS收集器。G1垃圾收集器是一个并行、并发，同时也是基于增量整理的低暂停垃圾收集器。与前面所描述的垃圾收集器相比，从布局方面与它们有很大的不同，本文不对该部分做详细的说明。</p><p><strong>命令行参数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure><h1 id="Java-8各种垃圾收集器比较"><a href="#Java-8各种垃圾收集器比较" class="headerlink" title="Java 8各种垃圾收集器比较"></a>Java 8各种垃圾收集器比较</h1><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>OpenJDK 8 有多种 GC（Garbage Collector）算法，如 Parallel GC、CMS 和 G1。哪一个才是最快的呢？如果在 Java 9 中将 Java 8 默认的 GC 从 Parallel GC 改为 G1 （目前只是建议）将会怎么样呢？让我们对此进行基准测试。</p><p>为了方便查看，我已经对每种 GC 与 Java 8 默认 GC（Parallel GC）进行了比较。</p><p><img src="/images/GC_performance.jpg" alt="GC_performance"></p><p>结果非常清楚：默认（Parallel GC）是最快的。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在 Java 8 中，对 OptaPlanner 用例来说，默认 GC（Parallel GC）通常情况是最好的选择。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
          <category> GC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM调优（一） - 基本概念</title>
      <link href="/2017/08/17/jvm-optimization-base-intro/"/>
      <url>/2017/08/17/jvm-optimization-base-intro/</url>
      
        <content type="html"><![CDATA[<p>在阅读这篇文章之前，我建议你阅读《<a href="https://www.jianshu.com/p/8bd15969a641" target="_blank" rel="noopener">HotSpot垃圾回收算法概述</a>》的概念介绍部分。</p><p>本系列主要介绍：</p><ul><li>JVM调优相关的基本概念</li><li>基本的垃圾回收算法和垃圾收集器</li><li>GC面临的问题</li><li>分代GC详述</li></ul><p>本文主要介绍JVM调优的相关基本概念。</p><h1 id="JVM架构"><a href="#JVM架构" class="headerlink" title="JVM架构"></a>JVM架构</h1><h2 id="HotSpot架构"><a href="#HotSpot架构" class="headerlink" title="HotSpot架构"></a>HotSpot架构</h2><p>HotSpot JVM架构支持较强的基本特征和功能，此外还支持<strong>高性能</strong>和<strong>高吞吐率</strong>的特性。例如，JVM JIT编译器产生动态优化的代码，也就是，编译器是在Java运行的时候的时候进行优化，并为当前的系统架构生成高性能的目标机器指令。此外，经过对运行时环境和多线程垃圾回收器不断地设计和优化，现在的HotSpot JVM甚至在大型的系统上都具有较高的伸缩性。JVM 的主要组件包括：ClassLoader、运行时数据区和执行引擎。</p><p><img src="/images/jvm_architecture.jpg" alt="jvm_architecture"></p><p>从上图可知，JVM主要包括四个部分：</p><ul><li>类加载器（ClassLoader）：在JVM启动时或者在类运行时将需要的class加载到JVM中。</li><li>内存区（也叫运行数据区）：是在JVM运行的时候操作所分配的内存区。运行时内存区主要可以划分为5个区域，如图：</li></ul><p><img src="/images/runtime_data_areas.jpg" alt="runtime_data_areas"></p><p>方法区：用于存储类结构信息的地方，包括常量池、静态变量、构造函数等。虽然JVM规范把方法区描述为堆的一个逻辑部分， 但它却有个别名non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。</p><p>堆(Heap)：存储java实例或者对象的地方。这块是GC的主要区域（后面解释）。从存储的内容我们可以很容易知道，方法区和堆是被所有java线程共享的。</p><p>栈(Stack)：java栈总是和线程关联在一起，每当创建一个线程时，JVM就会为这个线程创建一个对应的java栈。在这个java栈中又会包含多个栈帧，每运行一个方法就创建一个栈帧，用于存储局部变量表、操作栈、方法返回值等。每一个方法从调用直至执行完成的过程，就对应一个栈帧在java栈中入栈到出栈的过程。所以java栈是现成私有的。</p><p>程序计数器(PC Register)：用于保存当前线程执行的内存地址。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。</p><p>本地方法栈(Native Method Stack)：和java栈的作用差不多，只不过是为JVM使用到的native方法服务的。</p><ul><li>执行引擎：负责执行class文件中包含的字节码指令。</li><li>本地方法接口：主要是调用C或C++实现的本地方法及返回结果。</li></ul><h2 id="HotSpot关键组件"><a href="#HotSpot关键组件" class="headerlink" title="HotSpot关键组件"></a>HotSpot关键组件</h2><p>与性能密切相关的JVM的关键组件，有堆、JIT编译器，垃圾收集器，在下图中这些组件用深色标注。</p><p><img src="/images/key_jvm_architecture_components.jpg" alt="key_jvm_architecture_components"></p><p>性能优化主要关注这三个组件即可。堆是存储对象的地方，该区域由用户指定（可以在启动应用程序的时候指定）的垃圾回收器来管理。大多数优化选项都是通过配置堆的大小和选择最合适的垃圾回收器来实现。JIT编译器对性能也能产生比较大的影响，但是对于更新版本的JVM很少需要对其进行优化。</p><h1 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h1><p>堆和栈是程序运行的关键，很有必要把他们的关系说清楚。</p><p><img src="/images/heap_and_stack.jpg" alt="heap_and_stack"></p><p><strong>栈是运行时的单位，而堆是存储的单位</strong>。</p><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。</p><p>在Java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。</p><p>一个问题：<strong>为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</strong></p><ol><li>从软件设计的角度看，<strong>栈代表了处理逻辑，而堆代表了数据</strong>。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</li><li>堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种<strong>有效的数据交互方式</strong>(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，<strong>节省了空间</strong>。</li><li>栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得<strong>动态增长成为可能</strong>，相应栈中只需记录堆中的一个地址即可。</li><li>面向对象就是<strong>堆和栈的完美结合</strong>。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。</li></ol><p><strong>在Java中，Main函数就是栈的起始点，也是程序的起始点</strong>。</p><h1 id="Java内存分配"><a href="#Java内存分配" class="headerlink" title="Java内存分配"></a>Java内存分配</h1><p>Java的内存分配原理与C/C++不同，C/C++每次申请内存时都要malloc进行系统调用，而系统调用发生在内核空间，每次都要中断进行切换，这需要一定的开销，而Java虚拟机是先一次性分配一块较大的空间，然后每次new时都在该空间上进行分配和释放，减少了系统调用的次数，节省了一定的开销，这有点类似于内存池的概念；二是有了这块空间过后，如何进行分配和回收就跟GC机制有关了。</p><p>java一般内存申请有两种：<strong>静态内存和动态内存</strong>。很容易理解，编译时就能够确定的内存就是静态内存，即内存是固定的，系统一次性分配，比如int类型变量；动态内存分配就是在程序执行时才知道要分配的存储空间大小，比如java对象的内存空间。根据上面我们知道，java栈、程序计数器、本地方法栈都是线程私有的，线程生就生，线程灭就灭，栈中的栈帧随着方法的结束也会撤销，内存自然就跟着回收了。所以这几个区域的内存分配与回收是确定的，我们不需要管的。但是java堆和方法区则不一样，我们只有在程序运行期间才知道会创建哪些对象，所以这部分内存的分配和回收都是动态的。一般我们所说的垃圾回收也是针对的这一部分。</p><p>总之Stack的内存管理是顺序分配的，而且定长，不存在内存回收问题；而Heap 则是为java对象的实例随机分配内存，不定长度，所以存在内存分配和回收的问题。</p><h1 id="应用程序性能衡量要素"><a href="#应用程序性能衡量要素" class="headerlink" title="应用程序性能衡量要素"></a>应用程序性能衡量要素</h1><p>通常说来，在优化一个Java应用时，我们通常关心的是<strong>响应时间</strong>和<strong>吞吐量</strong>两者中的一个，在此对这两个概念做一下介绍。</p><h2 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h2><p>响应时间指的是应用或者系统对一个请求数据的回应。例如：</p><ul><li>桌面UI对鼠标事件的响应速度</li><li>网站返回页面的速度</li><li>数据库查询返回的速度</li></ul><p>所以，对于重点关心响应时间的应用，较长时间的应用暂停是不可接受的。我们要做到尽可能的提升响应速度，减少响应时间。</p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>吞吐量重点关心特定时间内应用程序处理工作的最大值。例如，吞吐量可以通过以下形式来衡量：</p><ul><li>给定时间内的完成的事物数量</li><li>一个小时你完成的批处理程序的个数</li><li>一个小时内完成的数据库查询的次数</li></ul><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
          <category> GC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python实现三种洗牌算法</title>
      <link href="/2017/01/19/python-shuffle-algorithms/"/>
      <url>/2017/01/19/python-shuffle-algorithms/</url>
      
        <content type="html"><![CDATA[<p>这个题来源于前一段时间同事的面试题，众所周知平时对于排序是考察比较多的，洗牌算法（打乱算法）是他的逆过程。从种类来看，洗牌算法大致分为三种：</p><h1 id="Fisher-Yates-Shuffle"><a href="#Fisher-Yates-Shuffle" class="headerlink" title="Fisher-Yates Shuffle"></a>Fisher-Yates Shuffle</h1><p>思想就是从原始数据随机抽取一个新的数字到新数组中，python实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"> 1. 从还没处理的数组（假如还剩k个）中，随机产生一个[0, k]之间的数字p（假设数组从0开始）；</span></span><br><span class="line"><span class="string"> 2. 从剩下的k个数中把第p个数取出；</span></span><br><span class="line"><span class="string"> 3. 重复步骤2和3直到数字全部取完；</span></span><br><span class="line"><span class="string"> 4. 从步骤3取出的数字序列便是一个打乱了的数列。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fisher_yates_shuffle</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="comment"># apply for a new list</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> list:</span><br><span class="line">        p = random.randrange(<span class="number">0</span>, len(list))</span><br><span class="line">        res.append(list[p])</span><br><span class="line">        list.pop(p)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">r = fisher_yates_shuffle([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>])</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure><h1 id="Knuth-Durstenfeld-Shuffle"><a href="#Knuth-Durstenfeld-Shuffle" class="headerlink" title="Knuth-Durstenfeld Shuffle"></a>Knuth-Durstenfeld Shuffle</h1><p>Knuth将Fisher算法加以改进。每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的末尾，即数组尾部存放的都是处理过的数据。Knuth是一个原地打乱的算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knuth_shuffle</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="comment"># no extra space</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        p = random.randrange(<span class="number">0</span>, i + <span class="number">1</span>)</span><br><span class="line">        list[i], list[p] = list[p], list[i]</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">    </span><br><span class="line">r = knuth_shuffle([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>])</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure><h1 id="Inside-Out-Algorithm"><a href="#Inside-Out-Algorithm" class="headerlink" title="Inside-Out Algorithm"></a>Inside-Out Algorithm</h1><p>Knuth算法是一个in-place算法，原始数据被直接打乱，但有些情形下需要保存原始数据，因此需要重新开辟一个新数组来存储打乱后的序列。Inside-Out算法的基本思想是设置一个游标 i 从前向后扫描原始数据的拷贝，在[0, i]之间随机一个下标 j，然后用位置 j 的元素替换掉位置 i 处的数字，再用原始数据位置 i 的元素替换掉拷贝数据位置 j 的元素。作用相当于在拷贝数据中交换位置 i 和 j 处的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inside_out_shuffle</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="comment"># save original data</span></span><br><span class="line">    res = list[:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(list)):</span><br><span class="line">        j = random.randrange(<span class="number">0</span>, i)</span><br><span class="line">        res[i] = res[j]</span><br><span class="line">        res[j] = list[i]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">r = inside_out_shuffle([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>])</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>前面使用python实现了三种洗牌算法，其实python的random模块也提供了shuffle的方法，用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle(items)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items</span><br><span class="line">[<span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>其内部正是使用的Knuth的Shuffle算法。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>githug小游戏通关笔记</title>
      <link href="/2017/01/17/githug-q-and-a/"/>
      <url>/2017/01/17/githug-q-and-a/</url>
      
        <content type="html"><![CDATA[<p>这货叫做Githug，主要目的是通过游戏的形式来练习git命令的使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ruby githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">No githug directory found, do you wish to create one? [yn]  y</span><br><span class="line">Welcome to Githug!</span><br></pre></td></tr></table></figure><h1 id="1-5"><a href="#1-5" class="headerlink" title="1 - 5"></a>1 - 5</h1><p>1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Name: init</span><br><span class="line">Level: 1</span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">A new directory, &#96;git_hug&#96;, has been created; initialize an empty repository in it.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  ruby git config --global core.editor &quot;&#x2F;usr&#x2F;bin&#x2F;vim&quot;</span><br><span class="line">➜  ruby cd git_hug </span><br><span class="line">➜  git_hug git init</span><br><span class="line">Initialized empty Git repository in &#x2F;Users&#x2F;yangxiao&#x2F;Documents&#x2F;ruby&#x2F;git_hug&#x2F;.git&#x2F;</span><br><span class="line">➜  git_hug git:(master) ls</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Name: config</span><br><span class="line">Level: 2</span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">Set up your git name and email, this is important so that your commits can be identified.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git config user.name sagittariusyx       </span><br><span class="line">➜  git_hug git:(master) git config user.email &quot;ssdut.xiao@gmail.com&quot;</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">What is your name? sagittariusyx</span><br><span class="line">What is your email? ssdut.xiao@gmail.com</span><br><span class="line">Your config has the following name: sagittariusyx</span><br><span class="line">Your config has the following email: ssdut.xiao@gmail.com</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Name: add</span><br><span class="line">Level: 3</span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">There is a file in your folder called &#96;README&#96;, you should add it to your staging area</span><br><span class="line">Note: You start each level with a new repo. Don&#39;t look for files from the previous one.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ ls</span><br><span class="line">README</span><br><span class="line">➜  git_hug git:(master) ✗ vim README </span><br><span class="line">➜  git_hug git:(master) ✗ git add README </span><br><span class="line">➜  git_hug git:(master) ✗ githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Name: commit</span><br><span class="line">Level: 4</span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">The &#96;README&#96; file has been added to your staging area, now commit it.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git commit -m &quot;init&quot;</span><br><span class="line">[master (root-commit) 17922c4] init</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Name: clone</span><br><span class="line">Level: 5</span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">Clone the repository at https:&#x2F;&#x2F;github.com&#x2F;Gazler&#x2F;cloneme.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git clone https:&#x2F;&#x2F;github.com&#x2F;Gazler&#x2F;cloneme </span><br><span class="line">Cloning into &#39;cloneme&#39;...</span><br><span class="line">remote: Counting objects: 7, done.</span><br><span class="line">remote: Total 7 (delta 0), reused 0 (delta 0), pack-reused 7</span><br><span class="line">Unpacking objects: 100% (7&#x2F;7), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">➜  git_hug githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><h1 id="6-10"><a href="#6-10" class="headerlink" title="6 - 10"></a>6 - 10</h1><p>6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Name: clone_to_folder</span><br><span class="line">Level: 6</span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">Clone the repository at https:&#x2F;&#x2F;github.com&#x2F;Gazler&#x2F;cloneme to &#96;my_cloned_repo&#96;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git clone https:&#x2F;&#x2F;github.com&#x2F;Gazler&#x2F;cloneme my_cloned_repo</span><br><span class="line">Cloning into &#39;my_cloned_repo&#39;...</span><br><span class="line">remote: Counting objects: 7, done.</span><br><span class="line">remote: Total 7 (delta 0), reused 0 (delta 0), pack-reused 7</span><br><span class="line">Unpacking objects: 100% (7&#x2F;7), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">➜  git_hug githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Name: ignore</span><br><span class="line">Level: 7</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">The text editor &#39;vim&#39; creates files ending in &#96;.swp&#96; (swap files) for all files that are currently open.  We don&#39;t want them creeping into the repository.  Make this repository ignore those swap files which are ending in &#96;.swp&#96;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ vim .gitignore </span><br><span class="line">*.swp</span><br><span class="line">[exit VIM]</span><br><span class="line">➜  git_hug git:(master) githug </span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Name: include</span><br><span class="line">Level: 8</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Notice a few files with the &#39;.a&#39; extension.  We want git to ignore all but the &#39;lib.a&#39; file.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ vim .gitignore</span><br><span class="line">*.a</span><br><span class="line">!lib.a</span><br><span class="line">[exit VIM]</span><br><span class="line">➜  git_hug git:(master) ✗ githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>9</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Name: status</span><br><span class="line">Level: 9</span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">There are some files in this repository, one of the files is untracked, which file is it?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">  new file:   Guardfile</span><br><span class="line">  new file:   README</span><br><span class="line">  new file:   config.rb</span><br><span class="line">  new file:   deploy.rb</span><br><span class="line">  new file:   setup.rb</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">  database.yml</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">What is the full file name of the untracked file? database.yml</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Name: number_of_files_committed</span><br><span class="line">Level: 10</span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">There are some files in this repository, how many of the files will be committed?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">  new file:   rubyfile1.rb</span><br><span class="line">  modified:   rubyfile4.rb</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">  modified:   rubyfile5.rb</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">  rubyfile6.rb</span><br><span class="line">  rubyfile7.rb</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">How many changes are going to be committed? 2</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><h1 id="11-15"><a href="#11-15" class="headerlink" title="11 - 15"></a>11 - 15</h1><p>11</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Name: rm</span><br><span class="line">Level: 11</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">A file has been removed from the working tree, however the file was not removed from the repository.  Find out what this file was and remove it.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add&#x2F;rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">  deleted:    deleteme.rb</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br><span class="line">➜  git_hug git:(master) ✗ git rm deleteme.rb</span><br><span class="line">rm &#39;deleteme.rb&#39;</span><br><span class="line">➜  git_hug git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">  deleted:    deleteme.rb</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>12</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Name: rm_cached</span><br><span class="line">Level: 12</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">A file has accidentally been added to your staging area, find out which file and remove it from the staging area.  *NOTE* Do not remove the file from the file system, only from git.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">  new file:   deleteme.rb</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git rm --cached deleteme.rb</span><br><span class="line">rm &#39;deleteme.rb&#39;</span><br><span class="line">➜  git_hug git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">  deleteme.rb</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line">➜  git_hug git:(master) ✗ githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>13</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Name: stash</span><br><span class="line">Level: 13</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You&#39;ve made some changes and want to work on them later. You should save them, but don&#39;t commit them.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">  modified:   lyrics.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br><span class="line">➜  git_hug git:(master) ✗ git stash</span><br><span class="line">Saved working directory and index state WIP on master: 0206059 Add some lyrics</span><br><span class="line">HEAD is now at 0206059 Add some lyrics</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>14</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Name: rename</span><br><span class="line">Level: 14</span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">We have a file called &#96;oldfile.txt&#96;. We want to rename it to &#96;newfile.txt&#96; and stage this change.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git mv oldfile.txt newfile.txt</span><br><span class="line">➜  git_hug git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">  renamed:    oldfile.txt -&gt; newfile.txt</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ githug </span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>15</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Name: restructure</span><br><span class="line">Level: 15</span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">You added some files to your repository, but now realize that your project needs to be restructured.  Make a new folder named &#96;src&#96; and using Git move all of the .html files into this folder.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ls</span><br><span class="line">about.html   contact.html index.html</span><br><span class="line">➜  git_hug git:(master) mkdir src</span><br><span class="line">➜  git_hug git:(master) git mv *.html src</span><br><span class="line">➜  git_hug git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">  renamed:    about.html -&gt; src&#x2F;about.html</span><br><span class="line">  renamed:    contact.html -&gt; src&#x2F;contact.html</span><br><span class="line">  renamed:    index.html -&gt; src&#x2F;index.html</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><h1 id="16-20"><a href="#16-20" class="headerlink" title="16 - 20"></a>16 - 20</h1><p>16</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Name: log</span><br><span class="line">Level: 16</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You will be asked for the hash of most recent commit.  You will need to investigate the logs of the repository for this.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git log</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">What is the hash of the most recent commit? 053adb5</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>17</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Name: tag</span><br><span class="line">Level: 17</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">We have a git repo and we want to tag the current commit with &#96;new_tag&#96;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git tag new_tag</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>18</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Name: push_tags</span><br><span class="line">Level: 18</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">There are tags in the repository that aren&#39;t pushed into remote repository. Push them now.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">From &#x2F;var&#x2F;folders&#x2F;6v&#x2F;0_m2zjlx1_vbvv4wgmlq0qm40000gn&#x2F;T&#x2F;d20170117-10523-xtjnrf&#x2F;</span><br><span class="line"> * [new branch]      master     -&gt; origin&#x2F;master</span><br><span class="line">➜  git_hug git:(master) git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line">➜  git_hug git:(master) githug --tags git push ?????</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>19</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Name: commit_amend</span><br><span class="line">Level: 19</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">The &#96;README&#96; file has been committed, but it looks like the file &#96;forgotten_file.rb&#96; was missing from the commit.  Add the file and amend your previous commit to include it.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">  forgotten_file.rb</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line">➜  git_hug git:(master) ✗ git add forgotten_file.rb </span><br><span class="line">➜  git_hug git:(master) ✗ git commit --amend</span><br><span class="line"></span><br><span class="line">*****[commit with VIM]*****</span><br><span class="line"></span><br><span class="line">[master 423cadb] Initial commit</span><br><span class="line"> Date: Tue Jan 17 20:37:55 2017 +0800</span><br><span class="line"> 2 files changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README</span><br><span class="line"> create mode 100644 forgotten_file.rb</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>20</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Name: commit_in_future</span><br><span class="line">Level: 20</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Commit your changes with the future date (e.g. tomorrow).</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git commit --date&#x3D;&quot;Tue Jan 18 21:12:01 CST 2017&quot;</span><br><span class="line">[master (root-commit) d364e1a] commit future!</span><br><span class="line"> Date: Wed Jan 18 21:12:01 2017 -0600</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><h1 id="21-25"><a href="#21-25" class="headerlink" title="21 - 25"></a>21 - 25</h1><p>21</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Name: reset</span><br><span class="line">Level: 21</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">There are two files to be committed.  The goal was to add each file as a separate commit, however both were added by accident.  Unstage the file &#96;to_commit_second.rb&#96; using the reset command (don&#39;t commit anything).</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git status     </span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">  new file:   to_commit_first.rb</span><br><span class="line">  new file:   to_commit_second.rb</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git reset HEAD to_commit_second.rb </span><br><span class="line">➜  git_hug git:(master) ✗ githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>22</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Name: reset_soft</span><br><span class="line">Level: 22</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You committed too soon. Now you want to undo the last commit, while keeping the index.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git reset --soft HEAD^1</span><br><span class="line">➜  git_hug git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">  new file:   newfile.rb</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>23</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Name: checkout_file</span><br><span class="line">Level: 23</span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">A file has been modified, but you don&#39;t want to keep the modification.  Checkout the &#96;config.rb&#96; file from the last commit.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">  modified:   config.rb</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br><span class="line">➜  git_hug git:(master) ✗ git checkout config.rb </span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>24</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Name: remote</span><br><span class="line">Level: 24</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">This project has a remote repository.  Identify it.</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git remote</span><br><span class="line">my_remote_repo</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">What is the name of the remote repository? my_remote_repo</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>25</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Name: remote_url</span><br><span class="line">Level: 25</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">The remote repositories have a url associated to them.  Please enter the url of remote_location.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git remote -v</span><br><span class="line">my_remote_repo  https:&#x2F;&#x2F;github.com&#x2F;Gazler&#x2F;githug (fetch)</span><br><span class="line">my_remote_repo  https:&#x2F;&#x2F;github.com&#x2F;Gazler&#x2F;githug (push)</span><br><span class="line">remote_location https:&#x2F;&#x2F;github.com&#x2F;githug&#x2F;not_a_repo (fetch)</span><br><span class="line">remote_location https:&#x2F;&#x2F;github.com&#x2F;githug&#x2F;not_a_repo (push)</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">What is the url of the remote repository? https:&#x2F;&#x2F;github.com&#x2F;githug&#x2F;not_a_repo</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><h1 id="26-30"><a href="#26-30" class="headerlink" title="26 - 30"></a>26 - 30</h1><p>26</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Name: pull</span><br><span class="line">Level: 26</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You need to pull changes from your origin repository.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git pull origin master</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3</span><br><span class="line">Unpacking objects: 100% (3&#x2F;3), done.</span><br><span class="line">From https:&#x2F;&#x2F;github.com&#x2F;pull-this&#x2F;thing-to-pull</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line"> * [new branch]      master     -&gt; origin&#x2F;master</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>27</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Name: remote_add</span><br><span class="line">Level: 27</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Add a remote repository called &#96;origin&#96; with the url https:&#x2F;&#x2F;github.com&#x2F;githug&#x2F;githug</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git remote add origin https:&#x2F;&#x2F;github.com&#x2F;githug&#x2F;githug</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>28</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Name: push</span><br><span class="line">Level: 28</span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">Your local master branch has diverged from the remote origin&#x2F;master branch. Rebase your commit onto origin&#x2F;master and push it to remote.</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git rebase origin&#x2F;master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: First commit</span><br><span class="line">Applying: Second commit</span><br><span class="line">Applying: Third commit</span><br><span class="line">➜  git_hug git:(master) git push origin master</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (6&#x2F;6), done.</span><br><span class="line">Writing objects: 100% (6&#x2F;6), 612 bytes | 0 bytes&#x2F;s, done.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">To &#x2F;var&#x2F;folders&#x2F;6v&#x2F;0_m2zjlx1_vbvv4wgmlq0qm40000gn&#x2F;T&#x2F;d20170120-2068-u1sjza&#x2F;.git</span><br><span class="line">   f3aeb43..2e33184  master -&gt; master</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>29</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Name: diff</span><br><span class="line">Level: 29</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">There have been modifications to the &#96;app.rb&#96; file since your last commit.  Find out which line has changed.</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git diff app.rb </span><br><span class="line">➜  git_hug git:(master) ✗ githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">What is the number of the line which has changed? 26</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>30</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Name: blame</span><br><span class="line">Level: 30</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Someone has put a password inside the file &#96;config.rb&#96; find out who it was.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git blame config.rb </span><br><span class="line">➜  git_hug git:(master) ✗ githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Who made the commit with the password? Spider Man</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><h1 id="31-35"><a href="#31-35" class="headerlink" title="31 - 35"></a>31 - 35</h1><p>31</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Name: branch</span><br><span class="line">Level: 31</span><br><span class="line">Difficulty: *</span><br><span class="line"></span><br><span class="line">You want to work on a piece of code that has the potential to break things, create the branch test_code.</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git branch test_code</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>32</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Name: checkout</span><br><span class="line">Level: 32</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Create and switch to a new branch called my_branch.  You will need to create a branch like you did in the previous level.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git checkout -b my_branch</span><br><span class="line">Switched to a new branch &#39;my_branch&#39;</span><br><span class="line">➜  git_hug git:(my_branch) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>33</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Name: checkout_tag</span><br><span class="line">Level: 33</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You need to fix a bug in the version 1.2 of your app. Checkout the tag &#96;v1.2&#96;.</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git checkout v1.2</span><br><span class="line">Note: checking out &#39;v1.2&#39;.</span><br><span class="line"></span><br><span class="line">You are in &#39;detached HEAD&#39; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at f83bf75... Some more changes</span><br><span class="line">➜  git_hug git:(f83bf75) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>34</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Name: checkout_tag_over_branch</span><br><span class="line">Level: 34</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You need to fix a bug in the version 1.2 of your app. Checkout the tag &#96;v1.2&#96; (Note: There is also a branch named &#96;v1.2&#96;).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git checkout tags&#x2F;v1.2</span><br><span class="line">Note: checking out &#39;tags&#x2F;v1.2&#39;.</span><br><span class="line"></span><br><span class="line">You are in &#39;detached HEAD&#39; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at 2aede5e... Some more changes</span><br><span class="line">➜  git_hug git:(2aede5e) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>35</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Name: branch_at</span><br><span class="line">Level: 35</span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">You forgot to branch at the previous commit and made a commit on top of it. Create branch test_branch at the commit before the last.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git branch test_branch HEAD^1</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><h1 id="36-40"><a href="#36-40" class="headerlink" title="36 - 40"></a>36 - 40</h1><p>36</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Name: delete_branch</span><br><span class="line">Level: 36</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You have created too many branches for your project. There is an old branch in your repo called &#39;delete_me&#39;, you should delete it.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git branch -d delete_me</span><br><span class="line">Deleted branch delete_me (was b60afe2).</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>37</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Name: push_branch</span><br><span class="line">Level: 37</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You&#39;ve made some changes to a local branch and want to share it, but aren&#39;t yet ready to merge it with the &#39;master&#39; branch.  Push only &#39;test_branch&#39; to the remote repository</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git push origin test_branch</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (6&#x2F;6), done.</span><br><span class="line">Writing objects: 100% (6&#x2F;6), 585 bytes | 0 bytes&#x2F;s, done.</span><br><span class="line">Total 6 (delta 3), reused 0 (delta 0)</span><br><span class="line">To &#x2F;var&#x2F;folders&#x2F;6v&#x2F;0_m2zjlx1_vbvv4wgmlq0qm40000gn&#x2F;T&#x2F;d20170120-2746-zswfij&#x2F;.git</span><br><span class="line"> * [new branch]      test_branch -&gt; test_branch</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>38</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Name: merge</span><br><span class="line">Level: 38</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">We have a file in the branch &#39;feature&#39;; Let&#39;s merge it to the master branch.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git merge feature</span><br><span class="line">Updating e12277f..cc8ea5a</span><br><span class="line">Fast-forward</span><br><span class="line"> file2 | 0</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 file2</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>39</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Name: fetch</span><br><span class="line">Level: 39</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Looks like a new branch was pushed into our remote repository. Get the changes without merging them with the local repository </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git fetch origin</span><br><span class="line">remote: Counting objects: 2, done.</span><br><span class="line">remote: Compressing objects: 100% (2&#x2F;2), done.</span><br><span class="line">remote: Total 2 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (2&#x2F;2), done.</span><br><span class="line">From &#x2F;var&#x2F;folders&#x2F;6v&#x2F;0_m2zjlx1_vbvv4wgmlq0qm40000gn&#x2F;T&#x2F;d20170120-2817-3ndtsr&#x2F;</span><br><span class="line"> * [new branch]      new_branch -&gt; origin&#x2F;new_branch</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>40</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Name: rebase</span><br><span class="line">Level: 40</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">We are using a git rebase workflow and the feature branch is ready to go into master. Let&#39;s rebase the feature branch onto our master branch.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git checkout feature</span><br><span class="line">Switched to branch &#39;feature&#39;</span><br><span class="line">➜  git_hug git:(feature) git rebase master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: add feature</span><br><span class="line">➜  git_hug git:(feature) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><h1 id="41-45"><a href="#41-45" class="headerlink" title="41 - 45"></a>41 - 45</h1><p>41</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Name: rebase_onto</span><br><span class="line">Level: 41</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You have created your branch from &#96;wrong_branch&#96; and already made some commits, and you realise that you needed to create your branch from &#96;master&#96;. Rebase your commits onto &#96;master&#96; branch so that you don&#39;t have &#96;wrong_branch&#96; commits.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(readme-update) git rebase --onto master wrong_branch</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: Add app name in readme</span><br><span class="line">Applying: Add &#96;About&#96; header in readme</span><br><span class="line">Applying: Add &#96;Install&#96; header in readme</span><br><span class="line">➜  git_hug git:(readme-update) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>42</p><p><code>git gc</code> 需要深研究搞明白，稍后我会整理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Name: repack</span><br><span class="line">Level: 42</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Optimise how your repository is packaged ensuring that redundant packs are removed.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git gc</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Writing objects: 100% (3&#x2F;3), done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>43</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Name: cherry-pick</span><br><span class="line">Level: 43</span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">Your new feature isn&#39;t worth the time and you&#39;re going to delete it. But it has one commit that fills in &#96;README&#96; file, and you want this commit to be on the master as well.</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git branch</span><br><span class="line">* master</span><br><span class="line">  new-feature</span><br><span class="line">➜  git_hug git:(master) git checkout new-feature </span><br><span class="line">Switched to branch &#39;new-feature&#39;</span><br><span class="line">➜  git_hug git:(new-feature) git log</span><br><span class="line">➜  git_hug git:(new-feature) git checkout master</span><br><span class="line">Switched to branch &#39;master&#39;</span><br><span class="line">➜  git_hug git:(master) git cherry-pick ca32a6dac7b6f97975edbe19a4296c2ee7682f68</span><br><span class="line">[master be39958] Filled in README.md with proper input</span><br><span class="line"> Author: Andrey &lt;aslushnikov@gmail.com&gt;</span><br><span class="line"> Date: Wed Mar 28 02:25:51 2012 +0400</span><br><span class="line"> 1 file changed, 1 insertion(+), 2 deletions(-)</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>44</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Name: grep</span><br><span class="line">Level: 44</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">Your project&#39;s deadline approaches, you should evaluate how many TODOs are left in your code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git grep &#39;TODO&#39; | wc -l</span><br><span class="line">       4</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">How many items are there in your todolist? 4</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>45</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Name: rename_commit</span><br><span class="line">Level: 45</span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">Correct the typo in the message of your first (non-root) commit.</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git rebase -i HEAD~2</span><br><span class="line"></span><br><span class="line"># 修改前面pick为reword</span><br><span class="line"></span><br><span class="line">[detached HEAD 35c7147] First commit</span><br><span class="line"> Date: Fri Jan 20 22:33:15 2017 +0800</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 file1</span><br><span class="line">Successfully rebased and updated refs&#x2F;heads&#x2F;master.</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><h1 id="46-50"><a href="#46-50" class="headerlink" title="46 - 50"></a>46 - 50</h1><p>46</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Name: squash</span><br><span class="line">Level: 46</span><br><span class="line">Difficulty: ****</span><br><span class="line"></span><br><span class="line">You have committed several times but would like all those changes to be one commit.</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git log</span><br><span class="line">➜  git_hug git:(master) git rebase -i HEAD~4</span><br><span class="line"></span><br><span class="line">[把后三个命令都改为s]</span><br><span class="line"></span><br><span class="line">[detached HEAD b21b641] Adding README</span><br><span class="line"> Date: Wed Jan 25 20:33:56 2017 +0800</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br><span class="line"> create mode 100644 README</span><br><span class="line">Successfully rebased and updated refs&#x2F;heads&#x2F;master.</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>47</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Name: merge_squash</span><br><span class="line">Level: 47</span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">Merge all commits from the long-feature-branch as a single commit.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git merge --squash long-feature-branch </span><br><span class="line">Squash commit -- not updating HEAD</span><br><span class="line">Automatic merge went well; stopped before committing as requested</span><br><span class="line">➜  git_hug git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">  new file:   file3</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git commit -m &quot;XXX&quot;</span><br><span class="line">[master e29f6b4] XXX</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br><span class="line"> create mode 100644 file3</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>48</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Name: reorder</span><br><span class="line">Level: 48</span><br><span class="line">Difficulty: ****</span><br><span class="line"></span><br><span class="line">You have committed several times but in the wrong order. Please reorder your commits.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git log</span><br><span class="line">➜  git_hug git:(master) git rebase -i HEAD~3</span><br><span class="line"></span><br><span class="line">[颠倒一下顺序]</span><br><span class="line"></span><br><span class="line">Successfully rebased and updated refs&#x2F;heads&#x2F;master.</span><br><span class="line">➜  git_hug git:(master) git log</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>49</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name: bisect</span><br><span class="line">Level: 49</span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">A bug was introduced somewhere along the way.  You know that running &#96;ruby prog.rb 5&#96; should output 15.  You can also run &#96;make test&#96;.  What are the first 7 chars of the hash of the commit that introduced the bug.</span><br></pre></td></tr></table></figure><p>项目中有个 bug 是某一次 commit 引入的。使用 make test 可以测试项目，返回值是 0 的话表示测试通过，无 bug。要求找出引入 bug 的那个 commit。</p><p><code>git birect</code> 的基本用法如下：</p><ol><li>执行 <code>git birect start</code>，表示开始二分搜索；</li><li>找到任意一个有问题的 commit，标记一下这个版本。一般这种情况下当前版本都是有问题的，所以 <code>git birect bad</code></li><li>找到任意一个没问题的 commit，标记一下这个版本。如 <code>git birect good f608824888b83bbedc1f658be7496ffea467a8fb</code></li><li>当你至少标记了一个 good 和一个 bad 之后，就会看到类似于 <code>Bisecting: 675 revisions left to test after this</code> 的提示，告诉你你标记的两个版本之间有这么多个待测试的版本。</li><li>然后两者中间的那个版本会自动被 <code>checkout</code>，你要做的是测试一下这个版本有没有问题，并标记为 <code>git birect good 或 bad</code></li><li>git 会自动重复第 4 步，然后你重复第 5 步。这样一直二分搜索下来，直到找到第一个有问题的版本。</li></ol><p>当然，这样一个一个版本手工测试还是很麻烦，如果你的项目有没有 bug 可以通过脚本自动检测，然后通过返回 0 来表示测试通过，返回其他值表示不通过，那么就可以省下手工测试的环节了。直接在第 4 步标记完之后，执行 <code>git run &lt;你的测试脚本&gt;</code>，git 将自动重复执行 第 4、5 步，直至找到第一个有问题的版本。</p><p>整体solution如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">➜  git_hug git:(master) git bisect start</span><br><span class="line">➜  git_hug git:(master) make test</span><br><span class="line">ruby prog.rb 5 | ruby test.rb</span><br><span class="line">make: *** [test] Error 1</span><br><span class="line">➜  git_hug git:(master) git bisect bad</span><br><span class="line">➜  git_hug git:(master) git log</span><br><span class="line">➜  git_hug git:(master) git checkout f608824888b83bbedc1f658be7496ffea467a8fb</span><br><span class="line">Note: checking out &#39;f608824888b83bbedc1f658be7496ffea467a8fb&#39;.</span><br><span class="line"></span><br><span class="line">You are in &#39;detached HEAD&#39; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at f608824... First commit</span><br><span class="line">➜  git_hug git:(f608824) make test</span><br><span class="line">ruby prog.rb 5 | ruby test.rb</span><br><span class="line">➜  git_hug git:(f608824) git bisect good</span><br><span class="line">Bisecting: 9 revisions left to test after this (roughly 3 steps)</span><br><span class="line">[fdbfc0d403e5ac0b2659cbfa2cbb061fcca0dc2a] Another Commit</span><br><span class="line">➜  git_hug git:(fdbfc0d) git bisect run make test</span><br><span class="line">running make test</span><br><span class="line">ruby prog.rb 5 | ruby test.rb</span><br><span class="line">Bisecting: 4 revisions left to test after this (roughly 2 steps)</span><br><span class="line">[18ed2ac1522a014412d4303ce7c8db39becab076] Another Commit</span><br><span class="line">running make test</span><br><span class="line">ruby prog.rb 5 | ruby test.rb</span><br><span class="line">make: *** [test] Error 1</span><br><span class="line">Bisecting: 2 revisions left to test after this (roughly 1 step)</span><br><span class="line">[9f54462abbb991b167532929b34118113aa6c52e] Another Commit</span><br><span class="line">running make test</span><br><span class="line">ruby prog.rb 5 | ruby test.rb</span><br><span class="line">Bisecting: 0 revisions left to test after this (roughly 1 step)</span><br><span class="line">[5db7a7cb90e745e2c9dbdd84810ccc7d91d92e72] Another Commit</span><br><span class="line">running make test</span><br><span class="line">ruby prog.rb 5 | ruby test.rb</span><br><span class="line">18ed2ac1522a014412d4303ce7c8db39becab076 is the first bad commit</span><br><span class="line">commit 18ed2ac1522a014412d4303ce7c8db39becab076</span><br><span class="line">Author: Robert Bittle &lt;guywithnose@gmail.com&gt;</span><br><span class="line">Date:   Mon Apr 23 06:52:10 2012 -0400</span><br><span class="line"></span><br><span class="line">    Another Commit</span><br><span class="line"></span><br><span class="line">:100644 100644 917e70054c8f4a4a79a8e805c0e1601b455ad236 7562257b8e6446686ffc43a2386c50c254365020 M  prog.rb</span><br><span class="line">bisect run success</span><br><span class="line">➜  git_hug git:(5db7a7c) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">What are the first 7 characters of the hash of the commit that introduced the bug? 18ed2ac1522</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>50</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Name: stage_lines</span><br><span class="line">Level: 50</span><br><span class="line">Difficulty: ****</span><br><span class="line"></span><br><span class="line">You&#39;ve made changes within a single file that belong to two different features, but neither of the changes are yet staged. Stage only the changes belonging to the first feature.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">  modified:   feature.rb</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br><span class="line">➜  git_hug git:(master) ✗ git add feature.rb -e</span><br><span class="line"></span><br><span class="line">[删除第二个commit]</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) ✗ githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><h1 id="51-56"><a href="#51-56" class="headerlink" title="51 - 56"></a>51 - 56</h1><p>51</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Name: find_old_branch</span><br><span class="line">Level: 51</span><br><span class="line">Difficulty: ****</span><br><span class="line"></span><br><span class="line">You have been working on a branch but got distracted by a major issue and forgot the name of it. Switch back to that branch.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(kill_the_batman) git reflog</span><br><span class="line">➜  git_hug git:(kill_the_batman) git checkout solve_world_hunger</span><br><span class="line">Switched to branch &#39;solve_world_hunger&#39;</span><br><span class="line">➜  git_hug git:(solve_world_hunger) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>52</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Name: revert</span><br><span class="line">Level: 52</span><br><span class="line">Difficulty: ****</span><br><span class="line"></span><br><span class="line">You have committed several times but want to undo the middle commit.</span><br><span class="line">All commits have been pushed, so you can&#39;t change existing history.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git revert HEAD^1</span><br><span class="line">[master e2a572b] Revert &quot;Bad commit&quot;</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> delete mode 100644 file3</span><br><span class="line">➜  git_hug git:(master) githug   </span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>53</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Name: restore</span><br><span class="line">Level: 53</span><br><span class="line">Difficulty: ****</span><br><span class="line"></span><br><span class="line">You decided to delete your latest commit by running &#96;git reset --hard HEAD^&#96;.  (Not a smart thing to do.)  You then change your mind, and want that commit back.  Restore the deleted commit.</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git reflog</span><br><span class="line">➜  git_hug git:(master) git checkout ef65ada</span><br><span class="line">Note: checking out &#39;ef65ada&#39;.</span><br><span class="line"></span><br><span class="line">You are in &#39;detached HEAD&#39; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at ef65ada... Restore this commit</span><br><span class="line">➜  git_hug git:(ef65ada) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>54</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Name: conflict</span><br><span class="line">Level: 54</span><br><span class="line">Difficulty: ****</span><br><span class="line"></span><br><span class="line">You need to merge mybranch into the current branch (master). But there may be some incorrect changes in mybranch which may cause conflicts. Solve any merge-conflicts you come across and finish the merge.</span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git branch</span><br><span class="line">* master</span><br><span class="line">  mybranch</span><br><span class="line">➜  git_hug git:(master) git merge mybranch </span><br><span class="line">Auto-merging poem.txt</span><br><span class="line">CONFLICT (content): Merge conflict in poem.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line">➜  git_hug git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">  both modified:   poem.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br><span class="line">➜  git_hug git:(master) ✗ vim poem.txt </span><br><span class="line">➜  git_hug git:(master) ✗ git add poem.txt </span><br><span class="line">➜  git_hug git:(master) ✗ git commit -m &quot;solve conflict&quot;</span><br><span class="line">[master 6ab8003] solve conflict</span><br><span class="line">➜  git_hug git:(master) githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>55</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Name: submodule</span><br><span class="line">Level: 55</span><br><span class="line">Difficulty: **</span><br><span class="line"></span><br><span class="line">You want to include the files from the following repo: &#96;https:&#x2F;&#x2F;github.com&#x2F;jackmaney&#x2F;githug-include-me&#96; into a the folder &#96;.&#x2F;githug-include-me&#96;. Do this without manually cloning the repo or copying the files from the repo into this repo.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  git_hug git:(master) git submodule add https:&#x2F;&#x2F;github.com&#x2F;jackmaney&#x2F;githug-include-me .&#x2F;githug-include-me</span><br><span class="line">Cloning into &#39;githug-include-me&#39;...</span><br><span class="line">remote: Counting objects: 9, done.</span><br><span class="line">remote: Total 9 (delta 0), reused 0 (delta 0), pack-reused 9</span><br><span class="line">Unpacking objects: 100% (9&#x2F;9), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">➜  git_hug git:(master) ✗ githug</span><br><span class="line">********************************************************************************</span><br><span class="line">*                                    Githug                                    *</span><br><span class="line">********************************************************************************</span><br><span class="line">Congratulations, you have solved the level!</span><br></pre></td></tr></table></figure><p>56</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name: contribute</span><br><span class="line">Level: 56</span><br><span class="line">Difficulty: ***</span><br><span class="line"></span><br><span class="line">This is the final level, the goal is to contribute to this repository by making a pull request on GitHub.  Please note that this level is designed to encourage you to add a valid contribution to Githug, not testing your ability to create a pull request.  Contributions that are likely to be accepted are levels, bug fixes and improved documentation.</span><br></pre></td></tr></table></figure><p>End，鼓励contribute，提PR。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python多线程</title>
      <link href="/2016/08/30/python-thread/"/>
      <url>/2016/08/30/python-thread/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h1><p>多进程和多线程都可以执行多个任务，线程是进程的一部分。线程的特点是线程之间可以共享内存和变量，资源消耗少（不过在Unix环境中，多进程和多线程资源调度消耗差距不明显，Unix调度较快），缺点是线程之间的同步和加锁比较麻烦。</p><h1 id="Python中多线程实现"><a href="#Python中多线程实现" class="headerlink" title="Python中多线程实现"></a>Python中多线程实现</h1><p>在Python中，对于多线程的实现，有两个标准模块thread和threading，我们在此主要使用较为高级的threading模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%s running'</span> % threading.current_thread().name</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%s ended'</span> % threading.current_thread().name</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'%s running'</span> % threading.current_thread().name</span><br><span class="line">t = threading.Thread(target=target)</span><br><span class="line"></span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'%s ended'</span> % threading.current_thread().name</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line">MainThread running</span><br><span class="line">Thread<span class="number">-1</span> running</span><br><span class="line">Thread<span class="number">-1</span> ended</span><br><span class="line">MainThread ended</span><br></pre></td></tr></table></figure><p>在上面的例子中，start是启动线程，join是阻塞当前线程。从结果可以看到，主线程直到Thread-1结束之后才结束。</p><h1 id="线程锁和ThreadLocal"><a href="#线程锁和ThreadLocal" class="headerlink" title="线程锁和ThreadLocal"></a>线程锁和ThreadLocal</h1><h2 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h2><p>对于多线程来说，最大的特点就是线程之间可以共享数据，那么共享数据的过程中就会出现多个线程同时更改一个变量，使用同样的资源，从而出现死锁、数据错乱的情况。</p><p>假设有两个全局资源，a和b，有两个线程thread1，thread2。thread1占用a，想访问b，但此时thread2占用b，想访问a，两个线程都不释放此时拥有的资源，那么就会造成死锁。</p><p>为了解决上述问题，出现了Lock。在访问某个资源之前，使用<code>Lock.acquire()</code>锁住资源；在访问之后，通过<code>Lock.release()</code>释放资源。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'the curent threading  %s is running'</span> % threading.current_thread().name</span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a += <span class="number">3</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        lock.release()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%s ended'</span> % threading.current_thread().name</span><br></pre></td></tr></table></figure><p>这里使用finally的目的是防止当前进程无限占用资源。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>介绍完线程锁，接下来我们介绍ThreadLocal。当不想将变量传递给其他线程时，可以使用局部变量，但是在函数中定义局部变量会使得在函数之间传递非常麻烦。ThreadLocal是非常牛逼的东西，它解决了全局变量需要加锁，局部变量传递麻烦的问题。</p><p>通过在线程中定义<code>local = threading.local()</code>，此时local就变成了一个全局变量，但是这个local只是在该线程中为全局变量，对于其他的线程来说是局部变量，也即别的线程不可更改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">local = threading.local()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'current thread: %s'</span> % threading.currentThread().name</span><br><span class="line">    local.name = name</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s in %s"</span> % (local.name,threading.currentThread().name)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=func,args=(<span class="string">'haibo'</span>,))</span><br><span class="line">t2 = threading.Thread(target=func,args=(<span class="string">'lina'</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">current thread: t1</span><br><span class="line">haibo <span class="keyword">in</span> t1</span><br><span class="line">current thread: t2</span><br><span class="line">lina <span class="keyword">in</span> t2</span><br></pre></td></tr></table></figure><p>ThreadLocal使用最多的地方就是每个线程处理一个HTTP请求。</p><h1 id="使用Map实现多线程"><a href="#使用Map实现多线程" class="headerlink" title="使用Map实现多线程"></a>使用Map实现多线程</h1><p>对于多线程的使用，我们通常是用thread或者threading来创建，比较麻烦。如果要创建更多的线程，那就要一一加到里面，不仅操作麻烦，而且代码可读性也很差。</p><p>在Python中，我们可以使用map来简化代码。map可以实现多任务的并发，简单示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">urls = [<span class="string">'http://www.baidu.com'</span>,<span class="string">'http://www.sina.com'</span>,<span class="string">'http://www.qq.com'</span>]</span><br><span class="line">results = map(urllib2.urlopen, urls)</span><br></pre></td></tr></table></figure><p>map将urls列表中每一个元素当做参数分别传给<code>urllib2.urlopen</code>函数，并且把结果放到result列表中。map的原理：</p><p><img src="/images/python_map.png" alt="python_map"></p><p>由此可见，map函数负责将线程分给不同的CPU。</p><p>在Python中有两个库包含了map函数：multiprocessing和它鲜为人知的子库multiprocessing.dummy。dummy是multiprocessing模块的完整克隆，唯一的不同在于multiprocessing作用于<strong>进程</strong>，而dummy模块作用于<strong>线程</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool <span class="keyword">as</span> ThreadPool</span><br><span class="line"></span><br><span class="line">urls = [<span class="string">'http://www.baidu.com'</span>,<span class="string">'http://www.sina.com'</span>,<span class="string">'http://www.qq.com'</span>]</span><br><span class="line"></span><br><span class="line">pool = ThreadPool()</span><br><span class="line"></span><br><span class="line">results = pool.map(urllib2.urlopen, urls)</span><br><span class="line"><span class="keyword">print</span> results</span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure><ul><li><code>pool = ThreadPool()</code>创建了线程池，默认值为当前机器CPU的核数，我们也可以指定线程池的大小，但不是越多越好，因为过多的话，线程之间的切换也是很消耗资源的。</li><li><code>results = pool.map(urllib2.urlopen, urls)</code>语句将不同的url传给各自的线程，并且把执行结果返回到result中。</li></ul><h1 id="Python多线程的缺陷-——-GIL"><a href="#Python多线程的缺陷-——-GIL" class="headerlink" title="Python多线程的缺陷 —— GIL"></a>Python多线程的缺陷 —— GIL</h1><p>上面说了那么多关于多线程的用法，但是在Python中多线程并不能真正的发挥作用，因为在Python中有一个GIL，即全局解释锁，该锁的存在保证在同一时间只能有一个线程执行任务，也就是说多线程并不是真正的并发，而是交替的进行。</p><h2 id="什么是GIL"><a href="#什么是GIL" class="headerlink" title="什么是GIL"></a>什么是GIL</h2><p>首先需要明确一点，GIL并不是Python的特性，它是在实现Python解释器（CPython）时所引入的一个概念。类似C++是一套语言标准，但是可以通过GCC、Visual C++等不同的编译器来编译成可执行代码。Python也是一样，同样一段代码可以通过CPython、PyPy、Psyco等不同的Python执行环境来执行。像其中的JPython就没有GIL，然而大部分环境下CPython是Python的默认执行环境，所以在很多人的概念中CPython就是Python，也就是想当然的将GIL归结为Python语言的缺陷。所以这里要先明确：<strong>GIL并不是Python的特性，Python完全可以不依赖于GIL</strong>。</p><p>官方给出的CPython中的GIL（Global Interpreter Lock）解释如下：</p><blockquote><p>In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)</p></blockquote><p>乍一看，GIL就是CPython中的全局锁。</p><h2 id="为什么会有GIL"><a href="#为什么会有GIL" class="headerlink" title="为什么会有GIL"></a>为什么会有GIL</h2><p>由于硬件的提升，CPU逐渐发展成多核，为了更加有效的利用多核处理器的性能，就出现了多线程的编程方式，而随之而来的就是线程间数据一致性和状态同步的困难。即使在CPU内部的Cache也不例外，为了有效解决多份缓存之间的数据同步，各厂商花费了不少心思，同时也不可避免的带来了一定的性能损失。</p><p>Python也是为了利用多核，开始支持多线程。而解决多线程之间<strong>数据完整性</strong>和<strong>状态同步</strong>的最简单方法自然就是加锁。于是有了GIL这把超级大锁，而当越来越多的开发者接受了这种设定后，他们开始大量的依赖这种特性（即默认python内部对象是thread-safe的，无需在实现时考虑额外的内存锁和同步操作）。</p><h2 id="当前GIL设计的缺陷"><a href="#当前GIL设计的缺陷" class="headerlink" title="当前GIL设计的缺陷"></a>当前GIL设计的缺陷</h2><p>伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># acquire GIL</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1000</span>:</span><br><span class="line">        do something</span><br><span class="line">    <span class="comment"># release GIL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Give Operating System a chance to do thread scheduling</span></span><br></pre></td></tr></table></figure><p>这种模式在只有一个CPU核心的情况下毫无问题。任何一个线程被唤起时都能够成功的获得GIL（因为只有释放了GIL才会引发线程调度）。但是当CPU有多个核的时候，问题就来了。从伪代码中可以看到，从<code>release GIL</code>到<code>acquire GIL</code>之间几乎是没有间隙的。所以当在其他核上的线程被唤起时，大部分情况下主线程已经又再一次获取到GIL了。这个时候被唤起的线程只能白白的浪费CPU时间，看着另一个线程拿着GIL欢快的执行着。然后达到切换时间后进入待调度状态，再被唤醒，再等待，由此往复恶性循环。</p><p>当然这种实现方式是原始而丑陋的，Python的每个版本中也在逐渐改进GIL和线程调度之间的互动关系。例如先尝试持有GIL再做上下文切换，在IO等待时释放GIL等尝试。但是无法改变的是GIL的存在使得操作系统线程调度这个本来就昂贵的操作变得更加奢侈了。</p><p>为了直观的理解GIL对于多线程带来的性能影响，这里直接借用一张测试结果图。图中表示的是两个线程在双核CPU上的执行情况。两个线程均为CPU密集型运算线程。绿色部分表示该线程正在运行，且在执行有用的计算，红色部分表示线程被调度唤醒，但是无法获取GIL，导致无法进行有效运算所等待的时间。</p><p><img src="/images/CPU_crowded.png" alt="CPU_crowded"></p><p>由此可见，GIL的存在导致多线程无法很好的利用多核CPU的并发处理能力。</p><p>那么Python的IO密集型线程能否从多线程中收益呢？我们来看下面这张测试结果。颜色代表的含义同上图一致。白色部分表示IO线程 处于等待。可见，当IO线程收到数据包引起终端切换后，仍然由于一个CPU密集型线程的存在，导致无法获取GIL锁，从而进行无尽的循环等待。</p><p><img src="/images/IO_crowded.png" alt="IO_crowded"></p><p>简单总结下就是：Python的多线程在多核CPU上，<strong>只对于IO密集型计算产生正面效果；而当有至少一个CPU密集型线程存在时，多线程的效率会由于GIL的存在而大幅下降</strong>。</p><h2 id="如何避免GIL产生的影响"><a href="#如何避免GIL产生的影响" class="headerlink" title="如何避免GIL产生的影响"></a>如何避免GIL产生的影响</h2><p>说了这么多，如果不说解决方案就仅仅是个科普贴。GIL这么烂，有没有办法绕过呢？我们来看一下有哪些现成的方案。</p><h3 id="用multiprocessing替代Thread"><a href="#用multiprocessing替代Thread" class="headerlink" title="用multiprocessing替代Thread"></a>用multiprocessing替代Thread</h3><p>multiprocessing库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。正如我们上面所说，它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是它使用了<strong>多进程</strong>而不是<strong>多线程</strong>。每个进程有自己独立的GIL，因此不会出现进程之间的GIL争抢。</p><p>当然multiprocessing也不是万能良药。它的引入会增加程序实现时线程间数据通讯和同步的困难。就拿计数器举例子，如果我们要多个线程累加同一个变量，对于thread来说，申明一个global变量，用<code>thread.Lock</code>的context包裹住三行就搞定了。而multiprocessing由于进程之间无法看到对方的数据，只能通过在主线程声明一个Queue，put再get或者用share memory的方式。这个额外的实现成本使得本来就非常痛苦的多线程编码变得更加痛苦了。</p><h3 id="使用其他的解析器"><a href="#使用其他的解析器" class="headerlink" title="使用其他的解析器"></a>使用其他的解析器</h3><p>之前也提到了既然GIL只是CPython的产物，那么其他解析器是不是更好呢？像JPython和IronPython这样的解析器由于实现语言的特性，他们不需要GIL的帮助。然而由于用了Java/C#作为解析器的实现，他们也失去了利用社区众多C语言模块有用特性的机会。所以这些解析器也因此一直都比较小众，毕竟功能和性能大家在初期都会选择前者。</p><h2 id="GIL总结"><a href="#GIL总结" class="headerlink" title="GIL总结"></a>GIL总结</h2><p>Python GIL其实是功能和性能之间权衡后的产物，它有其存在的合理性，也有比较难改变的客观因素。从本文的分析中，我们可以做以下简单的总结：</p><ul><li>因为GIL的存在，只有IO Bound场景下的多线程会得到较好的性能</li><li>如果对并行计算性能较高的程序可以考虑把核心部分也变为C模块，或者索性用其他语言实现</li><li>GIL在较长一段时间内将会继续存在，但是会不断改进</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一句话来总结本文的分析结果：<strong>Python多线程在IO密集型任务中还是很有用处的，而对于计算密集型任务，应该使用Python多进程</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python内存管理</title>
      <link href="/2016/08/21/python-memory-control/"/>
      <url>/2016/08/21/python-memory-control/</url>
      
        <content type="html"><![CDATA[<p>本文主要为了解释清楚python的内存管理机制，首先介绍了一下python关于内存使用的一些基本概念，然后介绍了引用计数和垃圾回收gc模块，并且解释了分代回收和“标记-清除”法，然后分析了一下各种操作会导致python变量和对象的变化，最后做了一下小结。</p><h1 id="Python变量、对象、引用、存储"><a href="#Python变量、对象、引用、存储" class="headerlink" title="Python变量、对象、引用、存储"></a>Python变量、对象、引用、存储</h1><p>python语言是一种解释性的编程语言，它不同于一些传统的编译语言，不是先编译成汇编再编程机器码，而是在运行的过程中，逐句将指令解释成机器码，所以造就了python语言一些特别的地方。例如<code>a = 1</code>，其中a是变量，1是对象。这里所谓的变量，它的意义类似一个指针，它本身是没有类型的，只有它指向的那个对象是什么类型，它才是什么类型，一旦把它指到别的地方，它的类型就变了，现在指向的是1，它的类型可以认为是int，假如接下来执行<code>a = 2.5</code>，那么变量的类型就变了。甚至当先给<code>a=1</code>，<code>a = a + 1</code>时，a的地址也会改变。而这里的1,2.5或者一个list一个dict就是一个被实例化的对象，对象拥有真正的资源与取值，当一个变量指向某个对象，被称为这个对象的产生了一个引用，一个对象可以有多个变量指向它，有多个引用。而一个变量可以随时指向另外的对象。同时一个变量可以指向另外一个变量，那么它们指向的那个对象的引用就增加了一个。</p><p>Python有个特别的机制，它会在解释器启动的时候事先分配好一些缓冲区，这些缓冲区部分是固定好取值，例如整数[-5,256]的内存地址是固定的(这里的固定指这一次程序启动之后，这些数字在这个程序中的内存地址就不变了，但是启动新的python程序，两次的内存地址不一样)。有的缓冲区就可以重复利用。这样的机制就使得不需要python频繁的调用内存malloc和free。下面的id是取内存地址，hex是转成16进制表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一次启动解释器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(<span class="number">1</span>))</span><br><span class="line"><span class="string">'0x14c5158'</span></span><br><span class="line"><span class="comment">#第二次启动解释器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(<span class="number">1</span>))</span><br><span class="line"><span class="string">'0xe17158'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#缓冲区被重复利用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(<span class="number">100000</span>))</span><br><span class="line"><span class="string">'0xe5be00'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(<span class="number">1000000</span>))</span><br><span class="line"><span class="string">'0xe5be00'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(<span class="number">10000000</span>))</span><br><span class="line"><span class="string">'0xe5be00'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(<span class="number">100000000</span>))</span><br><span class="line"><span class="string">'0xe5be00'</span></span><br></pre></td></tr></table></figure><p>针对整数对象，它的内存区域似乎是一个单独的区域，跟string、dict等的内存空间都不一样，从实验结果来看，它的地址大小只有’0xe5be00’，其他的是’0x7fe7e03c7698’。而存储整数对象的这块区域，有一块内存区域是事先分配好的，即[-5,256]范围内的整数。这块称为小整数缓冲池，静态分配，对某个变量赋值就是直接从里面取就行了，在python初始化时被创建。而另外的整数缓冲池称为大整数缓冲池，这块内存也是已经分配好了，只是要用的时候再赋值。可以从下面的例子中看到，针对257这个数字，虽然给a和b赋了相同的值，但是解释器实际上是先分配了不同的地址，再把这个地址给两个变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a))</span><br><span class="line"><span class="string">'0xe17158'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(b))</span><br><span class="line"><span class="string">'0xe17158'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a))</span><br><span class="line"><span class="string">'0xe5be00'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(b))</span><br><span class="line"><span class="string">'0xe5bdd0'</span></span><br></pre></td></tr></table></figure><p>针对string类型，它也有自己的缓冲区，也是分为固定缓冲区和可重复缓冲区，固定的是256个ASCII码字符。还发现一个有意思的现象，string中只要不出现除了字母和数字其他字符，那么对a和b赋同样的值，它们的内存地址都相同。但是如果string对象中有其他字符，那么对两个变量赋相同的string值，它们的内存地址还是不一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">'aaaaaaaaaaaaaaaaaaaa'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(b))</span><br><span class="line"><span class="string">'0x7fe7e03af848'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'aaaaaaaaaaaaaaaaaaaa'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a))</span><br><span class="line"><span class="string">'0x7fe7e03af848'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'abcd%'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">'abcd%'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a))</span><br><span class="line"><span class="string">'0x7fe7e02d4900'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(b))</span><br><span class="line"><span class="string">'0x7fe7e02d48d0'</span></span><br></pre></td></tr></table></figure><p>而另外的dict和list的缓冲区也是事先分配好，大小为80个对象。</p><p>因此变量的存储有三个区域，事先分配的静态内存、事先分配的可重复利用内存以及需要通过malloc和free来控制的自由内存。</p><h1 id="Python内存管理机制和操作对变量的影响"><a href="#Python内存管理机制和操作对变量的影响" class="headerlink" title="Python内存管理机制和操作对变量的影响"></a>Python内存管理机制和操作对变量的影响</h1><h2 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h2><p>python的内存在底层也是由malloc和free的方式来分配和释放，只是它代替程序员决定什么时候分配什么时候释放，同时也提供接口让用户手动释放，因此它有自己的一套内存管理体系，主要通过两种机制来实现，一个是引用计数，一个是垃圾回收。前者负责确定当前变量是否需要释放，后者解决前者解决不了的循环引用问题以及提供手动释放的接口。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p><strong><em>引用计数(reference counting)</em></strong>，针对可以重复利用的内存缓冲区和内存，python使用了一种引用计数的方式来控制和判断某快内存是否已经没有再被使用。即每个对象都有一个计数器count，记住了有多少个变量指向这个对象，当这个对象的引用计数器为0时，假如这个对象在缓冲区内，那么它地址空间不会被释放，而是等待下一次被使用，而非缓冲区的该释放就释放。</p><p>这里通过sys包中的getrefcount()来获取当前对象有多少个引用。这里返回的引用个数分别是2和3，比预计的1和2多了一个，这是因为传递参数给getrefcount的时候产生了一个临时引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(a)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(a)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>当一个变量通过另外一个变量赋值，那么它们的对象引用计数就增加1，当其中一个变量指向另外的地方，之前的对象计数就减少1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(a)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(a)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(b)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(a)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(b)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p><strong><em>垃圾回收(Garbage Collection)</em></strong>，python提供了del方法来删除某个变量，它的作用是让某个对象引用数减少1。当某个对象引用数变为0时并不是直接将它从内存空间中清除掉，而是采用垃圾回收机制gc模块，当这些引用数为0的变量规模达到一定规模，就自动启动垃圾回收，将那些引用数为0的对象所占的内存空间释放。这里gc模块采用了分代回收方法，将对象根据存活的时间分为三“代”，所有新建的对象都是0代，当0代对象经过一次自动垃圾回收，没有被释放的对象会被归入1代，同理1代归入2代。每次当0代对象中引用数为0的对象超过700个时，启动一次0代对象扫描垃圾回收，经过10次的0代回收，就进行一次0代和1代回收，1代回收次数超过10次，就会进行一次0代、1代和2代回收。而这里的几个值是通过查询get_threshold()返回(700,10,10)得到的。此外，gc模块还提供了手动回收的函数，即gc.collect()。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(a)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(a)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>而垃圾回收还有一个重要功能是，解决循环引用的问题，通常发生在某个变量a引用了自己或者变量a与b互相引用。考虑引用自己的情况，可以从下面的例子中看到，a所指向的内存对象有3个引用，但是实际上只有两个变量，假如把这两个变量都del掉，对象引用个数还是1，没有变成0，这种情况下，如果只有引用计数的机制，那么这块没有用的内存会一直无法释放掉。</p><p><img src="/images/gc_graph.png" alt="gc_graph"></p><p>python的gc模块利用了“标记-清除”法，即认为有效的对象之间能通过有向图连接起来，其中图的节点是对象，而边是引用，上图中obj代表对象，ref代表引用，从一些不能被释放的对象节点出发(称为root object，一些全局引用或者函数栈中的引用[5]，例如上图的obj_1，箭头表示obj_1引用了obj_2)遍历各代引用数不为0的对象。在python源码中，每个变量不仅有一个引用计数，还有一个有效引用计数gc_ref，后者一开始等于前者，但是启动标记清除法开始遍历对象时，从root object出发(初始图中的gc_ref为(1,1,1,1,1,1,1))，当对象i引用了对象j时，将对象j的有效引用个数减去1，这样上图中各个对象有效引用个数变为了(1, 0, 0, 0, 0, 0, 0)，接着将所有对象分配到两个表中，一个是reachable对象表，一个是unreachable对象表，root object和在图中能够直接或者间接与它们相连的对象就放入reachable，而不能通过root object访问到且有效引用个数变为0的对象作为放入unreachable，从而通过这种方式来消去循环引用的影响。</p><p>在人工调用gc.collect()的时候会有一个返回值，这个返回值就是这一次扫描unreachable的对象个数。在上面谈到的每一代的回收过程中，都会启用“标记-清除”法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(b)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(b)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(b)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unreachable = gc.collect()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unreachable</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="各种操作对变量地址的改变"><a href="#各种操作对变量地址的改变" class="headerlink" title="各种操作对变量地址的改变"></a>各种操作对变量地址的改变</h2><p>当处理赋值、加减乘除时，这些操作实际上导致变量指向的对象发生了改变，已经不是原来的那个对象了，并不是通过这个变量来改变它指向的对象的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a))</span><br><span class="line"><span class="string">'0xe17080'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = a - <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a))</span><br><span class="line"><span class="string">'0xe17098'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = a + <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a))</span><br><span class="line"><span class="string">'0xe17080'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = a * <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a))</span><br><span class="line"><span class="string">'0xe177a0'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = a / <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a))</span><br><span class="line"><span class="string">'0xe17488'</span></span><br></pre></td></tr></table></figure><p>增加减少list、dict对象内容是在对对象本身进行操作，此时变量的指向并没有改变，它作为对象的一个别名/引用，通过操纵变量来改变对应的对象内容。但是一旦将变量赋值到别的地方去，那么变量地址就改变了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a))</span><br><span class="line"><span class="string">'0x7fe7e02caef0'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a))</span><br><span class="line"><span class="string">'0x7fe7e02caef0'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a))</span><br><span class="line"><span class="string">'0x7fe7e02caea8'</span></span><br></pre></td></tr></table></figure><p>当把一个list变量赋值给另外一个变量时，这两个变量是等价的，它们都是原来对象的一个引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a))</span><br><span class="line"><span class="string">'0x7fe7e02caea8'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(b))</span><br><span class="line"><span class="string">'0x7fe7e02caea8'</span></span><br></pre></td></tr></table></figure><p>但是实际使用中，可能需要的是将里面的内容给复制出来到一个新的地址空间，这里可以使用python的copy模块，copy模块分为两种拷贝，一种是浅拷贝，一种是深拷贝。假设处理一个list对象，浅拷贝调用函数<code>copy.copy()</code>，产生了一块新的内存来存放list中的每个元素引用，也就是说每个元素的跟原来list中元素地址是一样的。所以从下面例子中可看出当原list中要是包含list对象，分别在a和b对list元素做操作时，两边都受到了影响。此外，通过b=list(a)来对变量b赋值时，也跟浅拷贝的效果一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">1000</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = copy.copy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">1000</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a))</span><br><span class="line"><span class="string">'0x7fe7e02e1368'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(b))</span><br><span class="line"><span class="string">'0x7fe7e02e1518'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a[<span class="number">2</span>]))</span><br><span class="line"><span class="string">'0x7fe7e02caea8'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(b[<span class="number">2</span>]))</span><br><span class="line"><span class="string">'0x7fe7e02caea8'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>].append(<span class="string">'a+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">1000</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a+'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">1000</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a+'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">2</span>].append(<span class="string">'b+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">1000</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a+'</span>, <span class="string">'b+'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">1000</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a+'</span>, <span class="string">'b+'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">2</span>, <span class="number">1000</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a+'</span>, <span class="string">'b+'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">2</span>, <span class="number">1000</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a+'</span>, <span class="string">'b+'</span>]]</span><br></pre></td></tr></table></figure><p>而深拷贝则调用<code>copy.deepcopy()</code>，它将原list中每个元素都复制了值到新的内存中去了，因此跟原来的元素地址不相同，那么再对a和b的元素做操作，就是互相不影响了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">1000</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = copy.deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a))</span><br><span class="line"><span class="string">'0x7fe7e02cae18'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(b))</span><br><span class="line"><span class="string">'0x7fe7e02e1368'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(a[<span class="number">2</span>]))</span><br><span class="line"><span class="string">'0x7fe7e02e14d0'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(id(b[<span class="number">2</span>]))</span><br><span class="line"><span class="string">'0x7fe7e02e1320'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>].append(<span class="string">'a+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">1000</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a+'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">1000</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">2</span>].append(<span class="string">'b+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">1000</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a+'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">1000</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b+'</span>]]</span><br></pre></td></tr></table></figure><p>当把一个变量传入一个函数时，它对应的对象引用个数增加2。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git rebase命令用法</title>
      <link href="/2016/08/04/git-rebase/"/>
      <url>/2016/08/04/git-rebase/</url>
      
        <content type="html"><![CDATA[<p>假设你现在基于远程分支”origin”，创建一个叫”mywork”的分支。</p><pre><code>$ git checkout -b mywork origin</code></pre><p><img src="/images/rebase0.png" alt="rebase0"></p><p>现在我们在这个分支做一些修改，然后生成两个提交(commit)。</p><pre><code>$ vim file.txt$ git commit$ vim otherfile.txt$ git commit...</code></pre><p>但是与此同时，有些人也在”origin”分支上做了一些修改并且做了提交了. 这就意味着”origin”和”mywork”这两个分支各自”前进”了，它们之间”分叉”了。</p><p><img src="/images/rebase1.png" alt="rebase1"></p><p>在这里，你可以用”pull”命令把”origin”分支上的修改拉下来并且和你的修改合并；结果看起来就像一个新的”合并的提交”(merge commit):</p><p><img src="/images/rebase2.png" alt="rebase2"></p><p>但是，如果你想让”mywork”分支历史看起来像没有经过任何合并一样，你也许可以用<a href="https://www.kernel.org/pub/software/scm/git/docs/git-rebase.html" target="_blank" rel="noopener">git rebase</a>:</p><pre><code>$ git checkout new$ git rebase origin</code></pre><p>这些命令会把你的”mywork”分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git/rebase”目录中),然后把”mywork”分支更新到最新的”origin”分支，最后把保存的这些补丁应用到”mywork”分支上。</p><p><img src="/images/rebase3.png" alt="rebase3"></p><p>当”mywork”分支更新之后，它会指向这些新创建的提交(commit),而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection), 这些被丢弃的提交就会删除。</p><p><img src="/images/rebase4.png" alt="rebase4"></p><p><img src="/images/rebase5.png" alt="rebase5"></p><p>在rebase的过程中，也许会出现冲突(conflict)。在这种情况，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，用<code>git add</code>命令去更新这些内容的索引(index)，然后，你无需执行<code>git commit</code>，只要执行:</p><pre><code>$ git rebase --continue</code></pre><p>这样git会继续应用(apply)余下的补丁。</p><p>在任何时候，你可以用<code>--abort</code>参数来终止rebase的行动，并且”mywork” 分支会回到rebase开始前的状态。</p><pre><code>$ git rebase --abort</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pandas简介和使用</title>
      <link href="/2016/07/18/pandas-intro/"/>
      <url>/2016/07/18/pandas-intro/</url>
      
        <content type="html"><![CDATA[<p>Pandas是基于NumPy的一个非常好用的库，正如名字一样，人见人爱。之所以如此，就在于不论是读取、处理数据，用它都非常简单。此前有一篇文章《<a href="http://geek.csdn.net/news/detail/2780" target="_blank" rel="noopener">别老扯什么Hadoop了，你的数据根本不够大</a>》指出：只有在超过5TB数据量的规模下，Hadoop才是一个合理的技术选择。相对小一些的数据，我这两天发现使用Python + Pandas处理起来更加敏捷。</p><p>安装Pandas非常简单，只需要一行命令（当然你需要先安装pip）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pandas</span><br></pre></td></tr></table></figure><h1 id="Pandas数据读取性能"><a href="#Pandas数据读取性能" class="headerlink" title="Pandas数据读取性能"></a>Pandas数据读取性能</h1><p>Pandas提供了IO工具可以将大文件分块读取，测试了一下性能，完整加载9800万条数据也只需要263秒左右，还是相当不错了。</p><p>根据测试，对于不同数据量的数据读取时间如下：</p><table><thead><tr><th></th><th>1百万条</th><th>1千万条</th><th>1亿条</th></tr></thead><tbody><tr><td>Data</td><td>1s</td><td>17s</td><td>263s</td></tr></tbody></table><h1 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h1><p>Pandas有两种自己独有的基本数据结构。应该注意的是，它固然有着两种数据结构，因为它依然是python的一个库，所以，python中有的数据类型在这里依然适用，也同样还可以使用类自己定义数据类型。只不过，Pandas里面又定义了两种数据类型：Series和DataFrame，它们让数据操作更简单了。</p><p>以下操作都是基于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><p>Series就如同列表一样，是一系列数据，每个数据对应一个索引值。比如这样一个列表：[9, 3, 8]，如果跟索引值写到一起，就是：</p><table><thead><tr><th>data</th><th>9</th><th>3</th><th>8</th></tr></thead><tbody><tr><td>index</td><td>0</td><td>1</td><td>2</td></tr></tbody></table><p>这种样式我们已经熟悉了，不过，在有些时候，需要把它竖过来表示：</p><table><thead><tr><th>index</th><th>data</th></tr></thead><tbody><tr><td>0</td><td>9</td></tr><tr><td>1</td><td>3</td></tr><tr><td>2</td><td>8</td></tr></tbody></table><p>上面两种，只是表现形式上的差别而已，而Series就是竖起来的list:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Series([<span class="number">100</span>, <span class="string">"PYTHON"</span>, <span class="string">"Soochow"</span>, <span class="string">"Qiwsir"</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="number">0</span>        <span class="number">100</span></span><br><span class="line"><span class="number">1</span>     PYTHON</span><br><span class="line"><span class="number">2</span>    Soochow</span><br><span class="line"><span class="number">3</span>     Qiwsir</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure><p>另外一点也很像列表，就是里面的元素的类型，由你任意决定（其实是由需要来决定）。</p><p>这里，我们实质上创建了一个Series对象，这个对象当然就有其属性和方法了。比如，下面的两个属性依次可以显示Series对象的数据值和索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.values</span><br><span class="line">array([<span class="number">100</span>, <span class="string">'PYTHON'</span>, <span class="string">'Soochow'</span>, <span class="string">'Qiwsir'</span>], dtype=object)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.index</span><br><span class="line">RangeIndex(start=<span class="number">0</span>, stop=<span class="number">4</span>, step=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>列表的索引只能是从0开始的整数，Series数据类型在默认情况下，其索引也是如此。不过，区别于列表的是，Series可以自定义索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = Series([<span class="number">100</span>, <span class="string">"PYTHON"</span>, <span class="string">"Soochow"</span>, <span class="string">"Qiwsir"</span>], \</span><br><span class="line"><span class="meta">... </span>index=[<span class="string">"mark"</span>, <span class="string">"title"</span>, <span class="string">"university"</span>, <span class="string">"name"</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2</span><br><span class="line">mark              <span class="number">100</span></span><br><span class="line">title          PYTHON</span><br><span class="line">university    Soochow</span><br><span class="line">name           Qiwsir</span><br><span class="line">dtype: object</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.index</span><br><span class="line">Index([<span class="string">u'mark'</span>, <span class="string">u'title'</span>, <span class="string">u'university'</span>, <span class="string">u'name'</span>], dtype=<span class="string">'object'</span>)</span><br></pre></td></tr></table></figure><p>每个元素都有了索引，就可以根据索引操作元素了。类似于list中的操作，根据索引查看其值和修改其值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2[<span class="string">"name"</span>]</span><br><span class="line"><span class="string">'Qiwsir'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2[<span class="string">"name"</span>] = <span class="string">"AOI"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2</span><br><span class="line">mark              <span class="number">100</span></span><br><span class="line">title          PYTHON</span><br><span class="line">university    Soochow</span><br><span class="line">name              AOI</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure><p>某种程度上，还有些类似dict操作数据；如果对此不太理解，可以看下面的例子。</p><p>前面定义Series对象的时候，用的是列表，即Series()方法的参数中，第一个列表就是其数据值，如果需要定义index，放在后面，依然是一个列表。除了这种方法之外，还可以用下面的方法定义Series对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sd = &#123;<span class="string">"python"</span>:<span class="number">8000</span>, <span class="string">"c++"</span>:<span class="number">8100</span>, <span class="string">"c"</span>:<span class="number">4000</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s4 = Series(sd)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s4</span><br><span class="line">c         <span class="number">4000</span></span><br><span class="line">c++       <span class="number">8100</span></span><br><span class="line">python    <span class="number">8000</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>现在是否理解为什么前面那个类似dict了？因为本来就是可以这样定义的。</p><p>这时候，索引依然可以自定义。Pandas的优势在这里体现出来，如果自定义了索引，自定的索引会自动寻找原来的索引，如果一样的，就取原来索引对应的值，这个可以简称为“自动对齐”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s6 = Series(sd, index=[<span class="string">"java"</span>, <span class="string">"python"</span>, <span class="string">"c++"</span>, <span class="string">"c"</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s6</span><br><span class="line">java         NaN</span><br><span class="line">python    <span class="number">8000.0</span></span><br><span class="line">c++       <span class="number">8100.0</span></span><br><span class="line">c         <span class="number">4000.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>在sd中，只有<code>&#39;python&#39;:8000, &#39;c++&#39;:8100, &#39;c&#39;:4000</code>，没有<code>&quot;java&quot;</code>，但是在索引参数中有，于是其它能够“自动对齐”的照搬原值，没有的那个<code>&quot;java&quot;</code>，依然在新Series对象的索引中存在，并且自动为其赋值<code>NaN</code>。在Pandas中，如果没有值，都对齐赋给<code>NaN</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.isnull(s6)</span><br><span class="line">java       <span class="literal">True</span></span><br><span class="line">python    <span class="literal">False</span></span><br><span class="line">c++       <span class="literal">False</span></span><br><span class="line">c         <span class="literal">False</span></span><br><span class="line">dtype: bool</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.notnull(s6)</span><br><span class="line">java      <span class="literal">False</span></span><br><span class="line">python     <span class="literal">True</span></span><br><span class="line">c++        <span class="literal">True</span></span><br><span class="line">c          <span class="literal">True</span></span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure><p>此外，Series对象也有同样的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s6.isnull()</span><br><span class="line">java       <span class="literal">True</span></span><br><span class="line">python    <span class="literal">False</span></span><br><span class="line">c++       <span class="literal">False</span></span><br><span class="line">c         <span class="literal">False</span></span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure><p>对于Series数据，也可以做类似下面的运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3 = Series([<span class="number">3</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3</span><br><span class="line">a    <span class="number">3</span></span><br><span class="line">b    <span class="number">9</span></span><br><span class="line">c    <span class="number">4</span></span><br><span class="line">d    <span class="number">7</span></span><br><span class="line">dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3[s3 &gt; <span class="number">5</span>]</span><br><span class="line">b    <span class="number">9</span></span><br><span class="line">d    <span class="number">7</span></span><br><span class="line">dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3 * <span class="number">5</span></span><br><span class="line">a    <span class="number">15</span></span><br><span class="line">b    <span class="number">45</span></span><br><span class="line">c    <span class="number">20</span></span><br><span class="line">d    <span class="number">35</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>DataFrame是一种二维的数据结构，非常接近于电子表格或者类似mysql数据库的形式。它的竖行称之为columns，横行跟前面的Series一样，称之为index，也就是说可以通过columns和index来确定一个主句的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = &#123;<span class="string">"name"</span>:[<span class="string">"yahoo"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>], \</span><br><span class="line"><span class="meta">... </span><span class="string">"marks"</span>:[<span class="number">200</span>,<span class="number">400</span>,<span class="number">800</span>], <span class="string">"price"</span>:[<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>]&#125; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1 = DataFrame(data) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1 </span><br><span class="line">     marks  name      price </span><br><span class="line"><span class="number">0</span>    <span class="number">200</span>    yahoo     <span class="number">9</span> </span><br><span class="line"><span class="number">1</span>    <span class="number">400</span>    google    <span class="number">3</span> </span><br><span class="line"><span class="number">2</span>    <span class="number">800</span>    facebook  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>这是定义一个DataFrame对象的常用方法——使用dict定义。字典的“键”（”name”，”marks”，”price”）就是DataFrame的columns的值（名称），字典中每个“键”的“值”是一个列表，它们就是那一竖列中的具体填充数据。上面的定义中没有确定索引，所以，按照惯例（Series中已经形成的惯例）就是从0开始的整数。从上面的结果中很明显表示出来，这就是一个二维的数据结构（类似excel或者mysql中的查看效果）。</p><p>上面的数据显示中，columns的顺序没有规定，就如同字典中键的顺序一样，但是在DataFrame中，columns跟字典键相比，有一个明显不同，就是其顺序可以被规定，像下面这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2 = DataFrame(data, columns=[<span class="string">'name'</span>,<span class="string">'price'</span>,<span class="string">'marks'</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2</span><br><span class="line">       name  price  marks</span><br><span class="line"><span class="number">0</span>     yahoo      <span class="number">9</span>    <span class="number">200</span></span><br><span class="line"><span class="number">1</span>    google      <span class="number">3</span>    <span class="number">400</span></span><br><span class="line"><span class="number">2</span>  facebook      <span class="number">7</span>    <span class="number">800</span></span><br></pre></td></tr></table></figure><p>跟Series类似的，DataFrame数据的索引也能够自定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3 = DataFrame(data, columns=[<span class="string">'name'</span>, <span class="string">'price'</span>, <span class="string">'marks'</span>, <span class="string">'debt'</span>], index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3</span><br><span class="line">       name  price  marks debt</span><br><span class="line">a     yahoo      <span class="number">9</span>    <span class="number">200</span>  NaN</span><br><span class="line">b    google      <span class="number">3</span>    <span class="number">400</span>  NaN</span><br><span class="line">c  facebook      <span class="number">7</span>    <span class="number">800</span>  NaN</span><br></pre></td></tr></table></figure><p>还要注意观察上面的显示结果。因为在定义f3的时候，columns的参数中，比以往多了一项(‘debt’)，但是这项在data这个字典中并没有，所以debt这一竖列的值都是空的，在Pandas中，空就用NaN来代表了。</p><p>定义DataFrame的方法，除了上面的之外，还可以使用“字典套字典”的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>newdata = &#123;<span class="string">"lang"</span>:&#123;<span class="string">"firstline"</span>:<span class="string">"python"</span>,<span class="string">"secondline"</span>:<span class="string">"java"</span>&#125;, <span class="string">"price"</span>:&#123;<span class="string">"firstline"</span>:<span class="number">8000</span>&#125;&#125; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f4 = DataFrame(newdata)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f4</span><br><span class="line">              lang   price</span><br><span class="line">firstline   python  <span class="number">8000.0</span></span><br><span class="line">secondline    java     NaN</span><br></pre></td></tr></table></figure><p>在字典中就规定好数列名称（第一层键）和每横行索引（第二层字典键）以及对应的数据（第二层字典值），也就是在字典中规定好了每个数据格子中的数据，没有规定的都是空。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>DataFrame(newdata, index=[<span class="string">"firstline"</span>,<span class="string">"secondline"</span>,<span class="string">"thirdline"</span>])</span><br><span class="line">              lang   price</span><br><span class="line">firstline   python  <span class="number">8000.0</span></span><br><span class="line">secondline    java     NaN</span><br><span class="line">thirdline      NaN     NaN</span><br></pre></td></tr></table></figure><p>如果额外确定了索引，就如同上面显示一样，除非在字典中有相应的索引内容，否则都是NaN。</p><p>前面定义了DataFrame数据（可以通过两种方法），它也是一种对象类型，比如变量f3引用了一个对象，它的类型是DataFrame。承接以前的思维方法：对象有属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3.columns</span><br><span class="line">Index([<span class="string">u'name'</span>, <span class="string">u'price'</span>, <span class="string">u'marks'</span>, <span class="string">u'debt'</span>], dtype=<span class="string">'object'</span>)</span><br></pre></td></tr></table></figure><p>DataFrame对象的columns属性，能够显示现有的columns名称。并且，还能用下面类似字典的方式，得到某竖列的全部内容（当然包含索引）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3[<span class="string">'name'</span>] </span><br><span class="line">a       yahoo</span><br><span class="line">b      google</span><br><span class="line">c    facebook</span><br><span class="line">Name: name, dtype: object</span><br></pre></td></tr></table></figure><p>这是什么？这其实就是一个Series，或者说，可以将DataFrame理解为是由一个一个的Series组成的。</p><p>对于没有数值的那一列，下面的操作是统一给那一列赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3[<span class="string">'debt'</span>] = <span class="number">89.2</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3</span><br><span class="line">       name  price  marks  debt</span><br><span class="line">a     yahoo      <span class="number">9</span>    <span class="number">200</span>  <span class="number">89.2</span></span><br><span class="line">b    google      <span class="number">3</span>    <span class="number">400</span>  <span class="number">89.2</span></span><br><span class="line">c  facebook      <span class="number">7</span>    <span class="number">800</span>  <span class="number">89.2</span></span><br></pre></td></tr></table></figure><p>除了能够统一赋值之外，还能够“点对点”添加数值，结合前面的Series，既然DataFrame对象的每竖列都是一个Series对象，那么可以先定义一个Series对象，然后把它放到DataFrame对象中。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sdebt = Series([<span class="number">2.2</span>, <span class="number">3.3</span>], index=[<span class="string">"a"</span>,<span class="string">"c"</span>])    <span class="comment">#注意索引 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3[<span class="string">'debt'</span>] = sdebt</span><br></pre></td></tr></table></figure><p>将Series对象(sdebt变量所引用) 赋给f3[‘debt’]列，Pandas的一个重要特性——自动对齐——在这里起做用了，在Series中，只有两个索引（”a”,”c”），它们将和DataFrame中的索引自动对齐。于是有：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3</span><br><span class="line">       name  price  marks  debt</span><br><span class="line">a     yahoo      <span class="number">9</span>    <span class="number">200</span>   <span class="number">2.2</span></span><br><span class="line">b    google      <span class="number">3</span>    <span class="number">400</span>   NaN</span><br><span class="line">c  facebook      <span class="number">7</span>    <span class="number">800</span>   <span class="number">3.3</span></span><br></pre></td></tr></table></figure><p>自动对齐之后，没有被复制的依然保持NaN。</p><h1 id="Pandas使用"><a href="#Pandas使用" class="headerlink" title="Pandas使用"></a>Pandas使用</h1><p>由于篇幅限制，不能讲pandas所有内容完全详尽描述，只是做一个简单的介绍，在实践中使用如果遇到问题，建议参考相关文档或者google来解决（不要用baidu）。</p><h2 id="读取csv文件"><a href="#读取csv文件" class="headerlink" title="读取csv文件"></a>读取csv文件</h2><h3 id="普通办法读取"><a href="#普通办法读取" class="headerlink" title="普通办法读取"></a>普通办法读取</h3><p>最简单、最直接的就是open()打开文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">"./marks.csv"</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> line</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">name,physics,python,math,english</span><br><span class="line"></span><br><span class="line">Google,<span class="number">100</span>,<span class="number">100</span>,<span class="number">25</span>,<span class="number">12</span></span><br><span class="line"></span><br><span class="line">Facebook,<span class="number">45</span>,<span class="number">54</span>,<span class="number">44</span>,<span class="number">88</span></span><br><span class="line"></span><br><span class="line">Twitter,<span class="number">54</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">91</span></span><br><span class="line"></span><br><span class="line">Yahoo,<span class="number">54</span>,<span class="number">452</span>,<span class="number">26</span>,<span class="number">100</span></span><br></pre></td></tr></table></figure><p>此方法可以，但略显麻烦。python中还有一个csv的标准库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> csv </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(csv)</span><br><span class="line">[<span class="string">'Dialect'</span>, <span class="string">'DictReader'</span>, <span class="string">'DictWriter'</span>, <span class="string">'Error'</span>, <span class="string">'QUOTE_ALL'</span>, <span class="string">'QUOTE_MINIMAL'</span>, <span class="string">'QUOTE_NONE'</span>, <span class="string">'QUOTE_NONNUMERIC'</span>, <span class="string">'Sniffer'</span>, <span class="string">'StringIO'</span>, <span class="string">'_Dialect'</span>, <span class="string">'__all__'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__file__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__version__'</span>, <span class="string">'excel'</span>, <span class="string">'excel_tab'</span>, <span class="string">'field_size_limit'</span>, <span class="string">'get_dialect'</span>, <span class="string">'list_dialects'</span>, <span class="string">'re'</span>, <span class="string">'reader'</span>, <span class="string">'reduce'</span>, <span class="string">'register_dialect'</span>, <span class="string">'unregister_dialect'</span>, <span class="string">'writer'</span>]</span><br></pre></td></tr></table></figure><p>从上面结果可以看出，csv模块提供的属性和方法。仅仅就读取本例子中的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> csv </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>csv_reader = csv.reader(open(<span class="string">"./marks.csv"</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> csv_reader:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> row</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">[<span class="string">'name'</span>, <span class="string">'physics'</span>, <span class="string">'python'</span>, <span class="string">'math'</span>, <span class="string">'english'</span>]</span><br><span class="line">[<span class="string">'Google'</span>, <span class="string">'100'</span>, <span class="string">'100'</span>, <span class="string">'25'</span>, <span class="string">'12'</span>]</span><br><span class="line">[<span class="string">'Facebook'</span>, <span class="string">'45'</span>, <span class="string">'54'</span>, <span class="string">'44'</span>, <span class="string">'88'</span>]</span><br><span class="line">[<span class="string">'Twitter'</span>, <span class="string">'54'</span>, <span class="string">'76'</span>, <span class="string">'13'</span>, <span class="string">'91'</span>]</span><br><span class="line">[<span class="string">'Yahoo'</span>, <span class="string">'54'</span>, <span class="string">'452'</span>, <span class="string">'26'</span>, <span class="string">'100'</span>]</span><br></pre></td></tr></table></figure><p>算是稍有改善。</p><h3 id="用Pandas读取"><a href="#用Pandas读取" class="headerlink" title="用Pandas读取"></a>用Pandas读取</h3><p>我们来看一下pandas的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marks = pd.read_csv(<span class="string">"./marks.csv"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marks</span><br><span class="line">       name  physics  python  math  english</span><br><span class="line"><span class="number">0</span>    Google      <span class="number">100</span>     <span class="number">100</span>    <span class="number">25</span>       <span class="number">12</span></span><br><span class="line"><span class="number">1</span>  Facebook       <span class="number">45</span>      <span class="number">54</span>    <span class="number">44</span>       <span class="number">88</span></span><br><span class="line"><span class="number">2</span>   Twitter       <span class="number">54</span>      <span class="number">76</span>    <span class="number">13</span>       <span class="number">91</span></span><br><span class="line"><span class="number">3</span>     Yahoo       <span class="number">54</span>     <span class="number">452</span>    <span class="number">26</span>      <span class="number">100</span></span><br></pre></td></tr></table></figure><p>以上结果就是一个DataFrame数据对象。</p><p>还有另外一种方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.read_table(<span class="string">"./marks.csv"</span>, sep=<span class="string">","</span>)</span><br><span class="line">       name  physics  python  math  english</span><br><span class="line"><span class="number">0</span>    Google      <span class="number">100</span>     <span class="number">100</span>    <span class="number">25</span>       <span class="number">12</span></span><br><span class="line"><span class="number">1</span>  Facebook       <span class="number">45</span>      <span class="number">54</span>    <span class="number">44</span>       <span class="number">88</span></span><br><span class="line"><span class="number">2</span>   Twitter       <span class="number">54</span>      <span class="number">76</span>    <span class="number">13</span>       <span class="number">91</span></span><br><span class="line"><span class="number">3</span>     Yahoo       <span class="number">54</span>     <span class="number">452</span>    <span class="number">26</span>      <span class="number">100</span></span><br></pre></td></tr></table></figure><p>如果你有足够的好奇心来研究这个名叫DataFrame的对象，可以这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(marks)</span><br><span class="line">[<span class="string">'T'</span>, <span class="string">'_AXIS_ALIASES'</span>, <span class="string">'_AXIS_NAMES'</span>, <span class="string">'_AXIS_NUMBERS'</span>, <span class="string">'__add__'</span>, <span class="string">'__and__'</span>, <span class="string">'__array__'</span>, <span class="string">'__array_wrap__'</span>, <span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__delitem__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__div__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__floordiv__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattr__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getitem__'</span>, <span class="string">'__getstate__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__len__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__mul__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__neg__'</span>, <span class="string">'__new__'</span>, <span class="string">'__nonzero__'</span>, <span class="string">'__or__'</span>, <span class="string">'__pow__'</span>, <span class="string">'__radd__'</span>, <span class="string">'__rdiv__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__rfloordiv__'</span>, <span class="string">'__rmul__'</span>, <span class="string">'__rpow__'</span>, <span class="string">'__rsub__'</span>, <span class="string">'__rtruediv__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__setitem__'</span>, <span class="string">'__setstate__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__sub__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__truediv__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'__xor__'</span>, <span class="string">'_agg_by_level'</span>, <span class="string">'_align_frame'</span>, <span class="string">'_align_series'</span>, <span class="string">'_apply_broadcast'</span>, <span class="string">'_apply_raw'</span>, <span class="string">'_apply_standard'</span>, <span class="string">'_auto_consolidate'</span>, <span class="string">'_bar_plot'</span>, <span class="string">'_boolean_set'</span>, <span class="string">'_box_item_values'</span>, <span class="string">'_clear_item_cache'</span>, <span class="string">'_combine_const'</span>, <span class="string">'_combine_frame'</span>, <span class="string">'_combine_match_columns'</span>, <span class="string">'_combine_match_index'</span>, <span class="string">'_combine_series'</span>, <span class="string">'_combine_series_infer'</span>, <span class="string">'_compare_frame'</span>, <span class="string">'_consolidate_inplace'</span>, <span class="string">'_constructor'</span>, <span class="string">'_count_level'</span>, <span class="string">'_cov_helper'</span>, <span class="string">'_data'</span>, <span class="string">'_default_stat_axis'</span>, <span class="string">'_expand_axes'</span>, <span class="string">'_from_axes'</span>, <span class="string">'_get_agg_axis'</span>, <span class="string">'_get_axis'</span>, <span class="string">'_get_axis_name'</span>, <span class="string">'_get_axis_number'</span>, <span class="string">'_get_item_cache'</span>, <span class="string">'_get_numeric_data'</span>, <span class="string">'_getitem_array'</span>, <span class="string">'_getitem_multilevel'</span>, <span class="string">'_helper_csvexcel'</span>, <span class="string">'_het_axis'</span>, <span class="string">'_indexed_same'</span>, <span class="string">'_init_dict'</span>, <span class="string">'_init_mgr'</span>, <span class="string">'_init_ndarray'</span>, <span class="string">'_is_mixed_type'</span>, <span class="string">'_item_cache'</span>, <span class="string">'_ix'</span>, <span class="string">'_join_compat'</span>, <span class="string">'_reduce'</span>, <span class="string">'_reindex_axis'</span>, <span class="string">'_reindex_columns'</span>, <span class="string">'_reindex_index'</span>, <span class="string">'_reindex_with_indexers'</span>, <span class="string">'_rename_columns_inplace'</span>, <span class="string">'_rename_index_inplace'</span>, <span class="string">'_sanitize_column'</span>, <span class="string">'_series'</span>, <span class="string">'_set_axis'</span>, <span class="string">'_set_item'</span>, <span class="string">'_set_item_multiple'</span>, <span class="string">'_shift_indexer'</span>, <span class="string">'_slice'</span>, <span class="string">'_unpickle_frame_compat'</span>, <span class="string">'_unpickle_matrix_compat'</span>, <span class="string">'_verbose_info'</span>, <span class="string">'_wrap_array'</span>, <span class="string">'abs'</span>, <span class="string">'add'</span>, <span class="string">'add_prefix'</span>, <span class="string">'add_suffix'</span>, <span class="string">'align'</span>, <span class="string">'append'</span>, <span class="string">'apply'</span>, <span class="string">'applymap'</span>, <span class="string">'as_matrix'</span>, <span class="string">'asfreq'</span>, <span class="string">'astype'</span>, <span class="string">'axes'</span>, <span class="string">'boxplot'</span>, <span class="string">'clip'</span>, <span class="string">'clip_lower'</span>, <span class="string">'clip_upper'</span>, <span class="string">'columns'</span>, <span class="string">'combine'</span>, <span class="string">'combineAdd'</span>, <span class="string">'combineMult'</span>, <span class="string">'combine_first'</span>, <span class="string">'consolidate'</span>, <span class="string">'convert_objects'</span>, <span class="string">'copy'</span>, <span class="string">'corr'</span>, <span class="string">'corrwith'</span>, <span class="string">'count'</span>, <span class="string">'cov'</span>, <span class="string">'cummax'</span>, <span class="string">'cummin'</span>, <span class="string">'cumprod'</span>, <span class="string">'cumsum'</span>, <span class="string">'delevel'</span>, <span class="string">'describe'</span>, <span class="string">'diff'</span>, <span class="string">'div'</span>, <span class="string">'dot'</span>, <span class="string">'drop'</span>, <span class="string">'drop_duplicates'</span>, <span class="string">'dropna'</span>, <span class="string">'dtypes'</span>, <span class="string">'duplicated'</span>, <span class="string">'fillna'</span>, <span class="string">'filter'</span>, <span class="string">'first_valid_index'</span>, <span class="string">'from_csv'</span>, <span class="string">'from_dict'</span>, <span class="string">'from_items'</span>, <span class="string">'from_records'</span>, <span class="string">'get'</span>, <span class="string">'get_dtype_counts'</span>, <span class="string">'get_value'</span>, <span class="string">'groupby'</span>, <span class="string">'head'</span>, <span class="string">'hist'</span>, <span class="string">'icol'</span>, <span class="string">'idxmax'</span>, <span class="string">'idxmin'</span>, <span class="string">'iget_value'</span>, <span class="string">'index'</span>, <span class="string">'info'</span>, <span class="string">'insert'</span>, <span class="string">'irow'</span>, <span class="string">'iteritems'</span>, <span class="string">'iterkv'</span>, <span class="string">'iterrows'</span>, <span class="string">'ix'</span>, <span class="string">'join'</span>, <span class="string">'last_valid_index'</span>, <span class="string">'load'</span>, <span class="string">'lookup'</span>, <span class="string">'mad'</span>, <span class="string">'max'</span>, <span class="string">'mean'</span>, <span class="string">'median'</span>, <span class="string">'merge'</span>, <span class="string">'min'</span>, <span class="string">'mul'</span>, <span class="string">'ndim'</span>, <span class="string">'pivot'</span>, <span class="string">'pivot_table'</span>, <span class="string">'plot'</span>, <span class="string">'pop'</span>, <span class="string">'prod'</span>, <span class="string">'product'</span>, <span class="string">'quantile'</span>, <span class="string">'radd'</span>, <span class="string">'rank'</span>, <span class="string">'rdiv'</span>, <span class="string">'reindex'</span>, <span class="string">'reindex_axis'</span>, <span class="string">'reindex_like'</span>, <span class="string">'rename'</span>, <span class="string">'rename_axis'</span>, <span class="string">'reorder_levels'</span>, <span class="string">'reset_index'</span>, <span class="string">'rmul'</span>, <span class="string">'rsub'</span>, <span class="string">'save'</span>, <span class="string">'select'</span>, <span class="string">'set_index'</span>, <span class="string">'set_value'</span>, <span class="string">'shape'</span>, <span class="string">'shift'</span>, <span class="string">'skew'</span>, <span class="string">'sort'</span>, <span class="string">'sort_index'</span>, <span class="string">'sortlevel'</span>, <span class="string">'stack'</span>, <span class="string">'std'</span>, <span class="string">'sub'</span>, <span class="string">'sum'</span>, <span class="string">'swaplevel'</span>, <span class="string">'tail'</span>, <span class="string">'take'</span>, <span class="string">'to_csv'</span>, <span class="string">'to_dict'</span>, <span class="string">'to_excel'</span>, <span class="string">'to_html'</span>, <span class="string">'to_panel'</span>, <span class="string">'to_records'</span>, <span class="string">'to_sparse'</span>, <span class="string">'to_string'</span>, <span class="string">'to_wide'</span>, <span class="string">'transpose'</span>, <span class="string">'truncate'</span>, <span class="string">'unstack'</span>, <span class="string">'values'</span>, <span class="string">'var'</span>, <span class="string">'xs'</span>]</span><br></pre></td></tr></table></figure><p>一个一个浏览一下，通过名字可以直到那个方法或者属性的大概，然后就可以根据你的喜好和需要，试一试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>marks.index</span><br><span class="line">Int64Index([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=int64)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marks.columns</span><br><span class="line">Index([name, physics, python, math, english], dtype=object)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marks[<span class="string">'name'</span>][<span class="number">1</span>]</span><br><span class="line"><span class="string">'Facebook'</span></span><br></pre></td></tr></table></figure><p>下面几个操作，也是常用到的，并且秉承了python的一贯方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>marks[:<span class="number">1</span>]</span><br><span class="line">     name  physics  python  math  english</span><br><span class="line"><span class="number">0</span>  Google      <span class="number">100</span>     <span class="number">100</span>    <span class="number">25</span>       <span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marks[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">       name  physics  python  math  english</span><br><span class="line"><span class="number">1</span>  Facebook       <span class="number">45</span>      <span class="number">54</span>    <span class="number">44</span>       <span class="number">88</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marks[<span class="string">"physics"</span>]</span><br><span class="line"><span class="number">0</span>    <span class="number">100</span></span><br><span class="line"><span class="number">1</span>     <span class="number">45</span></span><br><span class="line"><span class="number">2</span>     <span class="number">54</span></span><br><span class="line"><span class="number">3</span>     <span class="number">54</span></span><br><span class="line">Name: physics</span><br></pre></td></tr></table></figure><p>可以说，当你已经掌握了通过dir()和help()查看对象的方法和属性时，就已经掌握了pandas的用法，其实何止pandas，其它对象都是如此。</p><h1 id="一个pandas实例"><a href="#一个pandas实例" class="headerlink" title="一个pandas实例"></a>一个pandas实例</h1><p>上周一个朋友提出了一个简单的需求：对于百万条数量级的csv文件做一个简单的数据分析，在此非常感谢他让我有机会接触到了pandas，话不多说，上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> datetime, csv</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(rows, key, count)</span>:</span></span><br><span class="line">    data_max, data_min = rows[key].max(), rows[key].min()</span><br><span class="line">    data_avg = (rows[key].sum() / float(count)) <span class="keyword">if</span> count != <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> data_max, data_min, data_avg</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    starttime = datetime.datetime.now()</span><br><span class="line">    data = pd.read_csv(<span class="string">"new_colla.csv"</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'degree_year.csv'</span>,<span class="string">'ab+'</span>) <span class="keyword">as</span> ft:</span><br><span class="line">        writer = csv.writer(ft)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                rows = data[(data.degree1==i) &amp; (data.degree2==j)]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Get valuable data</span></span><br><span class="line">                age, count = (i, j), rows.colla_time.count()</span><br><span class="line">                <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                colla_time_max, colla_time_min, colla_time_avg = get_data(rows, <span class="string">"colla_time"</span>, count)</span><br><span class="line">                coarticle_num_max, coarticle_num_min, coarticle_num_avg = get_data(rows, <span class="string">"coarticle_num"</span>, count)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Write file</span></span><br><span class="line">                write_obj = [age, colla_time_max, colla_time_min, colla_time_avg, \</span><br><span class="line">                            coarticle_num_max, coarticle_num_min, coarticle_num_avg, count]</span><br><span class="line">                writer.writerow(write_obj)</span><br><span class="line"></span><br><span class="line">    endtime = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">print</span> (endtime - starttime).seconds</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算简介及基本技巧</title>
      <link href="/2016/07/06/bit-operation-skills/"/>
      <url>/2016/07/06/bit-operation-skills/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是位运算"><a href="#什么是位运算" class="headerlink" title="什么是位运算"></a>什么是位运算</h1><p>程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算说穿了，就是直接对整数在内存中的二进制位进行操作。比如，and运算本来是一个逻辑运算符，但整数与整数之间也可以进行and运算。举个例子，6的二进制是110，11的二进制是1011，那么6 and 11的结果就是2，它是二进制对应位进行逻辑运算的结果（0表示False，1表示True，空位都当0处理）：</p><pre><code>110 AND 1011 --&gt; 0010(b) --&gt; 2(d)</code></pre><p>由于位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。当然有人会说，这个快了有什么用，计算6 and 11没有什么实际意义啊。本文就将告诉你，位运算到底可以干什么，有些什么经典应用，以及如何用位运算优化你的程序。</p><h1 id="位运算基础"><a href="#位运算基础" class="headerlink" title="位运算基础"></a>位运算基础</h1><p>基本的位操作符有与、或、异或、取反、左移、右移这6种，它们的运算规则如下所示：</p><table><thead><tr><th align="left">符号</th><th align="left">描述</th><th align="left">运算规则</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">与</td><td align="left">两个位都为1时，结果才为1</td></tr><tr><td align="left">丨</td><td align="left">或</td><td align="left">两个位都为0时，结果才为0</td></tr><tr><td align="left">^</td><td align="left">异或</td><td align="left">两个位相同为0，相异为1</td></tr><tr><td align="left">~</td><td align="left">取反</td><td align="left">0变1，1变0</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移</td><td align="left">各二进位全部左移若干位，高位丢弃，低位补0</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移</td><td align="left">各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</td></tr></tbody></table><p>需要注意以下几点：</p><ul><li><p>这6种操作符，只有~取反是单目操作符，其它5种都是双目操作符；</p></li><li><p>位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错；</p></li><li><p>移位操作都是采取算术移位操作，算术移位是相对于逻辑移位，它们在左移操作中都一样，低位补0即可，但在<strong>右移中逻辑移位的高位补0而算术移位的高位是补符号位</strong>。如下面代码会输出-4和3；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b &#x3D; -15, 15</span><br><span class="line">puts a &gt;&gt; 2</span><br><span class="line">puts b &gt;&gt; 2</span><br></pre></td></tr></table></figure><p>因为15=0000 1111(二进制)，右移二位，最高位由符号位填充将得到0000 0011即3。-15 = 1111 0001(二进制)，右移二位，最高位由符号位填充将得到1111 1100即-4。</p></li><li><p>位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。比如要得到像1，3，5，9这些2^i+1的数字。写成a = 1 &lt;&lt; i + 1是不对的，程序会先执行i + 1，再执行左移操作。应该写成a = (1 &lt;&lt; i) + 1; </p></li><li><p>另外位操作还有一些复合操作符，如&amp;=、|=、 ^=、&lt;&lt;=、&gt;&gt;=。</p></li></ul><h1 id="常用位操作小技巧"><a href="#常用位操作小技巧" class="headerlink" title="常用位操作小技巧"></a>常用位操作小技巧</h1><p>下面对位操作的一些常见应用作个总结，有判断奇偶、交换两数、变换符号及求绝对值。这些小技巧应用易记，应当熟练掌握。</p><h2 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h2><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a &amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。</p><p>下面程序输出0到100之间的所有奇数。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>.times <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">  puts i <span class="keyword">if</span> i &amp; <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="交换两数"><a href="#交换两数" class="headerlink" title="交换两数"></a>交换两数</h2><p>一般交换函数的写法是：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(a, b)</span></span></span><br><span class="line">  <span class="keyword">if</span> a != b</span><br><span class="line">    c = a</span><br><span class="line">    a = b</span><br><span class="line">    b = c</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>注：ruby中这么写简直就是蠢，a, b = b, a即可，这里方便举例。</p><p>可以用位操作来实现交换两数而不用第三方变量：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(a, b)</span></span></span><br><span class="line">  <span class="keyword">if</span> a != b</span><br><span class="line">    a ^= b</span><br><span class="line">    b ^= a</span><br><span class="line">    a ^= b</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>可以这样理解：</p><ol><li>a ^= b 即a = (a ^ b);</li><li>b ^= a 即b = b ^ (a ^ b)，由于^运算满足交换律，b ^ (a ^ b)=b ^ b ^ a。由于一个数和自己异或的结果为0并且任何数与0异或都会不变的，所以此时b被赋上了a的值;</li><li>a ^= b 就是a = a ^ b，由于前面二步可知a = (a ^ b)，b = a，所以a = a ^ b即a = (a ^ b) ^ a。故a会被赋上b的值。</li></ol><p>再来个实例说明下以加深印象。a = 13, b = 6:<br>a的二进制为 13 = 8 + 4 + 1 = 1101(二进制)<br>b的二进制为 6 = 4 + 2 = 110(二进制)</p><ol><li>a ^= b  a = 1101 ^ 110 = 1011;</li><li>b ^= a  b = 110 ^ 1011 = 1101; 即b == 13</li><li>a ^= b  a = 1011 ^ 1101 = 110; 即a == 6</li></ol><h2 id="变换符号"><a href="#变换符号" class="headerlink" title="变换符号"></a>变换符号</h2><p>变换符号就是正数变成负数，负数变成正数。<br>如对于-11和11，可以通过下面的变换方法将-11变成11:</p><pre><code>1111 0101(二进制)取反-&gt; 0000 1010(二进制) 加1-&gt; 0000 1011(二进制)</code></pre><p>同样可以这样的将11变成-11</p><pre><code>0000 1011(二进制)取反-&gt; 1111 0100(二进制)加1-&gt; 1111 0101(二进制)</code></pre><p>因此变换符号只需要取反后加1即可。完整代码如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sign_reversal</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">return</span> ~n + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="求绝对值"><a href="#求绝对值" class="headerlink" title="求绝对值"></a>求绝对值</h2><p>位操作也可以用来求绝对值，对于负数可以通过对其取反后加1来得到正数。对-6可以这样：</p><pre><code>1111 1010(二进制)取反-&gt;0000 0101(二进制)加1-&gt; 0000 0110(二进制)</code></pre><p>来得到6。</p><p>因此先移位来取符号位，i = a &gt;&gt; 31;要注意如果a为正数，i等于0，为负数，i等于-1。然后对i进行判断——如果i等于0，直接返回；否之，返回~a + 1。完整代码如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(n)</span></span></span><br><span class="line">  i = n &gt;&gt; <span class="number">31</span></span><br><span class="line">  <span class="keyword">return</span> i == <span class="number">0</span> ? n : (~n + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在再分析下。对于任何数，与0异或都会保持不变，与-1即0xFFFFFFFF异或就相当于取反。因此，n与i异或后再减i（因为i为0或-1，所以减i即是要么加0要么加1）也可以得到绝对值。所以可以对上面代码优化下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(n)</span></span></span><br><span class="line">  i = a &gt;&gt; <span class="number">31</span></span><br><span class="line">  <span class="keyword">return</span> ((a ^ i) - i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>注意这种方法没用任何判断表达式，而且有些笔面试题就要求这样做，因此建议读者记住该方法。</p><h1 id="两个位运算的实例"><a href="#两个位运算的实例" class="headerlink" title="两个位运算的实例"></a>两个位运算的实例</h1><h2 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a>Single Number</h2><h3 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h3><p>一个数组中除了一个数字出现过一次外，其余的数字都出现了两次，找出那个只出现一次的数字。</p><p>注意点：</p><ul><li>算法时间杂度要求为O(n)</li><li>空间复杂度为O(1)</li></ul><p>例子:</p><p>输入: nums = [1, 2, 3, 4, 3, 2, 1]<br>输出: 4</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>非常常见的一道算法题，将所有数字进行异或操作即可。对于异或操作明确以下三点：</p><ul><li>一个整数与自己异或的结果是0</li><li>一个整数与0异或的结果是自己</li><li>异或操作满足交换律，即a^b=b^a</li></ul><p>所以对所有数字进行异或操作后剩下的就是那个只出现一次的数字。</p><h3 id="AC源码"><a href="#AC源码" class="headerlink" title="AC源码"></a>AC源码</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_number</span><span class="params">(nums)</span></span></span><br><span class="line">  res = <span class="number">0</span></span><br><span class="line">  nums.each <span class="keyword">do</span> <span class="params">|num|</span></span><br><span class="line">    res ^= num</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  res</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Power-Of-Two"><a href="#Power-Of-Two" class="headerlink" title="Power Of Two"></a>Power Of Two</h2><h3 id="原题-1"><a href="#原题-1" class="headerlink" title="原题"></a>原题</h3><p>这道题让我们判断一个数是否为2的次方数，而且要求时间和空间复杂度都为常数。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>比较下x - 1和x的关系试试？以x=4为例。</p><pre><code>0100 ==&gt; 40011 ==&gt; 3</code></pre><p>两个数进行按位与就为0了！如果不是2的整数幂则无上述关系，反证法可证之。</p><h3 id="AC源码-1"><a href="#AC源码-1" class="headerlink" title="AC源码"></a>AC源码</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_power_of_two</span><span class="params">(n)</span></span></span><br><span class="line"> <span class="keyword">return</span> (n &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> (n &amp; n-<span class="number">1</span>))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python函数参数默认值陷阱及根本原因</title>
      <link href="/2016/06/30/python-function-default-params/"/>
      <url>/2016/06/30/python-function-default-params/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我们都知道，在使用Python调用函数时，添加默认参数可以简化函数的调用。可虽然默认参数很有用，但使用不当，也会掉坑里。</p><h1 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h1><p>要了解这个问题的原因我们先需要一个准备知识，那就是：Python变量到底是如何实现的？Python变量区别于其他编程语言的申明&amp;赋值方式，采用的是创建&amp;指向的类似于指针的方式实现的。即Python中的变量实际上是对值或者对象的一个指针（简单的说他们是值得一个名字）。我们来看一个例子。</p><pre><code>p = 1p = p + 1</code></pre><p>对于传统语言，上面这段代码的执行方式将会是，先在内存中申明一个p的变量，然后将1存入变量p所在内存。执行加法操作的时候得到2的结果，将2这个数值再次存入到p所在内存地址中。<strong>可见整个执行过程中，变化的是变量p所在内存地址上的值</strong>；</p><p>上面这段代码中，Python实际上是现在执行内存中创建了一个1的对象，并将p指向了它。在执行加法操作的时候，实际上通过加法操作得到了一个2的新对象，并将p指向这个新的对象。<strong>可见整个执行过程中，变化的是p指向的内存地址</strong>。</p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>当你使用“可变”的对象作为函数中作为默认参数时会往往引起问题。因为在这种情况下参数可以在不创建新对象的情况下进行修改，例如 list dict。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(list=[])</span>:</span></span><br><span class="line"><span class="meta">... </span>    list.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> list</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>function()</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>function()</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>function()</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>像你所看到的那样，list 变得越来越长。如果你仔细地查看这个 list。你会发现 list 一直是同一个对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(function())</span><br><span class="line"><span class="number">140586497456392</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(function())</span><br><span class="line"><span class="number">140586497456392</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(function())</span><br><span class="line"><span class="number">140586497456392</span></span><br></pre></td></tr></table></figure><p>我之后使用ruby来验证了一下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">2.2.1 :001 &gt;</span> <span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(list=[])</span></span></span><br><span class="line"><span class="meta">2.2.1 :002?&gt;</span>   list &lt;&lt; <span class="number">1</span></span><br><span class="line"><span class="meta">2.2.1 :003?&gt;</span>   return list</span><br><span class="line"><span class="meta">2.2.1 :004?&gt;</span>   end</span><br><span class="line"> =&gt; <span class="symbol">:function</span> </span><br><span class="line"><span class="meta">2.2.1 :005 &gt;</span> function</span><br><span class="line"> =&gt; [<span class="number">1</span>] </span><br><span class="line"><span class="meta">2.2.1 :006 &gt;</span> function</span><br><span class="line"> =&gt; [<span class="number">1</span>] </span><br><span class="line"><span class="meta">2.2.1 :007 &gt;</span> function</span><br><span class="line"> =&gt; [<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>查看了一下每次调用<code>function</code>创建的对象的id，如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">2.2.1 :008 &gt;</span> function.object_id</span><br><span class="line"> =&gt; <span class="number">70229933774780</span> </span><br><span class="line"><span class="meta">2.2.1 :009 &gt;</span> function.object_id</span><br><span class="line"> =&gt; <span class="number">70229933792240</span> </span><br><span class="line"><span class="meta">2.2.1 :010 &gt;</span> function.object_id</span><br><span class="line"> =&gt; <span class="number">70229933806600</span></span><br></pre></td></tr></table></figure><p>可以很清楚的看出，ruby中不会存在这个问题。</p><h1 id="为什么会发生这种情况？"><a href="#为什么会发生这种情况？" class="headerlink" title="为什么会发生这种情况？"></a>为什么会发生这种情况？</h1><p><strong>当且仅当</strong>默认参数所在的“def”语句执行的时候，默认参数才会进行计算。请看<a href="http://docs.python.org/ref/function.html" target="_blank" rel="noopener">文档</a>描述的相关部分。</p><p>可见如果参数默认值是在函数编译<code>compile</code>阶段就已经被确定。之后所有的函数调用时，如果参数不显示的给予赋值，那么所谓的参数默认值不过是一个指向那个在<code>compile</code>阶段就已经存在的对象的指针。如果调用函数时，没有显示指定传入参数值得话。那么所有这种情况下的该参数都会作为编译时创建的那个对象的一种别名存在。如果参数的默认值是一个不可变(<code>Imuttable</code>)数值，那么在函数体内如果修改了该参数，那么参数就会重新指向另一个新的不可变值。而如果参数默认值是和本文最开始的举例一样，是一个可变对象(<code>Muttable</code>)，那么情况就比较糟糕了。所有函数体内对于该参数的修改，实际上都是对<code>compile</code>阶段就已经确定的那个对象的修改。</p><h1 id="如何避免？"><a href="#如何避免？" class="headerlink" title="如何避免？"></a>如何避免？</h1><p>当然最好的方式是不要使用可变对象作为函数默认值。如果非要这么用的话，下面是一种解决方案。还是以文章开头的需求为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(list=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> list <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        list = []</span><br><span class="line">    list.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h1 id="为什么Python要这么设计？"><a href="#为什么Python要这么设计？" class="headerlink" title="为什么Python要这么设计？"></a>为什么Python要这么设计？</h1><p>这个问题的答案在 <a href="http://stackoverflow.com/questions/1132941/least-astonishment-in-python-the-mutable-default-argument" target="_blank" rel="noopener">StackOverflow</a> 上可以找到答案。在这个回答中，答题者认为出于Python编译器的实现方式考虑，函数是一个内部一级对象。而参数默认值是这个对象的属性。在其他任何语言中，对象属性都是在对象创建时做绑定的。因此，函数参数默认值在编译时绑定也就不足为奇了。 然而，也有其他很多一些回答者不买账，认为即使是<code>first-class object</code>也可以使用<code>closure</code>的方式在执行时绑定。</p><p>甚至还有反驳者抛开实现逻辑，单纯从设计角度认为：只要是违背程序猿基本思考逻辑的行为，都是设计缺陷！下面是他们的一些论调： &gt; Sorry, but anything considered “The biggest WTF in Python” is most definitely a design flaw. This is a source of bugs for everyone at some point, because no one expects that behavior at first - which means it should not have been designed that way to begin with.</p><p>好吧，这么看来，如果没有来自于Python作者的亲自陈清，这个问题的答案就一直会是一个谜了。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>求小于n的质数的个数——埃拉托斯特尼筛法</title>
      <link href="/2016/06/29/eratosthenes-algorithms/"/>
      <url>/2016/06/29/eratosthenes-algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个非负数n，求小于n的质数的个数。</p><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>在本题中，我们采用<a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="noopener">埃拉托斯特尼筛法</a>，详细列出算法如下：</p><ol><li>从2开始遍历到根号n；</li><li>先找到第一个质数2，然后将其所有的倍数全部标记出来；</li><li>然后到下一个质数3，标记其所有倍数，依次类推，直到根号n；</li><li>此时数组中未被标记的数字就是质数。</li></ol><p>效果图如下：</p><p><img src="/images/Sieve_of_Eratosthenes_animation.gif" alt="Sieve_of_Eratosthenes_animation"></p><p>下面给出ruby和python代码实现：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">!<span class="comment">#/usr/bin/ruby</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_primes</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> n &lt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  mark = [<span class="literal">true</span>] * n</span><br><span class="line">  mark[<span class="number">0</span>], mark[<span class="number">1</span>] = <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>.upto(Math.sqrt(n)) <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">    <span class="keyword">if</span> mark[i]</span><br><span class="line">      p = i ** <span class="number">2</span></span><br><span class="line">      <span class="keyword">while</span> p &lt; n</span><br><span class="line">        mark[p] = <span class="literal">false</span></span><br><span class="line">        p += x</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  mark.count(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">!<span class="comment">#/usr/bin/python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_odd_iter</span><span class="params">()</span>:</span></span><br><span class="line">    n=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = n + <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_not_divisible</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x : x % n &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    it = _odd_iter()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n=next(it)</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        it = filter(_not_divisible(n), it)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> primes():</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1000</span>:</span><br><span class="line">        print(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vim中两个常用的块操作命令</title>
      <link href="/2016/05/29/vim-block-operator/"/>
      <url>/2016/05/29/vim-block-operator/</url>
      
        <content type="html"><![CDATA[<p>本文介绍Vim中两种常用的块操作命令。</p><h1 id="块操作"><a href="#块操作" class="headerlink" title="块操作"></a>块操作</h1><p>块操作有一个很典型的使用场景：批量给若干行添加备注。</p><blockquote><p>典型的块操作：<br>0 <Ctrl-v> hjkl I– [ESC]</p></blockquote><p>意思是：</p><ul><li>0 → 到行头</li><li><Ctrl-v> → 开始块操作</li><li>hjkl → 移动光标</li><li>I– → I是插入，插入“–”</li><li>按[ESC]键来为每一行生效</li></ul><h1 id="可视化选择"><a href="#可视化选择" class="headerlink" title="可视化选择"></a>可视化选择</h1><p>可视化选择也是一个常见的操作，一个常见的使用场景是批量给若干行添加或减少缩进。</p><blockquote><p>v hjkl &gt;或&lt;或=</p></blockquote><p>意思是：</p><ul><li>v → 切换到visual模式</li><li>hjkl → 移动光标</li><li>&lt; 或 &gt; → 左右缩进</li><li>= → 自动给缩进 （这个功能相当强大，我太喜欢了）</li></ul><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>学习Vim就像学钢琴一样，一旦学会，受益无穷。笔者也没有完全掌握Vim的所有命令，从本人的使用情况来讲，建议你每天都学习1到2个新命令，久而久之，相信你会熟练掌握。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浅析Dynamic Programming动态规划问题</title>
      <link href="/2016/05/05/dp-intro/"/>
      <url>/2016/05/05/dp-intro/</url>
      
        <content type="html"><![CDATA[<p>对于动态规划，每个刚接触的人都需要一段时间来理解，特别是第一次接触的时候总是想不通为什么这种方法可行，这篇文章就是为了帮助大家理解动态规划，并通过讲解基本的01背包问题来引导读者如何去思考动态规划。 </p><h1 id="初识动态规划"><a href="#初识动态规划" class="headerlink" title="初识动态规划"></a>初识动态规划</h1><p>经典的01背包问题是这样的：</p><p>有一个包和n个物品，包的容量为m，每个物品都有各自的体积和价值，问当从这n个物品中选择多个物品放在包里而物品体积总数不超过包的容量m时，能够得到的最大价值是多少？[对于每个物品不可以取多次，最多只能取一次，之所以叫做01背包，0表示不取，1表示取]</p><p>为了用一种生动又更形象的方式来讲解此题，我把此题用另一种方式来描述，如下：</p><p>有一个国家，所有的国民都非常老实憨厚，某天他们在自己的国家发现了十座金矿，并且这十座金矿在地图上排成一条直线，国王知道这个消息后非常高兴，他希望能够把这些金子都挖出来造福国民，首先他把这些金矿按照在地图上的位置从西至东进行编号，依次为0、1、2、3、4、5、6、7、8、9，然后他命令他的手下去对每一座金矿进行勘测，以便知道挖取每一座金矿需要多少人力以及每座金矿能够挖出多少金子，然后动员国民都来挖金子。</p><ul><li>题目补充1：挖每一座金矿需要的人数是固定的，多一个人少一个人都不行。国王知道每个金矿各需要多少人手，金矿i需要的人数为peopleNeeded。</li><li>题目补充2：每一座金矿所挖出来的金子数是固定的，当第i座金矿有peopleNeeded人去挖的话，就一定能恰好挖出gold个金子。否则一个金子都挖不出来。</li><li>题目补充3：开采一座金矿的人完成开采工作后，他们不会再次去开采其它金矿，因此一个人最多只能使用一次。</li><li>题目补充4：国王在全国范围内仅招募到了10000名愿意为了国家去挖金子的人，因此这些人可能不够把所有的金子都挖出来，但是国王希望挖到的金子越多越好。</li><li>题目补充5：这个国家的每一个人都很老实（包括国王），不会私吞任何金子，也不会弄虚作假，不会说谎话。</li><li>题目补充6：有很多人拿到这个题后的第一反应就是对每一个金矿求出平均每个人能挖出多少金子，然后从高到低进行选择，这里要强调这种方法是错的，如果你也是这样想的，请考虑背包模型，当有一个背包的容量为10，共有3个物品，体积分别是3、3、5，价值分别是6、6、9，那么你的方法取到的是前两个物品，总价值是12，但明显最大值是后两个物品组成的15。</li><li>题目补充7：我们只需要知道最多可以挖出多少金子即可，而不用关心哪些金矿挖哪些金矿不挖。</li></ul><p>那么，国王究竟如何知道在只有10000个人的情况下最多能挖出多少金子呢？国王是如何思考这个问题的呢？</p><p>国王首先来到了第9个金矿的所在地（注意，第9个就是最后一个，因为是从0开始编号的，最西边的那个金矿是第0个），他的臣子告诉他，如果要挖取第9个金矿的话就需要1500个人，并且第9个金矿可以挖出8888个金子。听到这里国王哈哈大笑起来，因为原先他以为要知道十个金矿在仅有10000个人的情况下最多能挖出多少金子是一件很难思考的问题，但是，就在刚才听完他的臣子所说的那句话时，国王已经知道总共最多能挖出多少金子了，国王是如何在不了解其它金矿的情况下知道最多能挖出多少金子的呢？他的臣子们也不知道这个谜，因此他的臣子们就问他了：“最聪明的国王陛下，我们都没有告诉您其它金矿的情况，您是如何知道最终答案的呢？”</p><p>得意的国王笑了笑，然后把他最得意的“左、右手”叫到跟前，说到：“我并不需要考虑最终要挖哪些金矿才能得到最多的金子，我只需要考虑我面前的这座金矿就可以了，对于我面前的这座金矿不外乎仅有两种选择，要么挖，要么不挖，对吧？”</p><p>“当然，当然”大臣们回答到。</p><p>国王继续说道：“如果我挖取第9座金矿的话那么我现在就能获得8888个金子，而我将用去1500个人，那么我还剩下8500个人。我亲爱的左部下，如果你告诉我当我把所有剩下的8500个人和所有剩下的其它金矿都交给你去开采你最多能给我挖出多少金子的话，那么我不就知道了在第9个金矿一定开采的情况下所能得到的最大金币数吗？”</p><p>国王的左部下听后回答道：“国王陛下，您的意思是如果我能用8500个人在其它金矿最多开采出x个金币的话，那您一共就能够获得 x + 8888个金子，对吗？”</p><p>“是啊，是啊……如果第9座金矿一定开采的话……”大臣们点头说到。</p><p>国王笑着继续对着他的右部下说到：“亲爱的右部下，也许我并不打算开采这第9座金矿，那么我依然拥有10000个人，如果我把这10000个人和剩下的金矿都给你的话，你最多能给我挖出多少个金子呢？”</p><p>国王的右部下聪明地说道：“尊敬的国王陛下，我明白您的意思了，如果我回答最多能购开采出y个金币的话，那您就可以在y和x+8888之间选择一个较大者，而这个较大者就是最终我们能获得的最大金币数，您看我这样理解对吗？”</p><p>国王笑得更灿烂了，问他的左部下：“那么亲爱的左部下，我给你8500个人和其余金矿的话你能告诉我最多能挖出多少金子吗？”</p><p>“请您放心，这个问题难不倒我”。左部下向国王打包票说到。</p><p>国王高兴地继续问他的右部下：“那右部下你呢，如果我给你10000个人和其余金矿的话你能告诉我最多能挖出多少金子吗？”</p><p>“当然能了！交给我吧！”右部下同左部下一样自信地回答道。</p><p>“那就拜托给你们两位了，现在我要回到我那舒适的王宫里去享受了，我期待着你们的答复。”国王说完就开始动身回去等消息了，他是多么地相信他的两个大臣能够给他一个准确的答复，因为国王其实知道他的两位大臣要比他聪明得多。</p><p>故事发展到这里，你是否在想国王的这两个大臣又是如何找到让国王满意的答案的呢？他们为什么能够如此自信呢？事实上他们的确比国王要聪明一些，因为他们从国王的身上学到了一点，就是这一点让他们充满了自信。</p><p>国王走后，国王的左、右部下来到了第8座金矿，早已在那里等待他们的金矿勘测兵向两位大臣报道：“聪明的两位大臣，您们好，第8座金矿需要1000个人才能开采，可以获得7000个金子”。</p><p>因为国王仅给他的左部下8500个人，所以国王的左部下叫来了两个人，对着其中一个人问到：“如果我给你7500个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？”</p><p>然后国王的左部下继续问另一个人：“如果我给你8500个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？”</p><p>国王的左部下在心里想着：“如果他们俩都能回答我的问题的话，那国王交给我的问题不就解决了吗？哈哈哈！”</p><p>因为国王给了他的右部下10000个人，所以国王的右部下同样也叫来了两个人，对着其中一个人问：“如果我给你9000个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？”</p><p>然后国王的右部下继续问他叫来的另一个人：“如果我给你10000个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？”</p><p>此时，国王的右部下同左部下一样，他们都在为自己如此聪明而感到满足。</p><p>当然，这四个被叫来的人同样自信地回答没有问题，因为他们同样地从这两个大臣身上学到了相同的一点，而两位自认为自己一样很聪明的大臣得意地笑着回到了他们的府邸，等着别人回答他们提出来的问题，现在你知道了这两个大臣是如何解决国王交待给他们的问题了吗？</p><p>那么你认为被大臣叫去的那四个人又是怎么完成大臣交给他们的问题的呢？答案当然是他们找到了另外八个人！</p><p>没用多少功夫，这个问题已经在全国传开了，更多人的人找到了更更多的人来解决这个问题，而有些人却不需要去另外找两个人帮他，哪些人不需要别人的帮助就可以回答他们的问题呢？</p><p>很明显，当被问到给你z个人和仅有第0座金矿时最多能挖出多少金子时，就不需要别人的帮助，因为你知道，如果z大于等于挖取第0座金矿所需要的人数的话，那么挖出来的最多金子数就是第0座金矿能够挖出来的金子数，如果这z个人不够开采第0座金矿，那么能挖出来的最多金子数就是0，因为这唯一的金矿不够人力去开采。让我们为这些不需要别人的帮助就可以准确地得出答案的人们鼓掌吧，这就是传说中的底层劳动人民！</p><p>故事讲到这里先暂停一下，我们现在重新来分析一下这个故事，让我们对动态规划有个理性认识。</p><p>子问题：<br>国王需要根据两个大臣的答案以及第9座金矿的信息才能判断出最多能够开采出多少金子。为了解决自己面临的问题，他需要给别人制造另外两个问题，这两个问题就是子问题。</p><h2 id="思考动态规划的第一点—最优子结构"><a href="#思考动态规划的第一点—最优子结构" class="headerlink" title="思考动态规划的第一点—最优子结构"></a>思考动态规划的第一点—最优子结构</h2><p>国王相信，只要他的两个大臣能够回答出正确的答案（对于考虑能够开采出的金子数，最多的也就是最优的同时也就是正确的），再加上他的聪明的判断就一定能得到最终的正确答案。我们把这种子问题最优时母问题通过优化选择后一定最优的情况叫做“最优子结构”。</p><h2 id="思考动态规划的第二点—子问题重叠"><a href="#思考动态规划的第二点—子问题重叠" class="headerlink" title="思考动态规划的第二点—子问题重叠"></a>思考动态规划的第二点—子问题重叠</h2><p>实际上国王也好，大臣也好，所有人面对的都是同样的问题，即给你一定数量的人，给你一定数量的金矿，让你求出能够开采出来的最多金子数。我们把这种母问题与子问题本质上是同一个问题的情况称为“子问题重叠”。然而问题中出现的不同点往往就是被子问题之间传递的参数，比如这里的人数和金矿数。</p><h2 id="思考动态规划的第三点—边界"><a href="#思考动态规划的第三点—边界" class="headerlink" title="思考动态规划的第三点—边界"></a>思考动态规划的第三点—边界</h2><p>想想如果不存在前面我们提到的那些底层劳动者的话这个问题能解决吗？永远都不可能！我们把这种子问题在一定时候就不再需要提出子子问题的情况叫做边界，没有边界就会出现死循环。</p><h2 id="思考动态规划的第四点—子问题独立"><a href="#思考动态规划的第四点—子问题独立" class="headerlink" title="思考动态规划的第四点—子问题独立"></a>思考动态规划的第四点—子问题独立</h2><p>要知道，当国王的两个大臣在思考他们自己的问题时他们是不会关心对方是如何计算怎样开采金矿的，因为他们知道，国王只会选择两个人中的一个作为最后方案，另一个人的方案并不会得到实施，因此一个人的决定对另一个人的决定是没有影响的。我们把这种一个母问题在对子问题选择时，当前被选择的子问题两两互不影响的情况叫做“子问题独立”。</p><hr><p>这就是动态规划，具有“最优子结构”、“子问题重叠”、“边界”和“子问题独立”，当你发现你正在思考的问题具备这四个性质的话，那么恭喜你，你基本上已经找到了动态规划的方法。</p><p>有了上面的这几点，我们就可以写出动态规划的转移方程式，现在我们来写出对应这个问题的方程式，如果用gold[mineNum]表示第mineNum个金矿能够挖出的金子数，用peopleNeeded[mineNum]表示挖第mineNum个金矿需要的人数，用函数f(people,mineNum)表示当有people个人和编号为0、1、2、3、……、mineNum的金矿时能够得到的最大金子数的话，f(people,mineNum)等于什么呢？或者说f(people,mineNum)的转移方程是怎样的呢？</p><p>答案是：</p><ul><li>当mineNum = 0且people &gt;= peopleNeeded[mineNum]时 f(people,mineNum) = gold[mineNum]</li><li>当mineNum = 0且people &lt; peopleNeeded[mineNum]时 f(people,mineNum) = 0</li><li>当mineNum != 0时 f(people,mineNum) = f(people-peopleNeeded[mineNum], mineNum-1) + gold[mineNum]与f(people, mineNum-1)中的较大者，前两个式子对应动态规划的“边界”，后一个式子对应动态规划的“最优子结构”</li></ul><p>请读者弄明白后再继续往下看。</p><h1 id="动态规划的优点"><a href="#动态规划的优点" class="headerlink" title="动态规划的优点"></a>动态规划的优点</h1><p>现在我假设读者你已经搞清楚了为什么动态规划是正确的方法，但是我们为什么需要使用动态规划呢？请先继续欣赏这个故事：</p><p>国王得知他的两个手下使用了和他相同的方法去解决交代给他们的问题后，不但没有认为他的两个大臣在偷懒，反而很高兴，因为他知道，他的大臣必然会找更多的人一起解决这个问题，而更多的人会找更更多的人，这样他这个聪明的方法就会在不经意间流传开来，而全国人民都会知道这个聪明的方法是他们伟大的国王想出来的，你说国王能不高兴吗？</p><p>但是国王也有一些担忧，因为他实在不知道这个“工程”要动用到多少人来完成，如果帮助他解决这个问题的人太多的话那么就太劳民伤财了。“会不会影响到今年的收成呢？”国王在心里想着这个问题，于是他请来了整个国家里唯一的两个数学天才，一个叫做小天，另一个叫做小才。</p><p>国王问小天：“小天啊，我发觉这个问题有点严重，我知道其实这可以简单的看成一个组合问题，也就是从十个金矿中选取若干个金矿进行开采，看看哪种组合得到的金子最多，也许用组合方法会更好一些。你能告诉我一共有多少种组合情况吗？”</p><p>“国王陛下，如果用组合方法的话一共要考虑2的10次方种情况，也就是1024种情况。”小天思考了一会回答到。</p><p>“嗯……，如果每一种情况我交给一个人去计算能得到的金子数的话，那我也要1024个人，其实还是挺多的。”国王好像再次感觉到了自己的方法是正确的。</p><p>国王心理期待着小才能够给它一个更好的答案，问到：“小才啊，那么你能告诉我用我的那个方法总共需要多少人吗？其实，我也计算过，好像需要的人数是1+2+4+8+16+32+64+……，毕竟每一个人的确都需要找另外两个人来帮助他们……”</p><p>不辜负国王的期待，小才微笑着说到：“亲爱的国王陛下，其实我们并不需要那么多人，因为有很多问题其实是相同的，而我们只需要为每一个不同的问题使用一个人力便可。”</p><p>国王高兴的问到：“此话如何讲？”</p><p>“打个比方，如果有一个人需要知道1000个人和3个金矿可以开采出多少金子，同时另一个人也需要知道1000个人和3个金矿可以开采出多少金子的话，那么他们可以去询问相同的一个人，而不用各自找不同的人浪费人力了。”</p><p>国王思考着说到：“嗯，很有道理，如果问题是一样的话那么就不需要去询问两个不同的人了，也就是说一个不同的问题仅需要一个人力，那么一共有多少个不同的问题呢？”   </p><p>“因为每个问题的人数可以从0取到10000，而金矿数可以从0取到10，所以最多大约有10000 * 10 等于100000个不同的问题。” 小才一边算着一边回答。</p><p>“什么？十万个问题？十万个人力？”国王有点失望。</p><p>“请国王放心，事实上我们需要的人力远远小于这个数的，因为不是每一个问题都会遇到，也许我们仅需要一、两百个人力就可以解决这个问题了，这主要和各个金矿所需要的人数有关。” 小才立刻回答到。</p><p>故事的最后，自然是国王再一次向他的臣民们证明了他是这个国家里最聪明的人，现在我们通过故事的第二部分来考虑动态规划的另外两个思考点。</p><h2 id="思考动态规划的第五点—做备忘录"><a href="#思考动态规划的第五点—做备忘录" class="headerlink" title="思考动态规划的第五点—做备忘录"></a>思考动态规划的第五点—做备忘录</h2><p>正如上面所说的一样，当我们遇到相同的问题时，我们可以问同一个人。讲的通俗一点就是，我们可以把问题的解放在一个变量中，如果再次遇到这个问题就直接从变量中获得答案，因此每一个问题仅会计算一遍，如果不做备忘的话，动态规划就没有任何优势可言了。</p><h2 id="思考动态规划的第六点—时间分析"><a href="#思考动态规划的第六点—时间分析" class="headerlink" title="思考动态规划的第六点—时间分析"></a>思考动态规划的第六点—时间分析</h2><p>正如上面所说，如果我们用穷举的方法，至少需要2^n个常数时间，因为总共有2^n种情况需要考虑，如果在背包问题中，包的容量为1000，物品数为100，那么需要考虑2^100种情况,这个数大约为10的30次方。</p><p>而如果用动态规划，最多大概只有1000*100 = 100000个不同的问题，这和10的30次方比起来优势是很明显的。而实际情况并不会出现那么多不同的问题，比如在金矿模型中，如果所有的金矿所需人口都是1000个人，那么问题总数大约只有100个。</p><p>非正式地，我们可以很容易得到动态规划所需时间，如果共有questionCount个相同的子问题，而每一个问题需要面对chooseCount种选择时，我们所需时间就为questionCount * chooseCount个常数。在金矿模型中，子问题最多有大概people * n 个(其中people是用于开采金矿的总人数，n是金矿的总数)，因此questionCount = people * n，而就像国王需要考虑是采用左部下的结果还是采用右部下的结果一样，每个问题面对两个选择，因此chooseCount = 2,所以程序运行时间为 T = O(questionCount * chooseCount) =O(people * n)，别忘了实际上需要的时间小于这个值，根据所遇到的具体情况有所不同。</p><hr><p>这就是动态规划的魔力，它减少了大量的计算，因此我们需要动态规划！</p><h1 id="动态规划的思考角度"><a href="#动态规划的思考角度" class="headerlink" title="动态规划的思考角度"></a>动态规划的思考角度</h1><p>那么什么是动态规划呢？我个人觉得，如果一个解决问题的方法满足上面六个思考点中的前四个，那么这个方法就属于动态规划。而在思考动态规划方法时，后两点同样也是需要考虑的。</p><p>面对问题要寻找动态规划的方法，首先要清楚一点，动态规划不是算法，它是一种方法，它是在一件事情发生的过程中寻找最优值的方法，因此，我们需要对这件事情所发生的过程进行考虑。而通常我们从过程的最后一步开始考虑，而不是先考虑过程的开始。</p><p>打个比方，上面的挖金矿问题，我们可以认为整个开采过程是从西至东进行开采的（也就是从第0座开始），那么总有面对最后一座金矿的时候（第9座），对这座金矿不外乎两个选择，开采与不开采，在最后一步确定时再去确定倒数第二步，直到考虑第0座金矿（过程的开始）。</p><p>而过程的开始，也就是考虑的最后一步，就是边界。</p><p>因此在遇到一个问题想用动态规划的方法去解决时，不妨先思考一下这个过程是怎样的，然后考虑过程的最后一步是如何选择的，通常我们需要自己去构造一个过程，比如后面的练习。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那么遇到问题如何用动态规划去解决呢？根据上面的分析我们可以按照下面的步骤去考虑：</p><ol><li>构造问题所对应的过程。</li><li>思考过程的最后一个步骤，看看有哪些选择情况。</li><li>找到最后一步的子问题，确保符合“子问题重叠”，把子问题中不相同的地方设置为参数。</li><li>使得子问题符合“最优子结构”。</li><li>找到边界，考虑边界的各种处理方式。</li><li>确保满足“子问题独立”，一般而言，如果我们是在多个子问题中选择一个作为实施方案，而不会同时实施多个方案，那么子问题就是独立的。</li><li>考虑如何做备忘录。</li><li>分析所需时间是否满足要求。</li><li>写出转移方程式。 </li></ol><hr><p>注：参考<a href="http://my.oschina.net/dadou/blog/493187" target="_blank" rel="noopener">易懂动态规划讲解</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配KMP算法</title>
      <link href="/2016/05/04/kmp-algorithms/"/>
      <url>/2016/05/04/kmp-algorithms/</url>
      
        <content type="html"><![CDATA[<p>字符串匹配是计算机的基本任务之一。</p><h2 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”？</p><pre><code>BBC ABCDAB ABCDABCDABDExABCDABD</code></pre><p>首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。</p><pre><code>BBC ABCDAB ABCDABCDABDE x ABCDABD</code></pre><p>因为B与A不匹配，搜索词再往后移。</p><pre><code>BBC ABCDAB ABCDABCDABDE    |    ABCDABD</code></pre><p>就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。</p><pre><code>BBC ABCDAB ABCDABCDABDE    ||    ABCDABD</code></pre><p>接着比较字符串和搜索词的下一个字符，还是相同。</p><pre><code>BBC ABCDAB ABCDABCDABDE    ||||||x    ABCDABD</code></pre><p>直到字符串有一个字符，与搜索词对应的字符不相同为止。</p><pre><code>BBC ABCDAB ABCDABCDABDE     x     ABCDABD</code></pre><p>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p><h3 id="ruby代码实现"><a href="#ruby代码实现" class="headerlink" title="ruby代码实现"></a>ruby代码实现</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(s, t)</span></span></span><br><span class="line">  i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; s.size &amp;&amp; j &lt; t.size</span><br><span class="line">    <span class="keyword">if</span> s[i] == t[j]      <span class="comment"># 两字母相等则继续</span></span><br><span class="line">      i, j = i + <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>       <span class="comment"># 指针后退重新开始匹配</span></span><br><span class="line">      i = i - j + <span class="number">1</span>    <span class="comment"># i退回到上次匹配首位的下一位</span></span><br><span class="line">      j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> j == t.size</span><br><span class="line">    <span class="keyword">return</span> i - j</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>我们基于上面的阐述，继续来看这个字符串匹配问题。</p><pre><code>BBC ABCDAB ABCDABCDABDE    ||||||x    ABCDABD</code></pre><p>一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。</p><table><thead><tr><th>搜索词</th><th>A</th><th>B</th><th>C</th><th>D</th><th>A</th><th>B</th><th>D</th></tr></thead><tbody><tr><td>部分匹配值</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td></tr></tbody></table><p>怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了</p><pre><code>BBC ABCDAB ABCDABCDABDE    ||||||x    ABCDABD</code></pre><p>已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：</p><pre><code>移动位数 = 已匹配的字符数 - 对应的部分匹配值</code></pre><p>因为 6 - 2 等于4，所以将搜索词向后移动4位。</p><pre><code>BBC ABCDAB ABCDABCDABDE        ||x        ABCDABD</code></pre><p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。</p><pre><code>BBC ABCDAB ABCDABCDABDE          x          ABCDABD</code></pre><p>因为空格与A不匹配，继续后移一位。</p><pre><code>BBC ABCDAB ABCDABCDABDE           ||||||x           ABCDABD</code></pre><p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。</p><pre><code>BBC ABCDAB ABCDABCDABDE               |||||||               ABCDABD</code></pre><p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。</p><h3 id="部分匹配表"><a href="#部分匹配表" class="headerlink" title="部分匹配表"></a>部分匹配表</h3><p>下面介绍《部分匹配表》是如何产生的。<br>首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p><pre><code>字符串：&quot;bread&quot;前缀：b, br, bre, brea后缀：read, ead, ad, d</code></pre><table><thead><tr><th>搜索词</th><th>A</th><th>B</th><th>C</th><th>D</th><th>A</th><th>B</th><th>D</th></tr></thead><tbody><tr><td>部分匹配值</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td></tr><tr><td>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例：</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>“A”的前缀和后缀都为空集，共有元素的长度为0；</li><li>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</li><li>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</li><li>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</li><li>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</li><li>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</li><li>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</li></ul><pre><code>BBC ABCDAB ABCDABCDABDE           ||||||x           ABCDABD</code></pre><p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p><p>Python实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pmt</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    PartialMatchTable</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    prefix = [s[:i+<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) - <span class="number">1</span>)]</span><br><span class="line">    postfix = [s[i+<span class="number">1</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) - <span class="number">1</span>)]</span><br><span class="line">    intersection = list(set(prefix) &amp; set(postfix))</span><br><span class="line">    <span class="keyword">if</span> intersection:</span><br><span class="line">        <span class="keyword">return</span> len(intersection[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmp</span><span class="params">(s, target)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(s) - len(target) + <span class="number">1</span>:</span><br><span class="line">        match = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(target)):</span><br><span class="line">            <span class="keyword">if</span> s[i + j] != target[j]:</span><br><span class="line">                match = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> match:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 移动位数 = 已匹配的字符数 - 对应的部分匹配值</span></span><br><span class="line">        <span class="keyword">if</span> j:</span><br><span class="line">            i += j - pmt(target[:j])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>注：参考阮一峰老师<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">《字符串匹配KMP算法》</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一致性哈希算法</title>
      <link href="/2016/04/21/hash-algorithms/"/>
      <url>/2016/04/21/hash-algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>本题出自<strong>Tencent2012笔试题附加题</strong>和<strong>Baidu2016春招笔试题（运维开发）</strong>。</p><p><strong>问题描述：</strong>例如某网站有n个服务器，为了方便用户的访问会在服务器上缓存数据，因此用户每次访问的时候最好能保持同一台服务器。</p><p>已有的做法是根据ServerIPIndex[IpAddr%n]得到请求的服务器，这种方法很方便将用户分到不同的服务器上去。但是如果一台服务器死掉了，那么n就变为了n-1，那么ServerIPIndex[IpAddr%n]与ServerIPIndex[IpAddr%(n-1)]基本上都不一样了，所以大多数用户的请求都会转到其他服务器，这样会发生大量访问错误。</p><p>问： 如何改进或者换一种方法，使得：</p><ol><li>一台服务器死掉后，不会造成大面积的访问错误；</li><li>原有的访问基本还是停留在同一台服务器上；</li><li>尽量考虑负载均衡。</li></ol><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><ol><li>最直观的办法还是模余方法：假设有N台服务器，现在完好的是M(M&lt;=N)，先用N求模，如果不落在完好的机器上，然后再用N-1求模，直到M。这种方式对于坏的机器不多的情况下，具有更好的稳定性。</li><li>一致性Hash算法。</li></ol><h1 id="一致性Hash算法简介"><a href="#一致性Hash算法简介" class="headerlink" title="一致性Hash算法简介"></a>一致性Hash算法简介</h1><h2 id="算法背景"><a href="#算法背景" class="headerlink" title="算法背景"></a>算法背景</h2><p><a href="https://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">一致性Hash算法</a>在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。</p><h2 id="基本场景"><a href="#基本场景" class="headerlink" title="基本场景"></a>基本场景</h2><p>比如你有N个cache服务器（后面简称cache），那么如何将一个对象object映射到N个cache上呢，你很可能会采用类似下面的通用方法计算object的hash值，然后均匀的映射到到N个cache：</p><pre><code>hash(object) % N</code></pre><p>一切都运行正常，再考虑如下的两种情况：</p><ol><li><p>一个cache服务器m down掉了（在实际应用中必须要考虑这种情况），这样所有映射到cache m的对象都会失效，需要把cache m 从cache中移除，这时候cache是N-1台，映射公式变成了：</p><pre><code>hash(object) % (N-1)</code></pre></li><li><p>由于访问加重，需要添加cache，这时候cache是N+1台，映射公式变成了：</p><pre><code>hash(object) % (N+1)</code></pre></li></ol><p>1和2意味着突然之间几乎所有的cache都失效了。对于服务器而言，这是一场灾难，洪水般的访问都会直接冲向后台服务器；再来考虑第三个问题，由于硬件能力越来越强，你可能想让后面添加的节点多做点活，显然上面的hash算法也做不到。</p><p>有什么方法可以改变这个状况呢，这就是consistent hashing。</p><h2 id="Hash算法和单调性"><a href="#Hash算法和单调性" class="headerlink" title="Hash算法和单调性"></a>Hash算法和单调性</h2><p>Hash 算法的一个衡量指标是单调性（ Monotonicity ），定义如下：</p><p><strong>单调性</strong>是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</p><p>容易看到，上面的简单 hash 算法 <code>hash(object) % N</code> 难以满足单调性要求。</p><h2 id="consistent-hashing算法的原理"><a href="#consistent-hashing算法的原理" class="headerlink" title="consistent hashing算法的原理"></a>consistent hashing算法的原理</h2><p>consistent hashing 是一种 hash 算法，简单的说，在移除 / 添加一个 cache 时，它能够尽可能小的改变已存在 key 映射关系，尽可能的满足单调性的要求。</p><p>下面就来按照 5 个步骤简单讲讲 consistent hashing 算法的基本原理。</p><h3 id="环形空间"><a href="#环形空间" class="headerlink" title="环形空间"></a>环形空间</h3><p>考虑通常的 hash 算法都是将 value 映射到一个 32 为的 key 值，也即是 0~2^32-1 次方的数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 2^32-1 ）相接的圆环，如下图所示的那样。</p><p><img src="/images/hash1.jpg" alt="hash1"></p><h3 id="把对象映射到hash空间"><a href="#把对象映射到hash空间" class="headerlink" title="把对象映射到hash空间"></a>把对象映射到hash空间</h3><p>接下来考虑 4 个对象 object1~object4 ，通过 hash 函数计算出的 hash 值 key 在环上的分布如图所示。</p><pre><code>hash(object1) = key1;……hash(object4) = key4;</code></pre><p><img src="/images/hash2.jpg" alt="hash2"></p><h3 id="把cache映射到hash空间"><a href="#把cache映射到hash空间" class="headerlink" title="把cache映射到hash空间"></a>把cache映射到hash空间</h3><p>Consistent hashing 的基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中，并且使用相同的 hash 算法。</p><p>假设当前有 A,B 和 C 共 3 台 cache ，那么其映射结果将如图 3 所示，他们在 hash 空间中，以对应的 hash 值排列。</p><pre><code>hash(cache A) = key A;……hash(cache C) = key C;</code></pre><p><img src="/images/hash3.jpg" alt="hash3"></p><p>说到这里，顺便提一下 cache 的 hash 计算，一般的方法可以使用 cache 机器的 IP 地址或者机器名作为 hash 输入。</p><h3 id="把对象映射到cache"><a href="#把对象映射到cache" class="headerlink" title="把对象映射到cache"></a>把对象映射到cache</h3><p>现在 cache 和对象都已经通过同一个 hash 算法映射到 hash 数值空间中了，接下来要考虑的就是如何将对象映射到 cache 上面了。</p><p>在这个环形空间中，如果沿着顺时针方向从对象的 key 值出发，直到遇见一个 cache ，那么就将该对象存储在这个 cache 上，因为对象和 cache 的 hash 值是固定的，因此这个 cache 必然是唯一和确定的。这样不就找到了对象和 cache 的映射方法了吗？！</p><p>依然继续上面的例子，那么根据上面的方法，对象 object1 将被存储到 cache A 上； object2和 object3 对应到 cache C ； object4 对应到 cache B ；</p><h3 id="考察cache的变动"><a href="#考察cache的变动" class="headerlink" title="考察cache的变动"></a>考察cache的变动</h3><p>前面讲过，通过 hash 然后求余的方法带来的最大问题就在于不能满足单调性，当 cache 有所变动时，cache 会失效，进而对后台服务器造成巨大的冲击，现在就来分析分析 consistent hashing 算法。</p><h4 id="移除cache"><a href="#移除cache" class="headerlink" title="移除cache"></a>移除cache</h4><p>考虑假设 cache B 挂掉了，根据上面讲到的映射方法，这时受影响的将仅是那些沿 cache B 逆时针遍历直到下一个 cache （ cache C ）之间的对象，也即是本来映射到 cache B 上的那些对象。</p><p>因此这里仅需要变动对象 object4 ，将其重新映射到 cache C 上即可；参见下图。</p><p><img src="/images/hash4.jpg" alt="hash4"></p><h4 id="添加cache"><a href="#添加cache" class="headerlink" title="添加cache"></a>添加cache</h4><p>再考虑添加一台新的 cache D 的情况，假设在这个环形 hash 空间中， cache D 被映射在对象 object2 和object3 之间。这时受影响的将仅是那些沿 cache D 逆时针遍历直到下一个 cache （ cache B ）之间的对象（它们是也本来映射到 cache C 上对象的一部分），将这些对象重新映射到 cache D 上即可。</p><p>因此这里仅需要变动对象 object2 ，将其重新映射到 cache D 上；参见下图。</p><p><img src="/images/hash5.jpg" alt="hash5"></p><h2 id="Hash算法和平衡性"><a href="#Hash算法和平衡性" class="headerlink" title="Hash算法和平衡性"></a>Hash算法和平衡性</h2><p>考量 Hash 算法的另一个指标是平衡性 (Balance) ，定义如下：</p><blockquote><p><strong>平衡性</strong>是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。</p></blockquote><p>hash 算法并不是保证绝对的平衡，如果 cache 较少的话，对象并不能被均匀的映射到 cache 上，比如在上面的例子中，仅部署 cache A 和 cache C 的情况下，在 4 个对象中， cache A 仅存储了 object1 ，而 cache C 则存储了 object2 、 object3 和 object4 ；分布是很不均衡的。</p><h3 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h3><p>为了解决这种情况， consistent hashing 引入了“虚拟节点”的概念，它可以如下定义：</p><p>“虚拟节点”（ virtual node ）是实际节点在 hash 空间的复制品（ replica ），一实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。</p><p>仍以仅部署 cache A 和 cache C 的情况为例，在图 4 中我们已经看到， cache 分布并不均匀。现在我们引入虚拟节点，并设置“复制个数”为 2 ，这就意味着一共会存在 4 个“虚拟节点”， cache A1, cache A2 代表了 cache A ； cache C1, cache C2 代表了 cache C ；假设一种比较理想的情况，参见下图。</p><p><img src="/images/hash6.jpg" alt="hash6"></p><p>此时，对象到“虚拟节点”的映射关系为：</p><pre><code>objec1-&gt;cache A2 ；objec2-&gt;cache A1 ；objec3-&gt;cache C1 ；objec4-&gt;cache C2 ；</code></pre><p>因此对象 object1 和 object2 都被映射到了 cache A 上，而 object3 和 object4 映射到了 cache C 上；平衡性有了很大提高。</p><p>引入“虚拟节点”后，映射关系就从 <code>{ 对象 -&gt; 节点 }</code> 转换到了 <code>{ 对象 -&gt; 虚拟节点 }</code> 。查询物体所在 cache时的映射关系如下图所示。</p><p><img src="/images/hash7.jpg" alt="hash7"></p><p>“虚拟节点”的 hash 计算可以采用对应节点的 IP 地址加数字后缀的方式。例如假设 cache A 的 IP 地址为202.168.14.241 。</p><p>引入“虚拟节点”前，计算 cache A 的 hash 值：</p><pre><code>Hash(“202.168.14.241”);</code></pre><p>引入“虚拟节点”后，计算“虚拟节”点 cache A1 和 cache A2 的 hash 值：</p><pre><code>Hash(“202.168.14.241#1”); // cache A1Hash(“202.168.14.241#2”); // cache A2</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串 —— Manacher算法</title>
      <link href="/2016/04/02/manacher-algorithms/"/>
      <url>/2016/04/02/manacher-algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h1><p><strong>最长回文子串问题：给定一个字符串，求它的最长回文子串长度。</strong></p><h1 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h1><p>首先用一个非常巧妙的方式，将所有可能的奇数/偶数长度的回文子串都转换成了奇数长度：在每个字符的两边都插入一个特殊的符号。比如 abba 变成 #a#b#b#a#， aba变成 #a#b#a#。</p><p>下面以字符串12212321为例，经过上一步，变成了 S[] = “#1#2#2#1#2#3#2#1#”。</p><p>然后用一个数组 P[i] 来记录以字符S[i]为中心的最长回文子串向左/右扩张的长度（包括S[i]，也就是把该回文串“对折”以后的长度），比如S和P的对应关系：</p><pre><code>S  #  1  #  2  #  2  #  1  #  2  #  3  #  2  #  1  #P  1  2  1  2  5  2  1  4  1  2  1  6  1  2  1  2  1(p.s. 可以看出，P[i]-1正好是原字符串中回文串的总长度）</code></pre><p>那么怎么计算 P[i] 呢？该算法增加两个辅助变量（其实一个就够了，两个更清晰）pos 和 mx，其中 pos 为已知的 {右边界最大} 的回文子串的中心，mx 则为 pos+P[pos]，也就是这个子串的右边界。</p><p>然后可以得到一个非常神奇的结论，这个算法的关键点就在这里了：如果 mx &gt; i，那么 P[i] &gt;= MIN(P[2 * pos - i], mx - i)。就是这个串卡了我非常久。实际上如果把它写得复杂一点，理解起来会简单很多：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记j = 2 * pos - i，也就是说 j 是 i 关于 pos 的对称点(j = pos + (pos - i))</span></span><br><span class="line"><span class="keyword">if</span> (mx - i &gt; P[j]) </span><br><span class="line">    P[i] = P[j];</span><br><span class="line"><span class="keyword">else</span>     <span class="comment"># P[j] &gt;= mx - i</span></span><br><span class="line">    P[i] = mx - i     <span class="comment"># P[i] &gt;= mx - i，取最小值，之后再匹配更新。</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>借助下面的图来理解：</p><p>当 mx - i &gt; P[j] 的时候，以S[j]为中心的回文子串包含在以S[pos]为中心的回文子串中，由于 i 和 j 对称，以S[i]为中心的回文子串必然包含在以S[pos]为中心的回文子串中，所以必有 P[i] = P[j]，见下图。</p><p><img src="/images/Manacher1.png" alt="Manacher1"></p><p>当 P[j] &gt;= mx - i 的时候，以S[j]为中心的回文子串不一定完全包含于以S[pos]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 P[i] &gt;= mx - i。至于mx之后的部分是否对称，就只能老老实实去匹配了。</p><p><img src="/images/Manacher2.png" alt="Manacher2"></p><p>对于 mx &lt;= i 的情况，无法对 P[i]做更多的假设，只能P[i] = 1，然后再去匹配了。</p><p>在这里查看该算法的<a href="https://github.com/sagittariusYX/leetcode/blob/master/ruby/longest_palindromic_substring.rb" target="_blank" rel="noopener">ruby实现</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux守护进程的启动方法</title>
      <link href="/2016/03/22/linux-daemon-start/"/>
      <url>/2016/03/22/linux-daemon-start/</url>
      
        <content type="html"><![CDATA[<h1 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h1><p>当Web应用写好后，下一件事就是启动，让它一直在后台运行，举例来说，你在命令行下启动一个rails server：</p><pre><code>$ bundle exec rails server</code></pre><p>看上去一切正常，所有人都能愉快地访问3000端口了。但是，一旦你退出命令行窗口，这个应用就跟着一起退出了，此时无法访问url。</p><p>怎么才能让它变成系统的守护进程（daemon），成为一种服务（service），一直在那里运行呢？</p><h1 id="前台任务与后台任务"><a href="#前台任务与后台任务" class="headerlink" title="前台任务与后台任务"></a>前台任务与后台任务</h1><p>像上面那样启动网站，叫做”前台任务”（foreground job）。它会独占命令行窗口，只有运行完了或者手动中止，才能执行其他命令。</p><p>变成守护进程的第一步，就是把它改成”后台任务”（background job）。</p><pre><code>$ bundle exec rails server &amp;</code></pre><p>只要在命令的尾部加上<code>&amp;</code>，启动的进程就会变成“后台任务”。如果想让正在运行的“前台任务”变成“后台任务”，可以先按<code>ctrl + z</code>，然后执行<code>bg</code>命令（让最近一个暂停的“后台任务”继续执行）。</p><p>后台任务有两个特点：</p><blockquote><ol><li>继承当前 session （对话）的标准输出（stdout）和标准错误（stderr）。<br>因此，后台任务的所有输出依然会同步地在命令行下显示。</li><li>不再继承当前 session 的标准输入（stdin）。你无法向这个任务输入指令了。<br>如果它试图读取标准输入，就会暂停执行（halt）。</li></ol></blockquote><p>可以看到，”后台任务”与”前台任务”的本质区别只有一个：是否继承标准输入。所以，执行后台任务的同时，用户还可以输入其他命令。</p><h1 id="SIGNUP信号"><a href="#SIGNUP信号" class="headerlink" title="SIGNUP信号"></a>SIGNUP信号</h1><p>变为”后台任务”后，一个进程是否就成为了守护进程呢？或者说，用户退出 session 以后，”后台任务”是否还会继续执行？</p><p>Linux系统是这样设计的。</p><blockquote><ol><li>用户准备退出session</li><li>系统向该session发出SIGHUP信号</li><li>session将SIGHUP信号发给所有子进程</li><li>子进程收到SIGHUP信号后，自动退出</li></ol></blockquote><p>上面的流程解释了，为什么”前台任务”会随着 session 的退出而退出：因为它收到了<code>SIGNUP</code>信号。</p><p>那么，“后台任务”是否也会收到<code>SIGNUP</code>信号？</p><p>这是由Shell的<code>huponexit</code>参数决定的。</p><pre><code>$ shopt | grep huponexit</code></pre><p>执行上面的命令，就会看到<code>huponexit</code>参数的值。</p><p>大多数Linux系统，这个参数默认关闭（<code>off</code>）。因此，session退出的时候，不会把SIGHUP信号发给”后台任务”。所以，一般来说，”后台任务”不会随着session一起退出。</p><h1 id="disown命令"><a href="#disown命令" class="headerlink" title="disown命令"></a>disown命令</h1><p>通过”后台任务”启动”守护进程”并不保险，因为有的系统的<code>huponexit</code>参数可能是打开的（<code>on</code>）。</p><p>更保险的方法是使用<code>disown</code>命令。它可以将指定任务从”后台任务”列表（<code>jobs</code>命令的返回结果）之中移除。一个”后台任务”只要不在这个列表之中，session就肯定不会向它发出<code>SIGHUP</code>信号。</p><pre><code>$ bundle exec rails server &amp;$ disown</code></pre><p>执行上面的命令以后，<code>Rails</code>进程就被移出了”后台任务”列表。你可以执行<code>jobs</code>命令验证，输出结果里面，不会有这个进程。</p><p><code>disown</code>的用法如下：</p><pre><code># 移出最近一个正在执行的后台任务$ disown# 移出所有正在执行的后台任务$ disown -r# 移出所有后台任务$ disown -a# 不移出后台任务，但是让它们不会收到SIGHUP信号$ disown -h# 根据jobId，移出指定的后台任务$ disown %2$ disown -h %2</code></pre><h1 id="nohup命令"><a href="#nohup命令" class="headerlink" title="nohup命令"></a>nohup命令</h1><p>还有比<code>disown</code>更方便的命令，就是<code>nohup</code>。</p><pre><code>$ nohup bundle exec rails server &amp;</code></pre><p><code>nohup</code>命令对<code>Rails</code>进程做了三件事：</p><blockquote><ol><li>阻止SIGHUP信号发到这个进程。</li><li>关闭标准输入。该进程不再能够接收任何输入，即使运行在前台。</li><li>重定向标准输出和标准错误到文件nohup.out。</li></ol></blockquote><p>也就是说，<code>nohup</code>命令实际上将子进程与它所在的session分离了。</p><p>注意，<code>nohup</code>命令不会自动把进程变为”后台任务”，所以必须加上<code>&amp;</code>符号。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
